(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: May, 2012
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/stdlib.sats"

(* ****** ****** *)

implement{
} getenv_gc
  (name) = let
  val fpfstr = getenv (name)
  val str2 = strptr0_copy (fpfstr.1)
  prval () = fpfstr.0 (fpfstr.1)
in
  str2
end // end of [getenv_gc]

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_malloc_libc_exn
  (atstype_size bsz)
{
  void *p ;
  p = atslib_malloc_libc(bsz) ;
  if (!p) {
    fprintf(stderr, "exit(ATSLIB): [malloc] failed\n") ; exit(1) ;
  } // end of [if]
  return p ;
} /* end of [atslib_malloc_libc_exn] */
%}

(* ****** ****** *)

(* end of [stdlib.dats] *)(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: May, 2012
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/stdio.sats"

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_fopen_exn
(
  atstype_string path
, atstype_string mode
) {
  FILE *filp ;
  filp = fopen ((char*)path, (char*)mode) ;
  if (!filp) ATSLIBfailexit("fopen") ; // HX: failure
  return filp ;
} /* end of [atslib_fopen_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_fclose_exn
  (atstype_ptr filp) {
  int err ;
  err = fclose ((FILE*)filp) ;
  if (0 > err) ATSLIBfailexit("fclose") ;
  return ;
} /* end of [atslib_fclose_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_fflush_exn
(
  atstype_ptr filp
) {
  int err = fflush((FILE*)filp) ;
  if (0 > err) ATSLIBfailexit("fflush") ;
  return ;
} /* end of [atslib_fflush_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_fputc_exn
(
  atstype_int c, atstype_ptr filp
) {
  int err ;
  err = fputc(c, (FILE*)filp) ;
  if (0 > err) {
    ATSLIBfailexit("fputc") ; // abnormal exit
  } // end of [if]
  return ;  
} /* end of [atslib_fputc_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_fgets_exn
(
  atstype_ptr buf0
, atstype_int bsz0
, atstype_ptr filp
) {
  char *buf, *pres ;
  buf = (char*)buf0 ;
  pres = fgets(buf, (int)bsz0, (FILE*)filp) ;
  if (!pres)
  {
    if (feof((FILE*)filp))
    {
      buf[0] = '\000' ; // EOF is reached
    } else {
      ATSLIBfailexit("fgets") ; // abnormal exit
    } // end of [if]
  } // end of [if]
  return ;  
} /* end of [atslib_fgets_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_fgets_gc
(
  atstype_int bsz0
, atstype_ptr filp0
)
{
  int bsz = bsz0 ;
  FILE *filp = (FILE*)filp0 ;
  int ofs = 0, ofs2 ;
  char *buf, *buf2, *pres ;
  buf = atspre_malloc_gc(bsz) ;
  while (1) {
    buf2 = buf+ofs ;
    pres = fgets(buf2, bsz-ofs, filp) ;
    if (!pres)
    {
      if (feof(filp))
      {
        *buf2 = '\000' ; return buf ;
      } else {
        atspre_mfree_gc(buf) ; return (char*)0 ;
      } // end of [if]
    }
    ofs2 = strlen(buf2) ;
    if (ofs2==0) return buf ;
    ofs += ofs2 ; // HX: ofs > 0
    if (buf[ofs-1]=='\n') return buf ;
    bsz *= 2 ; buf2 = buf ;
    buf = atspre_malloc_gc(bsz) ;
    memcpy(buf, buf2, ofs) ;
    atspre_mfree_gc(buf2) ;
  } // end of [while]
  return buf ; // HX: deadcode
} /* end of [atslib_fgets_gc] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_fputs_exn
(
  atstype_string str, atstype_ptr filp
) {
  int err ;
  err = fputs((char*)str, (FILE*)filp) ;
  if (0 > err) {
    ATSLIBfailexit("fputs") ; // abnormal exit
  } // end of [if]
  return ;  
} /* end of [atslib_fputs_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_puts_exn
(
  atstype_string str
) {
  int err ;
  err = puts((char*)str) ;
  if (0 > err) {
    ATSLIBfailexit("puts") ; // abnormal exit
  } // end of [if]
  return ;  
} /* end of [atslib_puts_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_popen_exn
(
  atstype_string cmd
, atstype_string type
) {
  FILE *filp ;
  filp = popen((char*)cmd, (char*)type) ;
  if (!filp) {
    ATSLIBfailexit("popen") ; // abnormal exit
  } // end of [if]
  return filp ;
} /* end of [atslib_popen_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_int
atslib_pclose_exn
(
  atstype_ptr filp
) {
  int res ;
  res = pclose((FILE*)filp) ;
  if (0 > res) {
    ATSLIBfailexit("pclose") ; // abnormal exit
  } // end of [if]
  return res ;
} /* end of [atslib_pclose_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_tmpfile_exn(
) {
  FILE *filp = tmpfile() ;
  if (!filp) ATSLIBfailexit("tmpfile") ;
  return (filp) ;
} /* end of [atslib_tmpfile_exn] */
%}

(* ****** ****** *)

(* end of [stdio.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/string.sats"

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_strerror_r_gc
(
  atstype_int errnum
) {
  char *p_err ;
  int bsz ;
  int err, myeno ;
//
// HX: [64] is chosen nearly randomly
//
  bsz = 64 ;
  p_err = (char*)0 ;
//
  while (1)
  {
    p_err = atspre_malloc_gc(bsz) ;
    err = atslib_strerror_r(errnum, p_err, bsz) ; myeno = errno ;
    if (err==0) return p_err ;
    if (myeno != ERANGE) break ;
    atspre_mfree_gc(p_err) ; bsz = 2 * bsz ;
  }
//
  return p_err ;
//
} /* end of [atslib_strerror_r_gc] */
%}

(* ****** ****** *)

(* end of [string.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: May, 2012
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libc/SATS/time.sats"

(* ****** ****** *)

implement{
} ctime_r_gc (tval) = let
//
val bsz = g1i2u (CTIME_BUFSZ)
val (pf, pfgc | p) = malloc_gc (bsz)
//
val p1 = ctime_r (pf | tval, p)
//
in
//
if p1 > 0 then let
  prval ctime_v_succ (pf) = pf
in
  $UN.castvwtp0{Strptr1}((pf, pfgc | p))
end else let
  prval ctime_v_fail (pf) = pf
  val () = mfree_gc (pf, pfgc | p)
in
  strptr_null ()
end // end of [if]
//
end // end of [ctime_r_gc]

(* ****** ****** *)

(* end of [stdlib.dats] *)(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: October, 2014
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/float.sats"

(* ****** ****** *)

(* end of [float.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/math.sats"

(* ****** ****** *)

implement isfinite<float> = isfinite_float
implement isfinite<double> = isfinite_double
implement isfinite<ldouble> = isfinite_ldouble

implement isnormal<float> = isnormal_float
implement isnormal<double> = isnormal_double
implement isnormal<ldouble> = isnormal_ldouble

implement fpclassify<float> = fpclassify_float
implement fpclassify<double> = fpclassify_double
implement fpclassify<ldouble> = fpclassify_ldouble

(* ****** ****** *)
//
implement isinf<float> = isinf_float
implement isinf<double> = isinf_double
implement isinf<ldouble> = isinf_ldouble
//
implement isnan<float> = isnan_float
implement isnan<double> = isnan_double
implement isnan<ldouble> = isnan_ldouble
//
(* ****** ****** *)

implement ceil<float> = ceil_float
implement ceil<double> = ceil_double
implement ceil<ldouble> = ceil_ldouble

(* ****** ****** *)

implement floor<float> = floor_float
implement floor<double> = floor_double
implement floor<ldouble> = floor_ldouble

(* ****** ****** *)

implement round<float> = round_float
implement round<double> = round_double
implement round<ldouble> = round_ldouble

(* ****** ****** *)

implement trunc<float> = trunc_float
implement trunc<double> = trunc_double
implement trunc<ldouble> = trunc_ldouble

(* ****** ****** *)

implement fmod<float> = fmod_float
implement fmod<double> = fmod_double
implement fmod<ldouble> = fmod_ldouble

(* ****** ****** *)
//
implement fmax<float> = fmax_float
implement fmax<double> = fmax_double
implement fmax<ldouble> = fmax_ldouble
//
implement fmin<float> = fmin_float
implement fmin<double> = fmin_double
implement fmin<ldouble> = fmax_ldouble
//
(* ****** ****** *)

implement fdim<float> = fdim_float
implement fdim<double> = fdim_double
implement fdim<ldouble> = fdim_ldouble

(* ****** ****** *)

implement fma<float> = fma_float
implement fma<double> = fma_double
implement fma<ldouble> = fma_ldouble

(* ****** ****** *)
//
implement sqrt<float> = sqrt_float
implement sqrt<double> = sqrt_double
implement sqrt<ldouble> = sqrt_ldouble
//
implement cbrt<float> = cbrt_float
implement cbrt<double> = cbrt_double
implement cbrt<ldouble> = cbrt_ldouble
//
(* ****** ****** *)

implement pow<float> = pow_float
implement pow<double> = pow_double
implement pow<ldouble> = pow_ldouble

(* ****** ****** *)

implement exp<float> = exp_float
implement exp<double> = exp_double
implement exp<ldouble> = exp_ldouble

(* ****** ****** *)

implement log<float> = log_float
implement log<double> = log_double
implement log<ldouble> = log_ldouble
implement log10<float> = log10_float
implement log10<double> = log10_double
implement log10<ldouble> = log10_ldouble

(* ****** ****** *)
//
implement sin<float> = sin_float
implement sin<double> = sin_double
implement sin<ldouble> = sin_ldouble
//
implement cos<float> = cos_float
implement cos<double> = cos_double
implement cos<ldouble> = cos_ldouble
//
implement tan<float> = tan_float
implement tan<double> = tan_double
implement tan<ldouble> = tan_ldouble
//
(* ****** ****** *)
//
implement asin<float> = asin_float
implement asin<double> = asin_double
implement asin<ldouble> = asin_ldouble
//
implement acos<float> = acos_float
implement acos<double> = acos_double
implement acos<ldouble> = acos_ldouble
//
implement atan<float> = atan_float
implement atan<double> = atan_double
implement atan<ldouble> = atan_ldouble
//
implement atan2<float> = atan2_float
implement atan2<double> = atan2_double
implement atan2<ldouble> = atan2_ldouble
//
(* ****** ****** *)
//
implement sinh<float> = sinh_float
implement sinh<double> = sinh_double
implement sinh<ldouble> = sinh_ldouble
//
implement cosh<float> = cosh_float
implement cosh<double> = cosh_double
implement cosh<ldouble> = cosh_ldouble
//
implement tanh<float> = tanh_float
implement tanh<double> = tanh_double
implement tanh<ldouble> = tanh_ldouble
//
(* ****** ****** *)
//
implement asinh<float> = asinh_float
implement asinh<double> = asinh_double
implement asinh<ldouble> = asinh_ldouble
//
implement acosh<float> = acosh_float
implement acosh<double> = acosh_double
implement acosh<ldouble> = acosh_ldouble
//
implement atanh<float> = atanh_float
implement atanh<double> = atanh_double
implement atanh<ldouble> = atanh_ldouble
//
(* ****** ****** *)

(* end of [math.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/fcntl.sats"

(* ****** ****** *)

%{
extern
atstype_int
atslib_fildes_iget_int
(
  atstype_int fd
) {
  int flags ;
  flags = fcntl (fd, F_GETFD) ;
  if (flags < 0) return -1 ; // [fd2] not in use
  return fd ;
} // end of [atslib_fildes_iget_int]
%}

(* ****** ****** *)

(* end of [fcntl.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libc/SATS/dirent.sats"

(* ****** ****** *)

implement{}
dirent$PC_NAME_MAX ((*void*)) = 256

(* ****** ****** *)

implement{}
dirent_get_d_name_gc
  (ent) = let
//
val (
  fpf | str
) = dirent_get_d_name (ent)
val str2 = strptr1_copy (str)
prval () = fpf (str)
//
in
  str2
end // end of [dirent_get_d_name_gc]

implement{}
direntp_get_d_name_gc
  (entp) = let
//
val (
  pf, fpf | p
) = direntp_get_viewptr (entp)
val str2 = dirent_get_d_name_gc<> (!p)
prval () = minus_addback (fpf, pf | entp)
//
in
  str2
end // end of [direntp_get_d_name_gc]

(* ****** ****** *)

implement{}
compare_dirent_string
  (ent1, str2) = let
//
val
(
  fpf1 | str1
) = dirent_get_d_name (ent1)
val sgn = compare_string_string ($UN.strptr2string(str1), str2)
prval () = fpf1 (str1)
//
in
  sgn
end // end of [compare_dirent_string]

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_opendir_exn
(
  atstype_string dname
) {
  DIR *dirp ;
  dirp = opendir((char*)dname) ;
  if (!dirp) ATSLIBfailexit("opendir") ;
  return dirp ; // [opendir] succeeded
} // end of [atslib_opendir_exn]
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_closedir_exn
(
  atstype_ptr dirp
) {
  int err = closedir((DIR*)dirp) ;
  if (err < 0) ATSLIBfailexit("closedir") ;
  return ; // [closedir] succeeded
} // end of [atslib_closedir_exn]
%}

(* ****** ****** *)

implement
{}(*tmp*)
readdir_r_gc
  (dirp) = let
//
val ofs = $extfcall
(
  Size_t
, "offsetof"
, $extval (int, "atslib_dirent_type")
, $extval (int, "d_name")
)
//
val bsz = ofs + i2sz(dirent$PC_NAME_MAX()+1)
val [l:addr] (pf, pfgc | p) = malloc_gc (bsz)
prval pf = $UN.castview0{(dirent?)@l}(pf)
var res: ptr
val err = readdir_r (dirp, !p, res)
//
in
//
if res > 0 then
  $UN.castvwtp0{Direntp1}@(pf, pfgc | p)
else let
  prval () = opt_clear{dirent}(!p)
  val () = ptr_free{dirent?}(pfgc, pf | p)
in
  $UN.castvwtp0{Direntp0}(the_null_ptr)
end (* end of [if] *)
//
end // end of [readdir_r_gc]

(* ****** ****** *)

(* end of [dirent.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: January, 2014
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/errno.sats"

(* ****** ****** *)

(* end of [errno.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/strings.sats"

(* ****** ****** *)
//
// HX-2013-03: it is still empty
//
(* ****** ****** *)

(* end of [strings.dats] *)(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: May, 2014
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/alloca.sats"

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

(*
implement
ptr_alloca_tsz
  {a}{dummy}
  (pf | tsz) = let
//
val [l:addr]
  (pfat, fpfat | p) = alloca (pf | tsz)
//
prval pfat =
  $UN.castview0{(a?)@l}(pfat)
prval fpfat =
  $UN.castview0{(a?)@l->void@dummy}(fpfat)
//
in
  (pfat, fpfat | p)
end // end of [ptr_alloca_tsz]
*)

(* ****** ****** *)

(*
implement
array_ptr_alloca_tsz
  {a}{dummy}{n}
  (pf | asz, tsz) = let
//
val [l:addr]
  (pfat, fpfat | p) = alloca (pf | asz*tsz)
//
prval pfat =
  $UN.castview0{array(a?,n)@l}(pfat)
prval fpfat =
  $UN.castview0{array(a?,n)@l->void@dummy}(fpfat)
//
in
  (pfat, fpfat | p)
end // end of [array_ptr_alloca_tsz]
*)

(* ****** ****** *)

(* end of [alloca.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/errno.sats"
staload "libc/SATS/fcntl.sats"
staload "libc/SATS/unistd.sats"

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_close_exn
(
  atstype_int fd
) {
  int err ;
  err = atslib_close(fd) ;
  if (0 > err) ATSLIBfailexit("close") ;
  return ;
} /* end of [atslib_close_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_int
atslib_dup2_fildes
(
  atstype_int fd, atstype_int fd2
) {
  int flags ;
//
  flags = fcntl(fd, F_GETFD) ;
//
  if (flags >= 0) {
    errno = EINVAL ; return -1 ; // [fd2] in use
  } /* end of [if] */
//
  return atslib_dup2(fd, fd2) ;
//
} /* end of [atslib_dup2_fildes] */
%}

(* ****** ****** *)

%{
extern
atstype_strptr
atslib_getcwd_gc (
) {
  char *p_cwd ;
  int bsz ;
  int myeno ;
  char *p2_cwd ;
//
// HX: [64] is chosen nearly randomly
//
  bsz = 64 ;
  p_cwd = (char*)0 ;
//
  while (1)
  {
    p_cwd = atspre_malloc_gc(bsz) ;
    p2_cwd = atslib_getcwd(p_cwd, bsz) ; myeno = errno ;
    if (p2_cwd != 0) return p_cwd ; else atspre_mfree_gc(p_cwd) ;
    if (myeno != ERANGE) break ;
    bsz = 2 * bsz ;
  }
//
  return (char*)0 ;
//
} /* end of [atslib_getcwd_gc] */
%}

(* ****** ****** *)

%{
extern
atstype_strptr
atslib_getlogin_r_gc (
) {
  char *p_uid ;
  int bsz ;
  int err, myeno ;
//
// HX: [16] is chosen nearly randomly
//
  bsz = 16 ;
  p_uid = (char*)0 ;
//
  while (1)
  {
    p_uid = atspre_malloc_gc(bsz) ;
    err = atslib_getlogin_r(p_uid, bsz) ; myeno = errno ;
    if (err==0) return p_uid ; else atspre_mfree_gc(p_uid) ;
    if (myeno != ERANGE) break ;
    bsz = 2 * bsz ;
  }
//
  return (char*)0 ;
//
} /* end of [atslib_getlogin_r_gc] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_rmdir_exn
(
  atstype_string path
) {
  int err ;
  err = atslib_rmdir(path) ;
  if (0 > err) ATSLIBfailexit("rmdir") ;
  return ;
} /* end of [atslib_rmdir_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_link_exn
(
  atstype_string old, atstype_string new
) {
  int err ;
  err = atslib_link(old, new) ;
  if (0 > err) ATSLIBfailexit("link") ;
  return ;
} /* end of [atslib_link_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_unlink_exn
(
  atstype_string path
) {
  int err ;
  err = atslib_unlink(path) ;
  if (0 > err) ATSLIBfailexit("unlink") ;
  return ;
} /* end of [atslib_unlink_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_symlink_exn
(
  atstype_string old, atstype_string new
) {
  int err ;
  err = atslib_symlink(old, new) ;
  if (0 > err) ATSLIBfailexit("symlink") ;
  return ;
} /* end of [atslib_symlink_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_strptr
atslib_readlink_gc
(
  atstype_string path
) {
  char *bfp ;
//
// HX: [64] is chosen nearly randomly
//
  int bsz = 64 ;
  ssize_t bsz2 ;
  bfp = (char*)0 ;
//
  while (1)
  {
    bfp = atspre_malloc_gc(bsz) ;
    bsz2 = atslib_readlink(path, bfp, bsz) ;
/*
    fprintf(stderr, "atslib_readlink_gc: bsz2 = %li\n", bsz2) ;
*/
    if (bsz2 < 0) {
      atspre_mfree_gc(bfp) ; break ;
    }
    if (bsz2 < bsz) {
      bfp[bsz2] = '\000' ; return bfp ;
    }
    atspre_mfree_gc(bfp) ; bsz *= 2 ;
  }
//
  return (char*)0 ; // HX: deadcode
//
} /* end of [atslib_readlink_gc] */
%}

(* ****** ****** *)

(* end of [unistd.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: April, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/types.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for staloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)
//
// HX-2014-04-29: it is still empty
//
(* ****** ****** *)

(* end of [types.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/socket.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for staloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/sys/SATS/socket.sats"

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

%{
ATSextern()
atstype_int
atslib_socket_AF_type_exn
(
  sa_family_t af, atstype_int tp
) {
  int
  fildes;
  fildes = socket(af, tp, 0);
  if(0 > fildes) ATSLIBfailexit("socket") ; // HX: failure
  return fildes;
} // end of [atslib_socket_AF_type_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_bind_exn
(
  atstype_int fd
, atstype_ptr addr, socklen_t addrlen
) {
  int
  err;
  err = bind(fd, addr, addrlen);
  if(0 > err) ATSLIBfailexit("bind") ; // HX: failure
  return;
} // end of [atslib_bind_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_listen_exn
(
  atstype_int fd, atstype_int nq
) {
  int
  err;
  err = listen(fd, nq);
  if(0 > err) ATSLIBfailexit("listen") ; // HX: failure
  return;
} // end of [atslib_listen_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_connect_exn
(
  atstype_int fd
, atstype_ptr addr, socklen_t addrlen
) {
  int
  err;
  err = connect(fd, addr, addrlen);
  if(0 > err) ATSLIBfailexit("connect") ; // HX: failure
  return;
} // end of [atslib_connect_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_socket_close_exn
(
  atstype_int fd
) {
  int
  err;
  err = close(fd);
  if(0 > err) ATSLIBfailexit("socket_close") ; // HX: failure
  return;
} // end of [atslib_socket_close_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_shutdown_exn
(
  atstype_int fd, atstype_int how
) {
  int
  err;
  err = shutdown(fd, how);
  if(0 > err) ATSLIBfailexit("shutdown") ; // HX: failure
  return;
} // end of [atslib_shutdown_exn]
%} // end of [%{]

(* ****** ****** *)

(* end of [socket.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: April, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/stat.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for staloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/sys/SATS/stat.sats"

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{(*tmp*)}
mkdirp (path, mode) = let
//
#define NUL '\000'
val dirsep = dirsep_get<> ()
//
fun auxmk
(
  path: string, mode: mode_t
) : int = let
  var st: stat?
  val ret = stat (path, st)
  prval () = opt_clear{stat}(st)
in
  if ret < 0 then mkdir (path, mode) else 0(*isexi*)
end // end of [auxmk]
//
fnx loop
  (p0: ptr, p1: ptr): int = let
  val c = $UN.ptr0_get<char> (p1)
in
//
if (
c != NUL
) then (
  if c = dirsep
    then loop2 (p0, p1) else loop (p0, ptr_succ<char> (p1))
  // end of [if]
) else (
  auxmk ($UN.cast{string}(p0), mode)
) (* end of [if] *)
//
end // end of [loop]
//
and loop2
  (p0: ptr, p1: ptr): int = let
  val () = $UN.ptr0_set<char> (p1, NUL)
  val ret = auxmk ($UN.cast{string}(p0), mode)
  val () = $UN.ptr0_set<char> (p1, dirsep)
in
  if ret >= 0 then loop (p0, ptr_succ<char> (p1)) else ret
end // end of [loop2]
//
val path = string0_copy (path)
//
val p0 = $UN.castvwtp1{ptr}(path)
//
val c0 = $UN.ptr0_get<char> (p0)
val ret =
(
if (
c0 != NUL
) then (
  if c0 = dirsep
    then loop (p0, ptr_succ<char> (p0)) else loop (p0, p0)
  // end of [if]
) else (0)
) : int // end of [val]
//
val ((*freed*)) = strptr_free (path)
//
in
  ret
end // end of [mkdirp]

(* ****** ****** *)

(* end of [stat.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/socket_in.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for staloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/sys/SATS/socket_in.sats"

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_bind_in_exn
(
  atstype_int fd, atstype_ptr addr
) {
  int
  err;
  err =
  bind(
    fd, (const struct sockaddr*)addr, sizeof(struct sockaddr_in)
  ); // end of [connent]
  if(0 > err) ATSLIBfailexit("bind");
  return;
} // end of [atslib_bind_in_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_connect_in_exn
(
  atstype_int fd, atstype_ptr addr
) {
  int
  err;
  err =
  connect(
    fd, (const struct sockaddr*)addr, sizeof(struct sockaddr_in)
  ); // end of [connent]
  if(0 > err) ATSLIBfailexit("connect");
  return;
} // end of [atslib_connect_in_exn]
%} // end of [%{]

(* ****** ****** *)

(* end of [socket_in.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/stat.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

staload
TYPES = "libc/sys/SATS/types.sats"

(* ****** ****** *)
//
typedef dev_t = $TYPES.dev_t
typedef ino_t = $TYPES.ino_t
typedef mode_t = $TYPES.mode_t
typedef nlink_t = $TYPES.nlink_t
//
typedef uid_t = $TYPES.uid_t
typedef gid_t = $TYPES.gid_t
//
typedef off_t = $TYPES.off_t
//
typedef blkcnt_t = $TYPES.blkcnt_t
typedef blksize_t = $TYPES.blksize_t
//
typedef time_t = $TYPES.time_t
//
vtypedef
fildes (i:int) = $TYPES.fildes (i)
//
vtypedef Fildes = $TYPES.Fildes
vtypedef Fildes0 = $TYPES.Fildes0
//
(* ****** ****** *)
//
typedef
stat_struct =
$extype_struct"atslib_stat_struct" of
{
  st_dev= dev_t // device
, st_ino= ino_t // 32-bit file serial number
, st_mode= mode_t // file mode
, st_nlink= nlink_t // link count
, st_uid= uid_t // user ID of the file's owner
, st_gid= gid_t // group ID of the file's group
, st_rdev= dev_t // device number if device
, st_size= off_t // size of file in bytes
, st_blksize= blksize_t // optimal block size for I/O
, st_blocks= blkcnt_t // number 512-byte blocks allocated
, st_atime= time_t // time of last access
, st_mtime= time_t // time of last modification
, st_ctime= time_t // time of last status change
//
, _rest= undefined_t0ype // ...
//
} // end of [stat_struct]
typedef stat = stat_struct
//
(* ****** ****** *)

macdef S_IFMT = $extval (mode_t, "S_IFMT")
macdef S_IFBLK = $extval (mode_t, "S_IFBLK")
macdef S_IFCHR = $extval (mode_t, "S_IFCHR")
macdef S_IFDIR = $extval (mode_t, "S_IFDIR")
macdef S_IFIFO = $extval (mode_t, "S_IFIFO")
macdef S_IFLNK = $extval (mode_t, "S_IFLNK")
macdef S_IFREG = $extval (mode_t, "S_IFREG")
macdef S_IFSOCK = $extval (mode_t, "S_IFSOCK")

(* ****** ****** *)
//
macdef S_IRWXU = $extval (mode_t, "S_IRWXU")
macdef S_IRUSR = $extval (mode_t, "S_IRUSR")
macdef S_IWUSR = $extval (mode_t, "S_IWUSR")
macdef S_IXUSR = $extval (mode_t, "S_IXUSR")
//
macdef S_IRWXG = $extval (mode_t, "S_IRWXG")
macdef S_IRGRP = $extval (mode_t, "S_IRGRP")
macdef S_IWGRP = $extval (mode_t, "S_IWGRP")
macdef S_IXGRP = $extval (mode_t, "S_IXGRP")
//
macdef S_IRWXO = $extval (mode_t, "S_IRWXO")
macdef S_IROTH = $extval (mode_t, "S_IROTH")
macdef S_IWOTH = $extval (mode_t, "S_IWOTH")
macdef S_IXOTH = $extval (mode_t, "S_IXOTH")
//
macdef S_ISUID = $extval (mode_t, "S_ISUID")
macdef S_ISGID = $extval (mode_t, "S_ISGID")
macdef S_ISVTX = $extval (mode_t, "S_ISVTX")
//
(* ****** ****** *)
//
// HX: macros
//
fun S_ISBLK (m: mode_t): bool = "mac#%"
fun S_ISCHR (m: mode_t): bool = "mac#%"
fun S_ISDIR (m: mode_t): bool = "mac#%"
fun S_ISFIFO (m: mode_t): bool = "mac#%"
fun S_ISREG (m: mode_t): bool = "mac#%"
fun S_ISLNK (m: mode_t): bool = "mac#%"
fun S_ISSOCK (m: mode_t): bool = "mac#%"
//
(* ****** ****** *)
//
// HX: (0/1/-1 : false/true/error)
//
fun isfdtype (fildes: int, fdtype: mode_t): int
//
(* ****** ****** *)
//
fun chmod
  (path: NSH(string), mode: mode_t): int = "mac#%"
fun chmod_exn
  (path: NSH(string), mode: mode_t): void = "ext#%"
//
fun fchmod (fd: !Fildes0, mode: mode_t): int = "mac#%"
//
(* ****** ****** *)
//
fun mkdir
  (path: NSH(string), mode: mode_t): int = "mac#%"
fun mkdir_exn
  (path: NSH(string), mode: mode_t): void = "ext#%"
//
(* ****** ****** *)
//
// HX-2014-04: this one is like [mkdir -p]
//
fun{
} mkdirp
  (path: NSH(string), mode: mode_t): int = "mac#%"
//
(* ****** ****** *)
//
fun mkdirat
  (dirfd: int, path: NSH(string), mode: mode_t): int = "mac#%"
//
(* ****** ****** *)
//
fun mkfifo // 0/-1 : succ/fail // errno set
  (path: NSH(string), perm: mode_t): int = "mac#%"
//
(* ****** ****** *)
//
fun stat
(
  path: NSH(string), st: &stat? >> opt (stat, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
fun stat_exn
  (path: NSH(string), st: &stat? >> stat): void = "ext#%"
//
(* ****** ****** *)
//
fun fstat
(
  fd: !Fildes0, st: &stat? >> opt (stat, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
fun fstat_exn
  (fd: !Fildes0, st: &stat? >> stat): void = "ext#%"
//
(* ****** ****** *)
//
fun lstat
(
  path: NSH(string), st: &stat? >> opt (stat, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
fun lstat_exn
  (path: NSH(string), st: &stat? >> stat): void = "ext#%"
//
(* ****** ****** *)

fun umask
  (mask_new: mode_t): mode_t(*old*)  = "mac#%"
// end of [umask]

(* ****** ****** *)

(* end of [stat.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/socket.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

abst@ype
sa_family_t = $extype"sa_family_t"
//
// HX: these are the primary ones:
//
macdef AF_UNIX = $extval (sa_family_t, "AF_UNIX")
macdef AF_INET = $extval (sa_family_t, "AF_INET")
macdef AF_INET6 = $extval (sa_family_t, "AF_INET6")
macdef AF_UNSPEC = $extval (sa_family_t, "AF_UNSPEC")
//
macdef AF_LOCAL = $extval (sa_family_t, "AF_LOCAL")
macdef AF_FILE = $extval (sa_family_t, "AF_FILE")
macdef AF_AX25 = $extval (sa_family_t, "AF_AX25")
macdef AF_IPX = $extval (sa_family_t, "AF_IPX")
macdef AF_APPLETALK = $extval (sa_family_t, "AF_APPLETALK")
macdef AF_NETROM = $extval (sa_family_t, "AF_NETROM")
macdef AF_BRIDGE = $extval (sa_family_t, "AF_BRIDGE")
macdef AF_ATMPVC = $extval (sa_family_t, "AF_ATMPVC")
macdef AF_X25 = $extval (sa_family_t, "AF_X25")
macdef AF_ROSE = $extval (sa_family_t, "AF_ROSE")
macdef AF_DECnet = $extval (sa_family_t, "AF_DECnet")
macdef AF_NETBEUI = $extval (sa_family_t, "AF_NETBEUI")
macdef AF_SECURITY = $extval (sa_family_t, "AF_SECURITY")
macdef AF_KEY = $extval (sa_family_t, "AF_KEY")
macdef AF_NETLINK = $extval (sa_family_t, "AF_NETLINK")
macdef AF_ROUTE = $extval (sa_family_t, "AF_ROUTE")
macdef AF_PACKET = $extval (sa_family_t, "AF_PACKET")
macdef AF_ASH = $extval (sa_family_t, "AF_ASH")
macdef AF_ECONET = $extval (sa_family_t, "AF_ECONET")
macdef AF_ATMSVC = $extval (sa_family_t, "AF_ATMSVC")
macdef AF_RDS = $extval (sa_family_t, "AF_RDS")
macdef AF_SNA = $extval (sa_family_t, "AF_SNA")
macdef AF_IRDA = $extval (sa_family_t, "AF_IRDA")
macdef AF_PPPOX = $extval (sa_family_t, "AF_PPPOX")
macdef AF_WANPIPE = $extval (sa_family_t, "AF_WANPIPE")
macdef AF_LLC = $extval (sa_family_t, "AF_LLC")
macdef AF_CAN = $extval (sa_family_t, "AF_CAN")
macdef AF_TIPC = $extval (sa_family_t, "AF_TIPC")
macdef AF_BLUETOOTH = $extval (sa_family_t, "AF_BLUETOOTH")
macdef AF_IUCV = $extval (sa_family_t, "AF_IUCV")
macdef AF_RXRPC = $extval (sa_family_t, "AF_RXRPC")
macdef AF_ISDN = $extval (sa_family_t, "AF_ISDN")
macdef AF_PHONET = $extval (sa_family_t, "AF_PHONET")
macdef AF_IEEE802154 = $extval (sa_family_t, "AF_IEEE802154")
macdef AF_MAX = $extval (sa_family_t, "AF_MAX")
//
(* ****** ****** *)
//
abst@ype
sp_family_t = $extype"sp_family_t"
//
macdef PF_UNIX = $extval (sp_family_t, "PF_UNIX")
macdef PF_INET = $extval (sp_family_t, "PF_INET")
macdef PF_INET6 = $extval (sp_family_t, "PF_INET6")
//
(* ****** ****** *)
//
abst@ype
socktype_t = int
//
macdef SOCK_RAW = $extval (socktype_t, "SOCK_RAW")
macdef SOCK_RDM = $extval (socktype_t, "SOCK_RDM")
macdef SOCK_DCCP = $extval (socktype_t, "SOCK_DCCP")
macdef SOCK_DGRAM = $extval (socktype_t, "SOCK_DGRAM")
macdef SOCK_PACKET = $extval (socktype_t, "SOCK_PACKET")
macdef SOCK_STREAM = $extval (socktype_t, "SOCK_STREAM")
macdef SOCK_SEQPACKET = $extval (socktype_t, "SOCK_SEQPACKET")
//
(* ****** ****** *)
//
abst@ype
socklen_t(n:int) = $extype"socklen_t"
//
castfn
int2socklen
  : {n:nat} (int n) -<> socklen_t(n)
castfn
size2socklen
  : {n:int} (size_t n) -<> socklen_t(n)
//
(* ****** ****** *)

stacst socklen_max : int // HX: sockaddr length

(* ****** ****** *)
//
abst@ype
sockaddr_struct(n:int) = $extype"sockaddr_struct"
stadef SA = sockaddr_struct
//
(* ****** ****** *)
//
// HX:
// client: init -> connect
// server:
// init -> bind -> listen -> accept
//
datasort
status =
| init | conn | bind | listen
//
absview socket_v (int, status)
//
(* ****** ****** *)
  
fun
socket_AF_type
(
  af: sa_family_t, st: socktype_t
) : [fd:int]
(
  option_v (socket_v (fd, init), fd >= 0) | int fd
) = "mac#%" // end-of-function
  
fun
socket_AF_type_exn
(
  af: sa_family_t, st: socktype_t
) : [fd:nat] (socket_v(fd, init) | int fd) = "ext#%"

(* ****** ****** *)  
//
dataview
bind_v
  (fd:int, int) = 
  | bind_v_succ (fd,  0) of socket_v (fd, bind)
  | bind_v_fail (fd, ~1) of socket_v (fd, init)
// end of [bind_v]
//
fun
bind_err
  {fd:int}{n:int}
(
  pf: socket_v (fd, init)
| fd: int fd, sockaddr: &SA(n), salen: socklen_t(n)
) : [i:int] (bind_v (fd, i) | int i) = "mac#%"
//
fun
bind_exn
  {fd:int}{n:int}
(
  pf: !socket_v(fd, init) >> socket_v(fd, bind)
| fd: int fd, sockaddr: &SA(n), salen: socklen_t(n)
) : void = "exn#%" // end of [bind_exn]
//
(* ****** ****** *)
//
dataview
listen_v
  (fd:int, int) = 
  | listen_v_succ (fd,  0) of socket_v (fd, listen)
  | listen_v_fail (fd, ~1(*err*)) of socket_v (fd, bind) 
// end of [listen_v]
//
fun
listen_err
  {fd:int}
(
  pf: socket_v(fd, bind)
| fd: int fd, backlog: intGt(0)
) : [i:int] (listen_v (fd, i) | int i) = "mac#%"
//
fun
listen_exn {fd:int}
(
  pf: !socket_v(fd, bind) >> socket_v(fd, listen)
| fd: int fd, backlog: intGt(0)
) : void = "ext#%" // end of [listen_exn]
//
(* ****** ****** *)
//
dataview
connect_v
(
  fd:int, int
) =
  | connect_v_succ (fd,  0) of socket_v (fd, conn)
  | connect_v_fail (fd, ~1(*err*)) of socket_v (fd, init)
// end of [connect_v]
//
fun
connect_err
  {fd:int}{n:int}
(
  pf: socket_v (fd, init)
| fd: int fd, sockaddr: &SA(n), salen: socklen_t(n)
) : [i:int] (connect_v (fd, i) | int i) = "mac#%"
//
fun
connect_exn
  {fd:int}{n:int}
(
  pf: !socket_v(fd, init) >> socket_v(fd, conn)
| fd: int fd, sockaddr: &SA(n), salen: socklen_t(n)
) : void = "exn#%" // end of [connect_exn]
//
(* ****** ****** *)
//
dataview
accept_v
  (fd1: int, int) =
  | {fd2:nat}
    accept_v_succ (fd1, fd2) of socket_v (fd2, conn)
  | accept_v_fail (fd1, ~1(*err*)) of () // failed attempt
// end of [accept_v]

fun
accept_err
  {fd1:int}{n:int}
(
  pf: !socket_v(fd1, listen)
| fd1: int fd1
, sa: &SA(n)? >> opt(SA(n), fd2 >= 0)
, salen: &socklen_t(n) >> socklen_t(n2)
) : #[fd2:int;n2:nat] (accept_v (fd1, fd2) | int fd2) = "mac#%"

fun
accept_null_err
  {fd1:int}
(
  pf: !socket_v(fd1, listen) | fd1: int fd1
) : [fd2:int]
(
  option_v (socket_v (fd2, conn), fd2 >= 0) | int fd2
) = "mac#%" // end-of-function

(* ****** ****** *)
//
fun
socket_close
  {fd:int}{s:status}
(
  pf: socket_v (fd, s) | fd: int fd
) : [i:int | i <= 0]
(
  option_v (socket_v (fd, s), i < 0) | int i
) = "mac#%" // end of [socket_close_err]
//
fun
socket_close_exn
  {fd:int}{s:status}
  (pf: socket_v (fd, s) | fd: int fd): void = "ext#%"
// end of [socket_close_exn]
//
(* ****** ****** *)

abst@ype
shutkind_t = int
macdef SHUT_RD = $extval(shutkind_t, "SHUT_RD")
macdef SHUT_WR = $extval(shutkind_t, "SHUT_WR")
macdef SHUT_RDWR = $extval(shutkind_t, "SHUT_RDWR")

(* ****** ****** *)
//
// HX: what error can occur?
//
fun
shutdown
  {fd:int} // 0/-1 : succ/fail // errno set
(
  pf: socket_v (fd, conn) | fd: int fd, how: shutkind_t
) : [i:int | i <= 0]
(
  option_v (socket_v (fd, conn), i < 0) | int i
) = "mac#%" // end of [shutdown]
//
fun
shutdown_exn
  {fd:int} // 0/-1 : succ/fail // errno set
(
  pf: socket_v (fd, conn) | fd: int fd, how: shutkind_t
) : void = "ext#%" // end of [shutdown_exn]
//
(* ****** ****** *)
//
// HX: it is just [read] in [unistd]
//
fun
socket_read
  {fd:int}
  {n,sz:int |
   0 <= n; n <= sz}
(
  pf: !socket_v(fd, conn) | fd: int fd, buf: &bytes(sz), ntot: size_t(n)
) : ssizeBtwe(~1, n) = "mac#%" // end of [socket_read]

(* ****** ****** *)
//
// HX: it is just [write] in [unistd]
//
fun
socket_write
  {fd:int}
  {n,sz:int |
   0 <= n; n <= sz}
(
  pf: !socket_v(fd, conn) | fd: int fd, buf: &bytes(sz), ntot: size_t(n)
) : ssizeBtwe(~1, n) = "mac#%" // end of [socket_write]
//
(* ****** ****** *)

(* end of [socket.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: August, 2013
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/time.cats"
%} // end of [%{#]

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libc"
#define
ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)
//
staload
TYPES = "libc/sys/SATS/types.sats"
typedef time_t = $TYPES.time_t
typedef suseconds_t = $TYPES.suseconds_t
//
(* ****** ****** *)
//
typedef
timeval_struct =
$extype_struct
"atslib_timeval_type" of
{ // = struct timeval
  tv_sec= time_t // seconds  
, tv_usec= suseconds_t // microseconds
} // end of [timeval_struct]
//
typedef timeval = timeval_struct
//
(* ****** ****** *)

(*
//
// HX: these macros seem only available in BSD
//
fun timerisset (tv: &timeval):<> bool = "mac#%"
fun timerclear (tv: &timeval >> _):<> bool = "mac#%"
*)

(* ****** ****** *)

typedef
timezone_struct =
$extype_struct"atslib_timezone_type" of
{ // = struct timezone
  tz_minuteswest= int // minutes west of GMT
, tz_dsttime= int // nonzero if DST is ever in effect
} // end of [timezone_struct]
typedef timezone = timezone_struct

(* ****** ****** *)
//
symintr gettimeofday
//
fun gettimeofday_tv
(
  tv: &timeval? >> opt (timeval, i==0)
) :<> #[i:int | i <= 0] int(i) = "mac#%"
overload gettimeofday with gettimeofday_tv
//
fun gettimeofday_tz
(
  tz: &timezone? >> opt (timezone, i==0)
) :<> #[i:int | i <= 0] int(i) = "mac#%"
overload gettimeofday with gettimeofday_tz
//
(* ****** ****** *)
//
symintr settimeofday
//
fun settimeofday_tv
  (tv: &timeval):<> [i:int | i <= 0] int(i) = "mac#%"
overload settimeofday with settimeofday_tv
//
fun settimeofday_tz
  (tz: &timezone):<> [i:int | i <= 0] int(i) = "mac#%"
overload settimeofday with settimeofday_tz
//
fun settimeofday_tvtz
  (tv: &timeval, tz: &timezone):<> [i:int | i <= 0] int(i) = "mac#%"
overload settimeofday with settimeofday_tvtz
//
(* ****** ****** *)

fun utimes
( // -1 on error // errno set
  path: string, buf: &(@[timeval][2])
) : int = "mac#%" // end of [utimes]

fun futimes {fd:nat}
( // -1 on error // errno set
  fd: int (fd), buf: &(@[timeval][2])
) : int = "mac#%" // end of [futimes]

fun futimesat
( // -1 on error // errno set
  dirfd: int, path: string, buf: &(@[timeval][2])
) : int = "mac#%" // end of [futimesat]

(* ****** ****** *)
//
abst@ype
itimerknd_t0ype = int
typedef itimerknd = itimerknd_t0ype
macdef ITIMER_REAL = $extval (itimerknd, "ITIMER_REAL")
macdef ITIMER_VIRTUAL = $extval (itimerknd, "ITIMER_VIRTUAL")
macdef ITIMER_PROF = $extval (itimerknd, "ITIMER_PROF")
//
(* ****** ****** *)
//
typedef
itimerval_struct =
$extype_struct"atslib_itimerval_type" of
{
  it_interval= timeval, it_value= timeval
} // end of [itimerval_struct] // end of [typedef]
//
typedef itimerval = itimerval_struct
//
(* ****** ****** *)
//
// HX: -1/0 : succ/fail // errno set
//
fun getitimer
(
  which: itimerknd
, itval: &itimerval? >> opt (itimerval, i==0)
) : #[i:int | i <= 0] int(i) = "mac#%" // endfun

fun setitimer
(
  which: itimerknd, itval: &itimerval
, itval_old: &itimerval? >> opt (itimerval, i==0)
) : #[i:int | i <= 0] int(i) = "mac#%" // endfun

fun setitimer_null
  (which: itimerknd, itval: &itimerval): int = "mac#%"
// end of [setitimer_null]

(* ****** ****** *)

(* end of [time.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: October, 2013
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/mman.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)
//
staload
FCNTL = "libc/SATS/fcntl.sats"
//
typedef mode_t = $FCNTL.mode_t
typedef fcntlflags = $FCNTL.fcntlflags
stadef fildes = $FCNTL.fildes
vtypedef Fildes = $FCNTL.Fildes
//
(* ****** ****** *)
//
abst@ype protflags = int
//
macdef PROT_NONE = $extval (protflags, "PROT_NONE")
macdef PROT_EXEC = $extval (protflags, "PROT_EXEC")
macdef PROT_READ = $extval (protflags, "PROT_READ")
macdef PROT_WRITE = $extval (protflags, "PROT_WRITE")
//                      
fun lor_protflags_protflags
  : (protflags, protflags) -<> protflags = "ext#atspre_lor_int_int"
overload lor with lor_protflags_protflags
//
(* ****** ****** *)
//
abst@ype mmapflags = int
//
macdef MAP_SHARED = $extval (mmapflags, "MAP_SHARED")
macdef MAP_PRIVATE = $extval (mmapflags, "MAP_PRIVATE")
//
macdef MAP_ANONYMOUS = $extval (mmapflags, "MAP_ANONYMOUS")
//
fun lor_mmapflags_mmapflags
  : (mmapflags, mmapflags) -<> mmapflags = "ext#atspre_lor_int_int"
overload lor with lor_mmapflags_mmapflags
//
(* ****** ****** *)

macdef MAP_FAILED = $extval (ptr, "MAP_FAILED") // = (void*)-1

(* ****** ****** *)

(*
/*
** Open shared memory segment
*/
extern
int shm_open
(
  __const char *__name, int __oflag, mode_t __mode
 ) ; // end of [shm_open]
*)
fun shm_open
(
  path: NSH(string), flags: fcntlflags, mode: mode_t
) : Fildes = "mac#%" // endfun

(* ****** ****** *)

(*
/*
** Remove shared memory segment
*/
extern int shm_unlink (__const char *__name);
*)
fun shm_unlink (path: NSH(string)):<!ref> intLte(0) = "mac#%"

(* ****** ****** *)

(* end of [mman.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: May, 2013
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/wait.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

staload
TYPES =
"libc/sys/SATS/types.sats"
typedef pid_t = $TYPES.pid_t

(* ****** ****** *)

absprop
WIFEXITED_p (s:int, b:bool)

fun WEXITSTATUS{s:int}
(
  pf: WIFEXITED_p (s, true) | status: int s
) : int = "mac#%" // end of [WEXITSTATUS]

fun WIFEXITED{s:int}
  (status: int s): [b:bool] (WIFEXITED_p (s, b) | bool b) = "mac#%"
// end of [WIFEXITED]

(* ****** ****** *)

absprop
WIFSIGNALED_p (s:int, b:bool)

fun WTERMSIG{s:int}
(
  pf: WIFSIGNALED_p (s, true) | status: int s
) : int = "mac#%" // end of [WTERMSIG]

fun WIFSIGNALED{s:int}
  (status: int s): [b:bool] (WIFSIGNALED_p (s, b) | bool b) = "mac#%"
// end of [WIFSIGNALED]

(* ****** ****** *)

absprop
WIFSTOPPED_p (s:int, b:bool)

fun WSTOPSIG{s:int}
(
  pf: WIFSTOPPED_p (s, true) | status: int s
) : int = "mac#%" // end of [WSTOPSIG]

fun WIFSTOPPED {s:int}
  (status: int s): [b:bool] (WIFSTOPPED_p (s, b) | bool b) = "mac#%"
// end of [WIFSTOPPED]

(* ****** ****** *)

absprop
WIFCONTINUED_p (s:int, b:bool)

fun WIFCONTINUED {s:int}
  (status: int s): [b:bool] (WIFCONTINUED_p (s, b) | bool b) = "mac#%"
// end of [WIFCONTINUED]

(* ****** ****** *)

absprop
WCOREDUMP_p (s:int, b:bool)

fun WCOREDUMP {s:int}
  (status: int s): [b:bool] (WCOREDUMP_p (s, b) | bool b) = "mac#%"
// end of [WCOREDUMP]

(* ****** ****** *)
//
symintr wait
fun wait_void (): pid_t = "mac#%"
fun wait_status (status: &int? >> int): pid_t = "mac#%"
overload wait with wait_void
overload wait with wait_status
//
(* ****** ****** *)

abst@ype
waitopt_t0ype = $extype"ats_int_type"
typedef waitopt = waitopt_t0ype
macdef WNONE = $extval (waitopt, "0")
macdef WNOHANG = $extval (waitopt, "WNOHANG")
macdef WUNTRACED = $extval (waitopt, "WUNTRACED")
macdef WCONTINUED = $extval (waitopt, "WCONTINUED")

fun lor_waitopt_waitopt
  (opt1: waitopt, opt2: waitopt): waitopt
overload lor with lor_waitopt_waitopt

(* ****** ****** *)

fun waitpid
(
  chldpid: pid_t, status: &int? >> int, opt: waitopt
) : pid_t = "mac#%" // end of [waitpid]

(* ****** ****** *)

(* end of [wait.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/socket_in.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/sys/SATS/socket.sats"

(* ****** ****** *)

staload IN = "libc/netinet/SATS/in.sats"

(* ****** ****** *)
//
typedef
in_port_t = $IN.in_port_t
typedef
in_port_nbo_t = $IN.in_port_nbo_t
//
(* ****** ****** *)
//
typedef
in_addr_hbo_t = $IN.in_addr_hbo_t
typedef
in_addr_nbo_t = $IN.in_addr_nbo_t
//
(* ****** ****** *)
//
typedef
in_addr_struct = $IN.in_addr_struct
//  
(* ****** ****** *)
//
typedef
sockaddr_in_struct =
$extype_struct
"sockaddr_in_struct" of
{
  sin_family = sa_family_t
, sin_port(**) = in_port_nbo_t // uint16
, sin_addr(**) = in_addr_struct
} // end of [sockaddr_in_struct]
//
typedef SA_in = sockaddr_in_struct
typedef sockaddr_in = sockaddr_in_struct
//
stacst socklen_in : int // HX: length of [sockaddr_in]
(*
stadef socklen_in = sizeof (sockaddr_in_struct)
*)
macdef socklen_in =
  $extval (socklen_t(socklen_in), "atslib_socklen_in")
//
praxi socklen_lte_in (): [socklen_in <= socklen_max] void
praxi sockaddr_in_trans {l:addr}
  (pf: !sockaddr_in_struct @ l >> sockaddr_struct(socklen_in) @ l): void
praxi sockaddr_trans_in {l:addr}
  (pf: !sockaddr_struct(socklen_in) @ l >> sockaddr_in_struct @ l): void
//
(* ****** ****** *)
//
fun
sockaddr_in_init
(
  sa: &SA_in? >> SA_in
, af: sa_family_t, inp: in_addr_nbo_t, port: in_port_nbo_t
) :<> void = "mac#%" // end of [sockaddr_in_init]

(* ****** ****** *)

fun
bind_in_exn
  {fd:int}
(
  pf: !socket_v(fd, init) >> socket_v(fd, bind) | fd: int fd, sa: &SA_in
) :<!exnref> void = "ext#%" // end of [bind_in_exn]

(* ****** ****** *)

fun
connect_in_exn
  {fd:int}
(
  pf: !socket_v(fd, init) >> socket_v(fd, conn) | fd: int fd, sa: &SA_in
) :<!exnref> void = "ext#%" // end of [connect_in_exn]

(* ****** ****** *)

(* end of [socket_in.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/types.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

abst@ype
time_t0ype = $extype"atslib_time_type"
typedef time_t = time_t0ype // = its C-counterpart

(* ****** ****** *)

fun time2lint (t: time_t):<> lint = "mac#%"
fun time2double (t: time_t):<> double = "mac#%"

(* ****** ****** *)
//
fun lt_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
fun lte_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
overload < with lt_time_time
overload <= with lte_time_time
//
fun gt_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
fun gte_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
overload > with gt_time_time
overload >= with gte_time_time
//
fun eq_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
fun neq_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
overload = with eq_time_time
overload <> with neq_time_time
overload != with neq_time_time
//
(* ****** ****** *)

abst@ype
clock_t0ype = $extype"atslib_clock_type"
typedef clock_t = clock_t0ype // = its C-counterpart

(* ****** ****** *)

fun clock2lint (t: clock_t):<> lint = "mac#%"
fun clock2double (t: clock_t):<> double = "mac#%"

(* ****** ****** *)

abst@ype
clockid_t0ype = $extype"atslib_clockid_type"
typedef clockid_t = clockid_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
mode_t0ype = $extype"atslib_mode_type"
typedef mode_t = mode_t0ype // = its C-counterpart

(* ****** ****** *)

fun mode2int (m: mode_t):<> int = "mac#%"
fun mode2uint (m: mode_t):<> uint = "mac#%"

fun eq_mode_mode (m1: mode_t, m2: mode_t):<> bool
fun neq_mode_mode (m1: mode_t, m2: mode_t):<> bool
overload = with eq_mode_mode
overload != with neq_mode_mode
overload <> with neq_mode_mode

(* ****** ****** *)

fun lor_mode_mode
  (m1: mode_t, m2: mode_t):<> mode_t = "mac#%"
overload lor with lor_mode_mode

fun land_mode_mode
  (m1: mode_t, m2: mode_t):<> mode_t = "mac#%"
overload land with land_mode_mode

(* ****** ****** *)

abst@ype
dev_t0ype = $extype"atslib_dev_type"
typedef dev_t = dev_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
ino_t0ype = $extype"atslib_ino_type"
typedef ino_t = ino_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
nlink_t0ype = $extype"atslib_nlink_type"
typedef nlink_t = nlink_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
pid_t0ype = $extype"atslib_pid_type"
typedef pid_t = pid_t0ype // = its C-counterpart
castfn pid2int (x: pid_t):<> int
castfn pid2lint (x: pid_t):<> lint

(* ****** ****** *)

abst@ype
uid_t0ype = $extype"atslib_uid_type"
typedef uid_t = uid_t0ype // = its C-counterpart
abst@ype
gid_t0ype = $extype"atslib_gid_type"
typedef gid_t = gid_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
off_t0ype = $extype"atslib_off_type"
typedef off_t = off_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
blkcnt_t0ype = $extype"atslib_blkcnt_type"
typedef blkcnt_t = blkcnt_t0ype // = its C-counterpart
abst@ype
blkcnt_t0ype = $extype"atslib_blkcnt_type"
typedef blkcnt_t = blkcnt_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
blksize_t0ype = $extype"atslib_blksize_type"
typedef blksize_t = blksize_t0ype // = its C-counterpart
abst@ype
blksize_t0ype = $extype"atslib_blksize_type"
typedef blksize_t = blksize_t0ype // = its C-counterpart

(* ****** ****** *)

fun lint2off (x: lint):<> off_t = "mac#%"
fun off2lint (x: off_t):<> lint = "mac#%"
fun size2off (x: size_t):<> off_t = "mac#%"
fun off2size (x: off_t):<> size_t = "mac#%"

(* ****** ****** *)
//
absview fildes_view (fd: int)
viewdef fildes_v (i:int) = fildes_view (i)
//
absvt@ype
fildes_vtype (fd: int) = int
//
vtypedef
fildes (fd: int) = fildes_vtype (fd)
//
vtypedef Fildes = [fd:int] fildes (fd)
vtypedef Fildes0 = [fd:int | fd >= 0] fildes (fd)
//
(* ****** ****** *)

castfn
fildes_decode
  {fd:nat} (fd: fildes (fd)):<> (fildes_v (fd) | int fd)
// end of [fildes_decode]

castfn fildes_encode
  {fd:nat} (pf: fildes_v (fd) | fd: int fd):<> fildes (fd)
// end of [fildes_encode]

(* ****** ****** *)

abst@ype
useconds_t = // microseconds
$extype"atslib_useconds_type"
castfn usec2lint (x: useconds_t):<> lint

abst@ype
suseconds_t = // microseconds
$extype"atslib_suseconds_type"
castfn susec2lint (x: suseconds_t):<> lint

(* ****** ****** *)

abst@ype
pthread_t =
$extype"atslib_pthread_type"
castfn pthread2lint (x: pthread_t):<> lint

(* ****** ****** *)

(* end of [types.sats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/socket.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: November, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_SOCKET
#define ATSLIB_LIBC_SYS_CATS_SOCKET

/* ****** ****** */
//
#include <unistd.h>
#include <sys/socket.h>
//
/* ****** ****** */

#include "share/H/pats_atslib.h"

/* ****** ****** */

/*
typedef
unsigned short int sa_family_t; // socket address family
*/
typedef
unsigned short int sp_family_t; // socket protocol family

/* ****** ****** */

#define atslib_socket_AF_type socket_AF_type
#define atslib_socket_PF_type socket_PF_type

/* ****** ****** */
//
#define \
atslib_bind_err(fd, sa, len) \
  bind(fd, (const struct sockaddr*)sa, len)
//
extern
void
atslib_bind_exn
(
  int sockfd, atstype_ptr sa, socklen_t salen
); // end of [atslib_bind_exn]
//
/* ****** ****** */
//
#define \
atslib_listen_err(fd, qsz) listen(fd, qsz)
//
extern
void
atslib_listen_exn (int sockfd, int listenqsz);
//
/* ****** ****** */
//
#define \
atslib_connect_err(fd, sa, len) \
  connect(fd, (const struct sockaddr*)sa, len)
//
extern
void
atslib_connect_exn
(
  int sockfd, atstype_ptr sa, socklen_t salen
); // end of [atslib_connect_exn]
//
/* ****** ****** */
//
#define \
atslib_accept_err(fd, sa, len) \
  accept(fd, (struct sockaddr*)sa, (socklen_t*)len)
//
#define \
atslib_accept_null_err(fd) atslib_accept_err(fd, 0, 0)
//
/* ****** ****** */

#define atslib_socket_close(fd) close(fd)

/* ****** ****** */

#define atslib_shutdown(fd, how) shutdown(fd, how)

/* ****** ****** */

#define \
atslib_socket_read(fd, bufp, bsz) read(fd, (char*)bufp, bsz)
#define \
atslib_socket_write(fd, bufp, bsz) write(fd, (const char*)bufp, bsz)

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_SOCKET

/* ****** ****** */

/* end of [socket.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/stat.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_STAT
#define ATSLIB_LIBC_SYS_CATS_STAT

/* ****** ****** */

#include <sys/stat.h>

/* ****** ****** */

typedef
struct stat
atslib_stat_struct ;

/* ****** ****** */

#define atslib_umask umask

/* ****** ****** */

#define atslib_chmod chmod

/* ****** ****** */

#define atslib_mkdir mkdir
#define atslib_mkdirat mkdirat

/* ****** ****** */

#define atslib_mkfifo mkfifo

/* ****** ****** */

#define atslib_stat stat
#define atslib_fstat fstat
#define atslib_lstat lstat

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_STAT

/* ****** ****** */

/* end of [stat.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/time.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_TIME
#define ATSLIB_LIBC_SYS_CATS_TIME

/* ****** ****** */

#include <sys/time.h>

/* ****** ****** */

typedef struct timeval atslib_timeval_type ;
typedef struct timezone atslib_timezone_type ;

/* ****** ****** */

#define atslib_gettimeofday_tv(tv) gettimeofday(tv, NULL)
#define atslib_gettimeofday_tz(tz) gettimeofday(NULL, tz)

#define atslib_settimeofday_tv(tv) settimeofday(tv, NULL)
#define atslib_settimeofday_tz(tz) settimeofday(NULL, tz)
#define atslib_settimeofday_tvtz(tv, tz) settimeofday(tv, tz)

/* ****** ****** */

#define atslib_utimes utimes
#define atslib_futimes futimes
#define atslib_futimesat futimesat

/* ****** ****** */

typedef struct itimerval ats_itimerval_type ;

#define atslib_getitimer getitimer
#define atslib_setitimer setitimer
#define atslib_setitimer_null(which, itval) setitimer(which, itval, NULL)

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_TIME

/* ****** ****** */

/* end of [time.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/mman.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: October, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_MMAN
#define ATSLIB_LIBC_SYS_CATS_MMAN

/* ****** ****** */
//
#include <fcntl.h>
#include <sys/types.h>
//
#include <sys/mman.h>
//
/* ****** ****** */

#define atslib_shm_open shm_open
#define atslib_shm_unlink shm_unlink

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_MMAN

/* ****** ****** */

/* end of [mman.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/wait.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: October, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_WAIT
#define ATSLIB_LIBC_SYS_CATS_WAIT

/* ****** ****** */
//
#include <sys/wait.h>
//
/* ****** ****** */
//
// HX: it is yet empty
//
/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_WAIT

/* ****** ****** */

/* end of [wait.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/types.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_TYPES
#define ATSLIB_LIBC_SYS_CATS_TYPES

/* ****** ****** */

#include <sys/types.h>

/* ****** ****** */

typedef mode_t atslib_mode_type ;

/* ****** ****** */
//
// HX-2013-8:
// [atslib_time_type] is already
// defined in [libc/CATS/time.cats]
//
typedef time_t atslib_types_time_type ;
//
/* ****** ****** */

#if(0)
//
// HX-2013-05: where are they?
// HX-2013-06: they are declared in [time.h]
//
typedef clock_t atslib_clock_type ;
typedef clockid_t atslib_clockid_type ;
#endif

/* ****** ****** */

typedef ino_t atslib_ino_type ;
typedef off_t atslib_off_type ;

/* ****** ****** */

typedef pid_t atslib_pid_type ;
typedef uid_t atslib_uid_type ;
typedef gid_t atslib_gid_type ;

/* ****** ****** */

ATSinline()
atslib_mode_type
atslib_lor_mode_mode
(
  atslib_mode_type m1
, atslib_mode_type m2
) {
  return (m1 | m2) ;
} // end of [atslib_lor_mode_mode]

ATSinline()
atslib_mode_type
atslib_land_mode_mode
(
  atslib_mode_type m1
, atslib_mode_type m2
) {
  return (m1 & m2) ;
} // end of [atslib_land_mode_mode]

/* ****** ****** */

ATSinline()
atstype_bool
atslib_lt_time_time
(
  atslib_types_time_type t1
, atslib_types_time_type t2
)
{
  return (t1 < t2 ? atsbool_true : atsbool_false) ;
} // end of [atslib_lt_time_time]
ATSinline()
atstype_bool
atslib_lte_time_time
(
  atslib_types_time_type t1
, atslib_types_time_type t2
)
{
  return (t1 <= t2 ? atsbool_true : atsbool_false) ;
} // end of [atslib_lte_time_time]

#define atslib_gt_time_time(t1, t2) atslib_lt_time_time(t2, t1)
#define atslib_gte_time_time(t1, t2) atslib_lte_time_time(t2, t1)

ATSinline()
atstype_bool
atslib_eq_time_time
(
  atslib_types_time_type t1
, atslib_types_time_type t2
)
{
  return (t1 == t2 ? atsbool_true : atsbool_false) ;
} // end of [atslib_eq_time_time]
ATSinline()
atstype_bool
atslib_neq_time_time
(
  atslib_types_time_type t1
, atslib_types_time_type t2
)
{
  return (t1 != t2 ? atsbool_true : atsbool_false) ;
} // end of [atslib_neq_time_time]

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_TYPES

/* ****** ****** */

/* end of [types.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/socket_in.atxt
** Time of generation: Tue Sep  1 22:06:06 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: November, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_SOCKET_IN
#define ATSLIB_LIBC_SYS_CATS_SOCKET_IN

/* ****** ****** */
//
#include <sys/socket.h>
#include <netinet/in.h>
//
/* ****** ****** */

#ifndef memset
extern void *memset (void *p, int c, size_t n) ;
#endif // ifndef(memset)

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atslib_sockaddr_in_init
(
  atstype_ptr sa
, sa_family_t af, in_addr_t inp, in_port_t port
) {
  struct sockaddr_in *sa2 = sa ;
  (void)memset(sa2, 0, sizeof(struct sockaddr_in)) ;
  sa2->sin_family = af ;
  sa2->sin_addr.s_addr = inp ;
  sa2->sin_port = port ;
} // end of [sockaddr_in_init]

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_SOCKET_IN

/* ****** ****** */

/* end of [socket_in.cats] */
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: December, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/dlfcn.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)
//
macdef RTLD_NOW = $extval (uint, "RTLD_NOW")
macdef RTLD_LAZY = $extval (uint, "RTLD_LAZY")
//
(* ****** ****** *)
//
macdef RTLD_LOCAL = $extval (uint, "RTLD_LOCAL")
macdef RTLD_GLOBAL = $extval (uint, "RTLD_GLOBAL")
macdef RTLD_NOLOAD = $extval (uint, "RTLD_NOLOAD") // glibc-2.2
macdef RTLD_NODELETE = $extval (uint, "RTLD_NODELETE") // glibc-2.2
macdef RTLD_DEEPBIND = $extval (uint, "RTLD_DEEPBIND") // glibc-2.3.4
//
(* ****** ****** *)

absview dlopen_v (l:addr)

(* ****** ****** *)

fun dlopen (
  filename: NSH(stropt), flag: uint
) : [l:addr] (option_v (dlopen_v(l), l > null) | ptr l) = "mac#%"

(* ****** ****** *)

fun dlclose{l:agz}
  (pf: dlopen_v (l) | p: ptr (l)): [i:int | i >= 0] int(i) = "mac#%"
// end of [dlclose]

(* ****** ****** *)
//
praxi
dlopen_v_elim_null{l:addr | l <= null} (pf: dlopen_v (l)): void
//
(* ****** ****** *)

fun dlerror ((*void*)): vStrptr0 = "mac#%"

(* ****** ****** *)
//
fun dlsym{l:agz}
  (pf: !dlopen_v l | handle: ptr l, sym: NSH(string)): Ptr0 = "mac#%"
//
(* ****** ****** *)

(* end of [dlfcn.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: June, 2012
//
(* ****** ****** *)

%{#
#include "libc/CATS/stdlib.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

staload
STDDEF = "libc/SATS/stddef.sats"
typedef wchar_t = $STDDEF.wchar_t

(* ****** ****** *)

macdef EXIT_FAILURE = $extval (int, "EXIT_FAILURE")
macdef EXIT_SUCCESS = $extval (int, "EXIT_SUCCESS")

(* ****** ****** *)

abst@ype div_t = $extype"div_t"
abst@ype ldiv_t = $extype"ldiv_t"
abst@ype lldiv_t = $extype"lldiv_t"

(* ****** ****** *)
/*
void _Exit(int);
*/
fun _Exit (int): void = "mac#%"

/*
int atexit(void (*)(void));
*/
fun atexit
  (f: ((*void*)) -> void): int(*err*) = "mac#%"
// end of [atexit]

(* ****** ****** *)

/*
void abort(void);
*/
fun abort ((*void*)): void = "mac#%"

(* ****** ****** *)

/*
int abs (int)
*/
fun abs (int):<> int = "mac#%"
/*
long int labs(long int j);
*/
fun labs (lint):<> lint = "mac#%"
/*
long long int llabs(long long int j);
*/
fun llabs (lint):<> llint = "mac#%"

(* ****** ****** *)

/*
div_t div(int, int);
*/
fun div (int, int):<> div_t
/*
ldiv_t ldiv(long, long);
*/
fun ldiv (lint, lint):<> ldiv_t
/*
lldiv_t lldiv(long long, long long);                              
*/
fun lldiv (llint, llint):<> lldiv_t

(* ****** ****** *)

/*
long a64l(const char *);
*/
fun a64l (x: NSH(string)):<> lint = "mac#%"

/*
char *l64a(long value); // not defined for a negative value
*/
fun l64a
  {i:nat} (
  x: lint i
) :<!refwrt> [l:agz] vttakeout0 (strptr l) = "mac#%"
// end of [l64a]

(* ****** ****** *)

/*
int atoi(const char *);
*/
fun atoi (x: NSH(string)):<> int = "mac#%"

/*
long atol(const char *);
*/
fun atol (x: NSH(string)):<> lint = "mac#%"

/*
long long atoll(const char *);
*/
fun atoll (x: NSH(string)):<> llint = "mac#%"
                                          
/*
double atof(const char *);
*/
fun atof (x: NSH(string)):<> double = "mac#%"

(* ****** ****** *)

/*
long int strtol(const char *nptr, char **endptr, int base);
*/
symintr strtol
fun strtol0
  (nptr: string, base: intBtwe (2, 36)):<!wrt> lint = "mac#%"
overload strtol with strtol0
fun strtol1
  (nptr: string, endptr: &ptr? >> _, base: intBtwe (2, 36)):<!wrt> lint = "mac#%"
overload strtol with strtol1
fun strtol_unsafe
  (nptr: string, endptr: ptr, base: int):<!wrt> lint = "mac#%"
// end of [strtol_unsafe]
/*
long long int strtoll(const char *nptr, char **endptr, int base);
*/
symintr strtoll
fun strtoll0
  (nptr: string, base: intBtwe (2, 36)):<!wrt> llint
overload strtoll with strtoll0
fun strtoll1
  (nptr: string, endptr: &ptr? >> _, base: intBtwe (2, 36)):<!wrt> llint
overload strtoll with strtoll1
fun strtoll_unsafe
  (nptr: string, endptr: ptr, base: int):<!wrt> llint
// end of [strtoll_unsafe]

(* ****** ****** *)

/*
unsigned long strtoul(const char *nptr, char **endptr, int base);
*/
symintr strtoul
fun strtoul0
  (nptr: string, base: intBtwe (2, 36)):<!wrt> ulint
overload strtoul with strtoul0
fun strtoul1
  (nptr: string, endptr: &ptr? >> _, base: intBtwe (2, 36)):<!wrt> ulint
overload strtoul with strtoul1
fun strtoul_unsafe
  (nptr: string, endptr: ptr, base: int):<!wrt> ulint
// end of [strtoul_unsafe]
/*
unsigned long long strtoull(const char *nptr, char **endptr, int base);
*/
symintr strtoull
fun strtoull0
  (nptr: string, base: intBtwe (2, 36)):<!wrt> ullint
overload strtoull with strtoull0
fun strtoull1
  (nptr: string, endptr: &ptr? >> _, base: intBtwe (2, 36)):<!wrt> ullint
overload strtoull with strtoull1
fun strtoull_unsafe
  (nptr: string, endptr: ptr, base: int):<!wrt> ullint
// end of [strtoull_unsafe]

(* ****** ****** *)

/*
float strtof(const char *nptr, char **endptr);
*/
symintr strtof
fun strtof0 (nptr: string):<!wrt> float = "mac#%"
overload strtof with strtof0
fun strtof1
  (nptr: string, endptr: &ptr? >> _):<!wrt> float = "mac#%"
overload strtof with strtof1
fun strtof_unsafe
  (nptr: string, endptr: ptr):<!wrt> float = "mac#%"
// end of [strtof_unsafe]
/*
double strtod(const char *nptr, char **endptr);
*/
symintr strtod
fun strtod0 (nptr: string):<!wrt> double = "mac#%"
overload strtod with strtod0
fun strtod1
  (nptr: string, endptr: &ptr? >> _):<!wrt> double = "mac#%"
overload strtod with strtod1
fun strtod_unsafe
  (nptr: string, endptr: ptr):<!wrt> double = "mac#%"
// end of [strtod_unsafe]
/*
long double strtold(const char *nptr, char **endptr);
*/
symintr strtold
fun strtold0 (nptr: string):<!wrt> ldouble = "mac#%"
overload strtold with strtold0
fun strtold1
  (nptr: string, endptr: &ptr? >> _):<!wrt> ldouble = "mac#%"
overload strtold with strtold1
fun strtold_unsafe
  (nptr: string, endptr: ptr):<!wrt> ldouble = "mac#%"
// end of [strtold_unsafe]

(* ****** ****** *)

(*
//
// HX: these env-functions may not be reentrant!
//
*)

(* ****** ****** *)

/*
char *getenv(char *);
*/
fun getenv
(
  name: NSH(string)
) :<!ref> [l:addr] vttakeout0 (strptr l) = "mac#%"

fun{} getenv_gc (name: NSH(string)):<!refwrt> Strptr0

(* ****** ****** *)

/*
int putenv(char *);
*/
//
// HX: [nameval] is shared!
//
fun putenv
  (nameval: SHR(string)):<!refwrt> int = "mac#%"
// end of [putenv]

(* ****** ****** *)

/*
int setenv
(
  const char *name, const char *value, int overwrite
) ;
*/
fun setenv
(
  name: NSH(string), value: NSH(string), overwrite: int
) :<!refwrt> int = "mac#%"

/*
int unsetenv(const char *name);
*/
fun unsetenv
  (name: NSH(string)):<!refwrt> int = "mac#%"
// end of [unsetenv]

(* ****** ****** *)

/*
int clearenv(void);
*/
fun clearenv ((*void*)):<!refwrt> int = "mac#%"

(* ****** ****** *)
//
// HX:
// these funs seem to have become obsolete
//
fun rand ((*void*)):<!refwrt> int = "mac#%"
fun srand (seed: uint):<!refwrt> void = "mac#%"

fun rand_r (seed: &uint >> _):<> int = "mac#%"

(* ****** ****** *)
/*
long int random(void);
*/
fun random((*void*)):<!refwrt> lint = "mac#%"

/*
void srandom(unsigned int seed);
*/
fun srandom(seed: uint):<!refwrt> void = "mac#%"

/*
char
*initstate
(
  unsigned int seed, char *state, size_t n
) ;
*/
fun initstate_unsafe
(
  seed: uint, state: cPtr1 (char), n: sizeGte(8)
) : cPtr0 (char) = "mac#%"
// end of [initstate_unsafe]

/*
char *setstate(char *state);
*/
fun setstate_unsafe
  (state: cPtr1 (char)):<!ref> cPtr0 (char) = "mac#%"
// end of [setstate_unsafe]

(* ****** ****** *)
/*
double drand48(void); // obsolete
*/
fun drand48 ((*void*)):<!ref> double = "mac#%"
     
/*
double erand48(unsigned short xsubi[3]); // obsolete
*/
fun erand48
  (xsubi: &(@[usint][3])):<!ref> double = "mac#%"
// end of [erand48]

/*
long int lrand48(void); // obsolete
*/
fun lrand48 ((*void*)):<!ref> lint = "mac#%"
/*
long int nrand48(unsigned short xsubi[3]); // obsolete
*/
fun nrand48
  (xsubi: &(@[usint][3])):<!ref> lint = "mac#%"
// end of [nrand48]

/*
long int mrand48(void); // obsolete
*/
fun mrand48 ((*void*)):<!ref> lint = "mac#%"

/*
long int jrand48(unsigned short xsubi[3]); // obsolete
*/
fun jrand48
  (xsubi: &(@[usint][3])):<!ref> lint = "mac#%"
// end of [jrand48]

/*
void srand48(long int seedval); // obsolete
*/
fun srand48 (seedval: lint):<!ref> void = "mac#%"

/*
unsigned short *seed48(unsigned short seed16v[3]); // obsolete
*/
// HX: returning pointer to some internal buffer
fun seed48 (seed16v: &(@[usint][3])): Ptr1 = "mac#%"

/*
void lcong48(unsigned short param[7]); // obsolete
*/
fun lcong48 (param: &(@[usint][7])):<!ref> void = "mac#%"

(* ****** ****** *)
/*
void
*bsearch
(
  const void *key
, const void *base
, size_t nmemb, size_t size
, int (*compar)(const void *, const void *)
) ; // end of [bsearch]
*/
fun bsearch
  {a:vt0p}{n:int}
(
  key: &RD(a)
, arr: &RD(@[INV(a)][n])
, asz: size_t (n), tsz: sizeof_t (a)
, cmp: cmpref (a)
) :<> Ptr0 = "mac#%" // end of [bsearch]

(* ****** ****** *)
/*
void qsort
(
  void *base, size_t nmemb, size_t size
, int(*compar)(const void *, const void *)
) ; // end of [qsort]
*/
fun qsort
  {a:vt0p}{n:int}
(
  A: &(@[INV(a)][n]), asz: size_t (n), tsz: sizeof_t (a), cmp: cmpref (a)
) :<!wrt> void = "mac#%" // end of [qsort]

(* ****** ****** *)
/*
int mblen(const char *s, size_t n);
*/
fun mblen_unsafe
  (s: cPtr0 (char), n: size_t):<!refwrt> int = "mac#%"
// end of [mblen_unsafe]

/*
int wctomb(char *s, wchar_t wc);
*/
fun wctomb_unsafe
  (s: cPtr0 (char), wc: wchar_t):<!refwrt> int = "mac#%"
// end of [wctomb_unsafe]

/*
size_t wcstombs
(
  char *dest, const wchar_t *src, size_t n
) ;
*/
fun wcstombs_unsafe
(
  dest: cPtr0 (char), src: cPtr1 (wchar_t), n: size_t
) :<!refwrt> ssize_t = "mac#%" // endfun

(* ****** ****** *)
/*
void setkey(const char *key);
*/
fun setkey_unsafe (key: cPtr1 (char)):<!ref> void = "mac#%"

(* ****** ****** *)
/*
int mkstemp(char *template);
*/
fun mkstemp {n:int | n >= 6}
  (template: !strnptr (n)): int = "mac#%"
// end of [mkstemp] // endfun

/*
int mkostemp (char *template, int flags);
*/
fun mkostemp {n:int | n >= 6}
  (template: !strnptr (n), flags: int): int = "mac#%"
// end of [mkostemp] // endfun

(* ****** ****** *)
/*
int grantpt(int fd);
*/
fun grantpt (fd: int): int = "mac#%"

(* ****** ****** *)

dataview
malloc_libc_v (addr, int) =
  | {l:agz}{n:int}
    malloc_libc_v_succ (l, n) of (b0ytes (n) @ l, mfree_libc_v (l))
  | {n:int} malloc_libc_v_fail (null, n)
// end of [malloc_libc_v]

(* ****** ****** *)

fun
malloc_libc
  {n:int}
(
  bsz: size_t n
) :<!wrt>
[
  l:addr
] (
  malloc_libc_v (l, n) | ptr l
) = "mac#%" // end of [malloc]

fun
malloc_libc_exn
  {n:int}
(
  bsz: size_t n
) :<!wrt>
[
  l:addr | l > null
] (
  b0ytes(n) @ l, mfree_libc_v l | ptr l
) = "mac#%" // end of [malloc_exn]

fun mfree_libc
  {l:addr}{n:int}
(
  b0ytes(n) @ l, mfree_libc_v l | ptr l
) :<!wrt> void = "mac#%" // endfun

(* ****** ****** *)

/*
int system(const char *command);
*/
fun system (command: NSH(string)): int = "mac#%"

(* ****** ****** *)

(* end of [stdlib.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: February, 2014
//
(* ****** ****** *)

%{#
#include "libc/CATS/alloca.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

fun alloca
  {dummy:addr}{n:int}
(
  pf: void@dummy | n: size_t (n)
) : [l:addr]
(
  bytes(n) @ l, bytes(n) @ l -> void@dummy | ptr(l)
) = "mac#%" // end of [alloca]

(* ****** ****** *)

(*
fun{
a:vt0p
} ptr_alloca
  {dummy:addr} (
  pf: void@dummy | (*void*)
) : [l:addr] (a? @ l, a? @ l -> void@dummy | ptr(l))
*)
fun
ptr_alloca_tsz
  {a:vt0p}{dummy:addr}
  (pf: void@dummy | tsz: sizeof_t(a))
: [l:addr] (a? @ l, a? @ l -> void@dummy | ptr(l)) = "mac#%"

(* ****** ****** *)

(*
fun{
a:vt0p
} array_ptr_alloca
  {dummy:addr}{n:int}
(
  pf: void@dummy | asz: size_t(n)
) : [l:addr] (array(a?,n)@l, array(a?,n)@l -> void@dummy | ptr(l))
*)
fun
array_ptr_alloca_tsz
  {a:vt0p}{dummy:addr}{n:int}
(
  pf: void@dummy | asz: size_t(n), tsz: sizeof_t(a)
) : [l:addr] (array(a?,n)@l, array(a?,n)@l -> void@dummy | ptr(l)) = "mac#%"

(* ****** ****** *)

(* end of [alloca.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/string.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

fun strcmp (x1: string, x2: string):<> int = "mac#%"
fun strncmp (x1: string, x2: string, n: size_t):<> int = "mac#%"

(* ****** ****** *)

fun strcoll (x1: string, x2: string):<> int = "mac#%"

(* ****** ****** *)

fun strspn (x1: string, x2: string):<> size_t = "mac#%"
fun strcspn (x1: string, x2: string):<> size_t = "mac#%"

(* ****** ****** *)
//
fun strlen
  {n:int} (x: string n):<> size_t (n) = "mac#%"
fun strnlen {m,n:int}
  (x: string n, max: size_t m):<> size_t (min(m,n)) = "mac#%"
//
(* ****** ****** *)

fun strcat
  {l:addr}{m:int}{n1,n2:int | n1+n2 < m}
(
  !strbuf_v (l, m, n1) >> strbuf_v (l, m, n1+n2) | ptr (l), string (n2)
) :<!wrt> ptr (l) = "mac#%" // end of [strcat]

fun strcat_unsafe
  {l:addr} (x1: ptr (l), x2: string):<!wrt> ptr (l) = "mac#%"
fun strncat_unsafe
  {l:addr} (x1: ptr (l), x2: string, n: size_t):<!wrt> ptr (l) = "mac#%"

(* ****** ****** *)

fun strcpy
  {l:addr}{m:int}{n:int | n < m}
(
  !b0ytes(m) @ l >> strbuf_v (l, m, n) | ptr (l), string (n)
) :<!wrt> ptr (l) = "mac#%" // endfun

fun strcpy_unsafe
  {l:addr} (dst: ptr (l), src: string):<!wrt> ptr (l) = "mac#%"
fun strncpy_unsafe
  {l:addr} (dst: ptr (l), src: string, n: size_t):<!wrt> ptr (l) = "mac#%"

(* ****** ****** *)

absview strdup_view (l:addr)
viewdef strdup_v (l:addr) = strdup_view (l)

fun strdup
(
  str: string
) :<!wrt> [l:addr] (strdup_v (l) | strptr (l)) = "mac#%"
fun strndup
(
  str: string
) :<!wrt> [l:addr] (strdup_v (l) | strptr (l)) = "mac#%"

fun strdup_free
  {l:addr} (pf: strdup_v (l) | x: strptr l):<!wrt> void = "mac#%"
// end of [strdup_free]

(* ****** ****** *)
//
// HX-2013-03:
// strdupa-functions are gcc-functions;
// they use alloca for memory allocation
//
absview strdupa_view (l:addr)
viewdef strdupa_v (l:addr) = strdupa_view (l)

fun strdupa
(
  str: string
) :<!wrt> [l:addr] (strdupa_v (l) | strptr (l)) = "mac#%"
fun strndupa
(
  str: string
) :<!wrt> [l:addr] (strdupa_v (l) | strptr (l)) = "mac#%"

fun strdupa_free
  {l:addr} (pf: strdupa_v (l) | x: strptr l):<!wrt> void = "mac#%"
// end of [strdupa_free]

(* ****** ****** *)

fun strfry {l:agz} (x: !strptr (l) >> _):<!wrt> ptr (l) = "mac#%"

(* ****** ****** *)
//
fun memcpy
  {l:addr}
  {n1,n2:int}
  {n:int | n <= n1; n <= n2}
(
  pf: !b0ytes(n1) @ l >> bytes(n1) @ l
| dst: ptr (l), src: &RD(@[byte][n2]), n: size_t (n)
) :<!wrt> ptr (l) = "mac#%" // end of [memcpy]
//
fun memcpy_unsafe{l:addr}
  (dst: ptr (l), src: ptr, n: size_t):<!wrt> ptr (l) = "mac#%"
//
(* ****** ****** *)
/*
void *memset(void *s, int c, size_t n);
*/
fun memset_unsafe{l:addr}
  (dst: ptr (l), c: int, n: size_t): ptr (l) = "mac#%"
//
(* ****** ****** *)
/*
void *memmove(void *dest, const void *src, size_t n);
*/
fun memmove_unsafe{l:addr}
  (dst: ptr (l), src: ptr, n: size_t):<!wrt> ptr (l) = "mac#%"
//
(* ****** ****** *)
/*
void *memccpy(void *dest, const void *src, int c, size_t n);
*/
fun memccpy_unsafe{l:addr}
  (dst: ptr (l), src: ptr, c: int, n: size_t):<!wrt> Ptr0 = "mac#%"
//
(* ****** ****** *)
//
fun mempcpy
  {l:addr}
  {n1,n2:int}
  {n:int | n <= n1; n <= n2}
(
  pf: !b0ytes(n1) @ l >> bytes(n1) @ l
| dst: ptr (l), src: &RD(@[byte][n2]), n: size_t (n)
) :<!wrt> ptr (l+n) = "mac#%" // end of [mempcpy]
//
fun mempcpy_unsafe{l:addr}{n:int}
  (dst: ptr (l), src: ptr, n: size_t (n)):<!wrt> ptr (l+n) = "mac#%"
//
(* ****** ****** *)
//
// HX: This one is non-reentrant:
//
fun strerror
  (errnum: int):<!ref> [l:agz] vttakeout0 (strptr l) = "mac#%"
// end of [strerror]

(* ****** ****** *)
/*
int strerror_r(int errnum, char *buf, size_t buflen);
*/
fun strerror_r{n:int}
  (errnum: int, buf: &bytes(n), n: size_t (n)):<> int = "mac#%"
// end of [strerror_r]

(* ****** ****** *)

fun strerror_r_gc (errnum: int):<> Strptr1 = "ext#%"

(* ****** ****** *)

(* end of [string.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: October, 2014
//
(* ****** ****** *)

%{#
#include "libc/CATS/float.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

macdef
FLT_EPSILON = $extval (float, "FLT_EPSILON")
macdef
DBL_EPSILON = $extval (double, "DBL_EPSILON")

(* ****** ****** *)

(* end of [float.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/fnmatch.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

macdef
FNM_MATCH = 0 // HX: match is found
macdef
FNM_NOMATCH = $extval (int, "FNM_NOMATCH") // HX: no match is found

(* ****** ****** *)

typedef fnmflags = int

(* ****** ****** *)

(*
FNM_NOESCAPE
If this flag is set, treat backslash as an ordinary character, instead of
an escape character.
*)
macdef
FNM_NOESCAPE = $extval (fnmflags, "FNM_NOESCAPE")

(*
FNM_PATHNAME
If this flag is set, match a slash in string only with a slash in pattern
and not by an asterisk '*' or a question mark (?) metacharacter, nor by a
bracket expression ([]) containing a slash.
*)
macdef
FNM_PATHNAME = $extval (fnmflags, "FNM_PATHNAME")
                                                  
(*
FNM_PERIOD
If this flag is set, a leading period in string has to be matched exactly
by a period in pattern.  A period is considered to be leading if it is the
first character in string, or if both FNM_PATHNAME is set and the period
immediately follows a slash.
*)
macdef
FNM_PERIOD = $extval (fnmflags, "FNM_PERIOD")

(*
FNM_FILE_NAME
This is a GNU synonym for FNM_PATHNAME.
*)
macdef
FNM_FILE_NAME = $extval (fnmflags, "FNM_FILE_NAME")

(*
FNM_LEADING_DIR
If this flag (a GNU extension) is set, the pattern is considered to be
matched if it matches an initial segment of string which is followed by a
slash.  This flag is mainly for the internal use of glibc and is only
implemented in certain cases.
*)
macdef
FNM_LEADING_DIR = $extval (fnmflags, "FNM_LEADING_DIR")
                                                                                                                                             
(*
FNM_CASEFOLD
If this flag (a GNU extension) is set, the pattern is matched
case-insensitively.
*)
macdef
FNM_CASEFOLD = $extval (fnmflags, "FNM_CASEFOLD")

(* ****** ****** *)

symintr fnmatch

fun fnmatch_null
(
  pattern: NSH(string), fname: NSH(string)
) :<> int = "mac#%" // end of [fnmatch]

fun fnmatch_flags
(
  pattern: NSH(string), fname: NSH(string), flags: fnmflags
) :<> int = "mac#%" // end of [fnmatch]

overload fnmatch with fnmatch_null
overload fnmatch with fnmatch_flags

(* ****** ****** *)

(* end of [fnmatch.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: April, 2014
//
(* ****** ****** *)

%{#
#include "libc/CATS/signal.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)
//
staload
TYPES = "libc/sys/SATS/types.sats"
typedef pid_t = $TYPES.pid_t
typedef uid_t = $TYPES.uid_t
typedef clock_t = $TYPES.clock_t
//
(*
staload
PTHREAD = "libc/SATS/pthread.sats"
typedef pthread_t = $PTHREAD.pthread_t
*)
abst@ype
pthread_t0ype =
$extype "pthread_t"
//
typedef pthread_t = pthread_t0ype
//
(* ****** ****** *)
//
// HX: defined in [libc/CATS/signal.cats]
//
abst@ype
signum_t0ype =
$extype"signum_t"
//
typedef signum_t = signum_t0ype
//
macdef SIGHUP = $extval (signum_t, "SIGHUP") // 1
macdef SIGINT = $extval (signum_t, "SIGINT") // 2
macdef SIGQUIT = $extval (signum_t, "SIGQUIT") // 3
macdef SIGILL = $extval (signum_t, "SIGILL") // 4
macdef SIGABRT = $extval (signum_t, "SIGABRT") // 6
macdef SIGFPE = $extval (signum_t, "SIGFPE") // 8
macdef SIGKILL = $extval (signum_t, "SIGKILL") // 9
macdef SIGSEGV = $extval (signum_t, "SIGSEGV") // 11
macdef SIGPIPE = $extval (signum_t, "SIGPIPE") // 13
macdef SIGALRM = $extval (signum_t, "SIGALRM") // 14
macdef SIGTERM = $extval (signum_t, "SIGTERM") // 15
macdef SIGUSR1 = $extval (signum_t, "SIGUSR1")
macdef SIGUSR2 = $extval (signum_t, "SIGUSR2")
macdef SIGCHLD = $extval (signum_t, "SIGCHLD")
macdef SIGCONT = $extval (signum_t, "SIGCONT")
macdef SIGSTOP = $extval (signum_t, "SIGSTOP")
macdef SIGTSTP = $extval (signum_t, "SIGTSTP")
macdef SIGTTIN = $extval (signum_t, "SIGTTIN")
macdef SIGTTOU = $extval (signum_t, "SIGTTOU")
//
macdef SIGBUS = $extval (signum_t, "SIGBUS")
macdef SIGTRAP = $extval (signum_t, "SIGTRAP") // 5
//
macdef SIGIO = $extval (signum_t, "SIGIO")
//
(* ****** ****** *)
//
abstype
sighandler_type = ptr
typedef
sighandler_t = sighandler_type
//
macdef SIG_DFL = $extval (sighandler_t, "SIG_DFL")
macdef SIG_IGN = $extval (sighandler_t, "SIG_IGN")
macdef SIG_HOLD = $extval (sighandler_t, "SIG_HOLD")
macdef SIG_ERR = $extval (sighandler_t, "SIG_ERR")
//
castfn sighandler (f: (signum_t) -<fun1> void): sighandler_t
//
(* ****** ****** *)
//
abst@ype
sigset_t0ype =
$extype"sigset_t"
//
typedef sigset_t = sigset_t0ype
//
// HX-2014-04-07:
// errno [EINVAL] is set in case of failure
//
fun
sigemptyset // 0/-1 : succ/fail
(
  set: &sigset_t? >> opt (sigset_t, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
//
fun
sigfillset // 0/-1 : succ/fail
(
  set: &sigset_t? >> opt (sigset_t, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
//
fun
sigaddset // 0/-1 : succ/fail
  (set: &sigset_t, sgn: signum_t): int = "mac#%"
//
fun
sigdelset // 0/-1 : succ/fail
  (set: &sigset_t, sgn: signum_t): int = "mac#%"
//
fun
sigismember // 0/1/-1 : false/true/error
  (set: &sigset_t, sgn: signum_t): int = "mac#%"
//
(* ****** ****** *)
//
abst@ype
sigmaskhow_t0ype = int
//
typedef sigmaskhow_t = sigmaskhow_t0ype
//
macdef SIG_BLOCK = $extval (sigmaskhow_t, "SIG_BLOCK")
macdef SIG_UNBLOCK = $extval (sigmaskhow_t, "SIG_UNBLOCK")
macdef SIG_SETMASK = $extval (sigmaskhow_t, "SIG_SETMASK")
//
(* ****** ****** *)
//
abst@ype
sigval_t0ype =
$extype"sigval_t"
typedef sigval_t = sigval_t0ype
//
abst@ype
saflag_t0ype = uint
typedef saflag_t = saflag_t0ype
//
macdef
SA_NOCLDSTOP = $extval (saflag_t, "SA_NOCLDSTOP")
macdef
SA_NOCLDWAIT = $extval (saflag_t, "SA_NOCLDWAIT")
macdef SA_NODEFER = $extval (saflag_t, "SA_NODEFER")
macdef SA_ONSTACK = $extval (saflag_t, "SA_ONSTACK")
macdef SA_RESETHAND = $extval (saflag_t, "SA_RESETHAND")
macdef SA_RESTART = $extval (saflag_t, "SA_RESTART")
macdef SA_SIGINFO = $extval (saflag_t, "SA_SIGINFO")
//
(* ****** ****** *)
//
// HX: this one is deprecated; please use [sigaction]
//
fun signal
  (sgn: signum_t, act: sighandler_t): sighandler_t = "mac#%"
// end of [signal]
//
(* ****** ****** *)
//
typedef
siginfo_struct =
$extype_struct"siginfo_t" of
{
  si_signo= int // signal number
, si_sigerror= int // error value
, si_code= int // signal code
, si_trapno= int // trap number that caused HW signal
, si_pid= pid_t // proc ID of the sending process
, si_uid= uid_t // real user ID of the sending process
, si_status= int // exit value or signal
, si_utime= clock_t // user time consumed
, si_stime= clock_t // system time consumed
, si_value= sigval_t // signal value
, si_int= int // signal (POSIX.1b)
, si_ptr= ptr // signal (POSIX.1b)
, si_overrun= int // timer overrun count (POSIX.1b)
, si_timerid= int // timer ID (POSIX.1b)
, si_addr= ptr // memory location that caused fault
, si_band= int // band event
, si_fd= int // file descriptor
} (* end of [siginfo_struct] *)
//
typedef siginfo = siginfo_struct
//
(* ****** ****** *)
//
typedef
sigaction_struct =
$extype_struct
"atslib_sigaction_struct" of
{
  sa_handler= sighandler_t
, sa_sigaction= (int, &siginfo, ptr) -<fun1> void
, sa_mask= sigset_t
, sa_flags= saflag_t
, sa_restorer= ((*void*)) -<fun1> void
} (* end of [sigaction_struct] *)
//
typedef sigaction = sigaction_struct
//
fun sigaction
(
  sgn: signum_t
, newact: &RD(sigaction)
, oldact: &sigaction? >> opt (sigaction, i==0)
) : #[i:int | i <= 0] int i = "mac#%" // 0/-1 : succ/fail
//
fun sigaction_null
  (sgn: signum_t, newact: &RD(sigaction)): int = "mac#%"
//
(* ****** ****** *)
//
fun kill // 0/-1 : succ/fail // errno set
  (proc: pid_t, sgn: signum_t): int = "mac#%"
//
// HX: killpg (pgrp, sgn) = kill (-pgrp, sgn)
//
fun killpg // 0/-1 : succ/fail // errno set
  (pgrp: pid_t, sgn: signum_t): int = "mac#%"
//
(* ****** ****** *)
//
// HX-2014-04:
// raise(sgn) =
// pthread_kill (pthread_self, sgn)
//
fun raise (signum_t): int = "mac#%"
//
fun pthread_kill // 0/errno : succ/fail
  (tid: pthread_t, sgn: signum_t): int = "mac#%"
//
(* ****** ****** *)
//
// HX-2014-04-07: 0/errno : succ/fail
//
fun sigwait
(
  set: &sigset_t
, sgn: &signum_t? >> opt (signum_t, i==0)
) : #[i:int | i >= 0] int(i) = "mac#%"
//
(* ****** ****** *)
//
// HX-2014-04-07:
// [sigpause] is deprecated
// please use [sigsuspend] instead
//
// always -1: fail // errno set
fun sigpause (sgn: signum_t): int = "mac#%"
//
// HX-2014-04-07:
// always -1: fail // errno set // EINTR is set normally
//
fun sigsuspend (mask: &sigset_t): int = "mac#%"
//
(* ****** ****** *)
//
// HX-2014-04-07:
// 0/-1 : succ/fail // errno set
//
fun sigpending
(
  set: &sigset_t? >> opt (sigset_t, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
//
//
// HX-2014-04-07:
// 0/-1 : succ/fail // errno set
//
fun siginterrupt (sgn: signum_t, flag: int): int = "mac#%"
//
(* ****** ****** *)
//
(*
//
// HX: print onto stderr
//
*)
fun psignal
  (sgn: signum_t, msg: string): void = "mac#%"
// end of [psignal]
fun strsignal
  (sgn: signum_t) // HX: errno set?
  :<!ref> [l:addr] (strptr(l) -<lin,prf> void | strptr(l)) = "mac#%"
// end of [strsignal]
//
(* ****** ****** *)

(* end of [signal.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxi AT gmail DOT com
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/time.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)
//
staload
TYPES = "libc/sys/SATS/types.sats"
//
typedef time_t = $TYPES.time_t
typedef clock_t = $TYPES.clock_t
typedef clockid_t = $TYPES.clockid_t
//
macdef
CLOCKS_PER_SEC = $extval (clock_t, "CLOCKS_PER_SEC")
//
macdef
CLOCK_REALTIME = $extval (clockid_t, "CLOCK_REALTIME")
macdef
CLOCK_MONOTONIC = $extval (clockid_t, "CLOCK_MONOTONIC")
//
macdef
CLOCK_THREAD_CPUTIME_ID = $extval (clockid_t, "CLOCK_THREAD_CPUTIME_ID")
macdef
CLOCK_PROCESS_CPUTIME_ID = $extval (clockid_t, "CLOCK_PROCESS_CPUTIME_ID")
//
(* ****** ****** *)

fun difftime
(
  finish: time_t, start: time_t
) :<> double = "mac#%" // endfun

(* ****** ****** *)
//
symintr time
//
fun
time_get ():<> time_t = "mac#%"
//
fun
time_getset
(
  t: &time_t? >> opt (time_t, b)
) :<> #[b:bool] bool (b) = "mac#%"
//
overload time with time_get
overload time with time_getset
//
(* ****** ****** *)

fun ctime // non-reentrant
(
  t: &RD(time_t) // read-only
) :<!ref> [l:agez] vttakeout0 (strptr l) = "mac#%" // endfun

(* ****** ****** *)
//
#define CTIME_BUFSZ 26
//
dataview
ctime_v (m:int, addr, addr) =
  | {l:addr}
    ctime_v_fail (m, l, null) of b0ytes_v (l, m)
  | {l:agz}
    ctime_v_succ (m, l, l) of strbuf_v (l, m, CTIME_BUFSZ-1)
//
fun ctime_r // reentrant-version
  {l:addr}{m:int | m >= CTIME_BUFSZ}
(
  !b0ytes_v (l, m) >> ctime_v (m, l, l1) | &RD(time_t), ptr (l)
) :<!wrt> #[l1:addr] ptr (l1) = "mac#%" // end of [ctime_r]
//
fun{
} ctime_r_gc (&RD(time_t)):<!wrt> Strptr0 // end of [ctime_r_gc]
//
(* ****** ****** *)

typedef
tm_struct =
$extype_struct"atslib_tm_struct_type" of
{
  tm_sec= int // natLt(60)
, tm_min= int // natLt(60)
, tm_hour= int // natLt(24)
, tm_mon= int (* month *) // natLt(12)
, tm_year= int (* year *) // starting from 1900
, tm_wday= int (* day of the week *) // natLt(7)
, tm_mday= int (* day of the month *)
, tm_yday= int (* day in the year *)
, tm_isdst= int (* daylight saving time *) // yes/no: 1/0
} // end of [tm_struct] // end of [typedef]

(* ****** ****** *)
//
(*
** HX (2010-01-15):
** These functions are now kept for backward compatibility
*)
fun tm_get_sec
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_min
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_hour
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_mday
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_mon
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_year
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_wday
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_yday
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_isdst
  (tm: &READ(tm_struct)):<> int = "mac#%"
//
(* ****** ****** *)

fun mktime (tm: &RD(tm_struct)):<> time_t = "mac#%"

(* ****** ****** *)

fun asctime
(
  tm: &RD(tm_struct)
) :<!ref> [l:addr] vttakeout0 (strptr l) = "mac#%"

(* ****** ****** *)

/*
size_t
strftime
(
  char *s, size_t max, const char *format, const struct tm *tm
) ; // end of [strftime]
*/
fun strftime
  {l:addr}{m:pos} (
  pf: !b0ytes(m) @ l >> strbuf(m, n) @ l
| p: ptr l, m: size_t m, fmt: string, tm: &RD(tm_struct)
) :<> #[n:nat | n < m] size_t n = "mac#%" // endfun

(* ****** ****** *)

fun
gmtime // non-reentrant
(
  tval: &RD(time_t)
) :<!ref>
[
  l:addr
] (
  option_v (vtakeout0 (tm_struct@l), l > null) | ptr l
) = "mac#%" // end of [gmtime]

fun
gmtime_r // reentrant-version
(
  tval: &RD(time_t), tm: &tm_struct? >> opt (tm_struct, l > null)
) :<> #[l:addr] ptr (l) = "mac#%" // endfun

(* ****** ****** *)

fun
localtime // non-reentrant
(
  tval: &RD(time_t) // read-only
) :<!ref>
[
  l:addr
] (
  option_v (vtakeout0 (tm_struct@l), l > null) | ptr l
) = "mac#%" // end of [localtime]

fun
localtime_r // reentrant-version
(
  tval: &RD(time_t), tm: &tm_struct? >> opt (tm_struct, l > null)
) :<> #[l:addr] ptr (l) = "mac#%" // endfun

(* ****** ****** *)

fun tzset ():<!ref> void = "mac#%"

(* ****** ****** *)

fun clock (): clock_t = "mac#%" // -1 for error

(* ****** ****** *)

typedef
timespec =
$extype_struct"atslib_timespec_type" of
{
  tv_sec= time_t (*secs*), tv_nsec= lint (*nanosecs*)
} // end of [extype_struct] // end of [timespec]

(* ****** ****** *)

fun
nanosleep
(
  tms: &RD(timespec)
, rem: &timespec? >> opt (timespec, i==0)
) : #[i:int | i <= 0] int(i) = "mac#%"

fun
nanosleep_null (tms: &RD(timespec)): int = "mac#%"

(* ****** ****** *)
//
// HX:
// librt is needed for these functions
//
fun
clock_getres
(
  id: clockid_t
, res: &timespec? >> opt (timespec, i==0)
) : #[i:int | i <= 0] int(i) = "mac#%"
//
fun
clock_gettime
(
  id: clockid_t
, tms: &timespec? >> opt (timespec, i==0)
) : #[i:int | i <= 0] int(i) = "mac#%"
//
// HX: this one requires SUPERUSER previlege
//
fun
clock_settime
  (id: clockid_t, tms: &RD(timespec)): int = "mac#%"
//
(* ****** ****** *)

(* end of [time.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: April, 2011
//
(* ****** ****** *)

%{#
#include "libc/CATS/stdio.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

sortdef fm = file_mode

(* ****** ****** *)

stadef r() = file_mode_r()
stadef w() = file_mode_w()
stadef rw() = file_mode_rw()

(* ****** ****** *)
//
staload
TYPES =
"libc/sys/SATS/types.sats"
//
stadef fildes = $TYPES.fildes
stadef fildes_v = $TYPES.fildes_v
//
(* ****** ****** *)

(*
abstype FILEref = ptr // declared in [prelude/basic_dyn.sats]
*)

(* ****** ****** *)
//
// HX-2011-04-02:
//
absview
FILE_view (l:addr, m:fm)
absvtype
FILEptr_vtype (addr, fm) = ptr
//
viewdef
FILE_v (l:addr, m:fm) = FILE_view (l, m)
vtypedef
FILEptr (l:addr, m: fm) = FILEptr_vtype (l, m)
//
(* ****** ****** *)
//
vtypedef
FILEptr0 (m:fm) =
  [l:addr | l >= null] FILEptr (l, m)
//
vtypedef
FILEptr1 (m:fm) = [l:agz] FILEptr (l, m)
vtypedef
FILEptr1 (*none*) = [l:agz;m:fm] FILEptr (l, m)
//
(* ****** ****** *)

stadef fmlte = file_mode_lte

(* ****** ****** *)
//
castfn
FILEptr2ptr
  {l:addr}{m:fm}(filp: !FILEptr (l, m)):<> ptr(l)
//
overload ptrcast with FILEptr2ptr
//
(* ****** ****** *)

castfn
FILEptr_encode
  {l:addr}{m:fm} (
  pf: FILE_v (l, m) | p: ptr l
) : FILEptr (l, m)
overload encode with FILEptr_encode

castfn
FILEptr_decode
  {l:agz}{m:fm} (
  p: FILEptr (l, m)
) : (FILE_v (l, m) | ptr l)
overload decode with FILEptr_decode

(* ****** ****** *)

praxi
FILEptr_free_null
  {l:alez}{m:fm} (p: FILEptr (l, m)):<prf> void
// end of [FILEptr_free_null]

(* ****** ****** *)

castfn
FILEptr_refize (filp: FILEptr1):<> FILEref

(* ****** ****** *)

castfn
FILEref_vttakeout // a lock is associated with FILEref-value
  {m:fm} (filr: FILEref):<> [l:agz] vttakeout0 (FILEptr (l, m))
// end of [FILEref_vttakeout]

(* ****** ****** *)
//
abst@ype whence_type = int
//
typedef whence = whence_type
//
macdef SEEK_SET = $extval (whence, "SEEK_SET")
macdef SEEK_CUR = $extval (whence, "SEEK_CUR")
macdef SEEK_END = $extval (whence, "SEEK_END")
//
(* ****** ****** *)
(*
//
// FILE *fopen (const char *path, const char *mode);
//
The fopen function opens the file whose name is the string pointed to by
path and associates a stream with it.

The argument mode points to a string beginning with one of the follow
ing sequences (Additional characters may follow these sequences.):

  r      Open  text  file  for  reading.  The stream is positioned at the
         beginning of the file.

  r+     Open for reading and writing.  The stream is positioned  at  the
         beginning of the file.

  w      Truncate  file  to  zero length or create text file for writing.
         The stream is positioned at the beginning of the file.

  w+     Open for reading and writing.  The file is created  if  it  does
         not  exist, otherwise it is truncated.  The stream is positioned
         at the beginning of the file.

  a      Open for appending (writing at end of file).  The file is created
         if it does not exist.  The stream is positioned at the end of the
         file.

  a+     Open for reading and appending (writing at end  of  file).   The
         file  is created if it does not exist.  The stream is positioned
         at the end of the file.

*)

fun fopen{m:fm}
(
  path: NSH(string), fmode(m)
) :<!wrt> FILEptr0 (m) = "mac#%"

fun fopen_exn{m:fm}
(
  path: NSH(string), fmode(m)
) :<!exnwrt> FILEptr1 (m) = "ext#%"

fun fopen_ref_exn{m:fm}
(
  path: NSH(string), fmode(m)
) :<!exnwrt> FILEref(*none*) = "ext#%"

(* ****** ****** *)
//
symintr fclose
symintr fclose_exn
//
fun fclose0
  (filr: FILEref):<!wrt> int = "mac#%"
fun fclose1
  {l:addr}{m:fm}
(
  filp: !FILEptr (l, m) >> ptr l
) :<!wrt>
  [i:int | i <= 0]
(
  option_v (FILE_v (l, m), i < 0) | int i
) = "mac#%" // endfun
//
overload fclose with fclose0
overload fclose with fclose1
//
fun fclose0_exn
  (filr: FILEref):<!exnwrt> void = "ext#%"
fun fclose1_exn
  (filp: FILEptr1(*none*)):<!exnwrt> void = "ext#%"
//
overload fclose_exn with fclose0_exn
overload fclose_exn with fclose1_exn
//
(* ****** ****** *)

(*
fun fclose_stdin ():<!exnwrt> void = "ext#%"
fun fclose_stdout ():<!exnwrt> void = "ext#%"
fun fclose_stderr ():<!exnwrt> void = "ext#%"
*)

(* ****** ****** *)
(*
//
// FILE *freopen (const char *path, const char *mode, FILE *stream);
//
The [freopen] function opens the file whose name is the string pointed to
by path and associates the stream pointed to by stream with it.  The original
stream (if it exists) is closed.  The mode argument is used just as in the
fopen function.  The primary use of the freopen function is to change the file
associated with a standard text stream (stderr, stdin, or stdout).
//
*)
//
symintr freopen
symintr freopen_exn
//
fun freopen0 {m2:fm}
(
  path: NSH(string), m2: fmode m2, filr: FILEref
) :<!wrt> Ptr0 = "mac#%"
//
// HX-2012-07:
// the original stream is closed even if [freopen] fails.
//
fun freopen1
  {m1,m2:fm}{l0:addr}
(
  path: NSH(string), m2: fmode m2, filp: FILEptr (l0, m1)
) :<!wrt> [
  l:addr | l==null || l==l0
] (
  option_v (FILE_v (l, m2), l > null) | ptr l
) = "mac#%" // end of [freopen1]
//
overload freopen with freopen0
overload freopen with freopen1
//
fun
freopen0_exn
  {m2:fm}
(
  path: NSH(string), m2: fmode m2, filr: FILEref
) :<!exnwrt> void = "ext#%" // end of [freopen0_exn]
overload freopen_exn with freopen0_exn
//
(* ****** ****** *)

(*
fun freopen_stdin
  (path: NSH(string)):<!exnwrt> void = "ext#%"
// end of [freopen_stdin]
fun freopen_stdout
  (path: NSH(string)):<!exnwrt> void = "ext#%"
// end of [freopen_stdout]
fun freopen_stderr
  (path: NSH(string)):<!exnwrt> void = "ext#%"
// end of [freopen_stderr]
*)

(* ****** ****** *)
(*
//
// int fileno (FILE* filp) ;
// 
The function fileno examines the argument stream and returns its integer
descriptor. In case fileno detects that its argument is not a valid stream,
it must return -1 and set errno to EBADF.
*)
//
symintr fileno
//
fun fileno0 (filr: FILEref):<> int = "mac#%"
overload fileno with fileno0
fun fileno1 (filp: !FILEptr1(*none*)):<> int = "mac#%"
overload fileno with fileno1

(* ****** ****** *)

(*
//
// HX-2011-08
//
*)
dataview
fdopen_v
(
  fd:int, addr, m: fmode
) =
  | {l:agz}
    fdopen_v_succ (fd, l, m) of FILE_v (l, m)
  | fdopen_v_fail (fd, null, m) of fildes_v (fd)
// end of [fdopen_v]

fun fdopen
  {fd:int}{m:fm}
(
  fd: fildes (fd), m: fmode (m)
) : [l:agez] 
(
  fdopen_v (fd, l, m) | ptr l
) = "mac#%" // end of [fdopen]

fun fdopen_exn
  {fd:int}{m:fm}
  (fd: fildes (fd), m: fmode (m)): FILEptr1 (m) = "ext#%"
// end of [fdopen_exn]

(* ****** ****** *)
(*  
//
// int feof (FILE *stream);
//
The function feof() returns a nonzero value if the end of the given file
stream has been reached.
//
*)
//
symintr feof
//
fun feof0 (filr: FILEref):<> int = "mac#%"
overload feof with feof0
fun feof1 (filp: !FILEptr1(*none*)):<> int = "mac#%"
overload feof with feof1

(* ****** ****** *)
(*
//
// int ferror (FILE *stream);
//
The function [ferror] tests the error indicator for the stream pointed to by
stream, returning non-zero if it is set.  The error indicator can only be
reset by the [clearerr] function.
*)
//
symintr ferror
//
fun ferror0 (filr: FILEref):<> int = "mac#%"
overload ferror with ferror0
fun ferror1 (filp: !FILEptr1(*none*)):<> int = "mac#%"
overload ferror with ferror1

(* ****** ****** *)
(*
//
// void clearerr (FILE *stream);
//
The function [clearerr] clears the end-of-file and error indicators for
the stream pointed to by stream.
//
*)
//
symintr clearerr
//
fun clearerr0
  (filr: FILEref):<!wrt> void = "mac#%"
overload clearerr with clearerr0
fun clearerr1
  (filp: !FILEptr1(*none*)):<!wrt> void = "mac#%"
overload clearerr with clearerr1

(* ****** ****** *)
(*
//
// int fflush (FILE *stream);
//
The function fflush forces a write of all user-space buffered data for the
given output or update stream via the streams underlying write function.
The open status of the stream is unaffected.
//
Upon successful completion 0 is returned.  Otherwise, EOF is returned and
the global variable errno is set to indicate the error.
*)
//
symintr fflush
symintr fflush_exn
//
fun fflush0
  (out: FILEref):<!wrt> int = "mac#%"
fun fflush1 {m:fm}
(
  pf: fmlte (m, w) | out: !FILEptr1 (m)
) :<!wrt> [i:int | i <= 0] int (i) = "mac#%"
//
overload fflush with fflush0
overload fflush with fflush1
//
fun fflush0_exn
  (out: FILEref):<!exnwrt> void = "ext#%"
overload fflush_exn with fflush0_exn
//
(* ****** ****** *)
//
fun fflush_all ():<!exnwrt> void = "ext#%"
fun fflush_stdout ():<!exnwrt> void = "ext#%"
//
(* ****** ****** *)
(*
//
// int fgetc (FILE *stream)
//
[fgetc] reads the next character from stream and returns it as an
unsigned char cast to an int, or EOF on end of file or error. Note
that EOF must be a negative number!
//
*)
//
symintr fgetc
//
fun fgetc0
  (inp: FILEref):<!wrt> int = "mac#%"
fun fgetc1 {m:fm}
(
  pf: fmlte (m, r()) | inp: !FILEptr1 (m)
) :<!wrt> intLte (UCHAR_MAX) = "mac#%"
//
overload fgetc with fgetc0
overload fgetc with fgetc1
//
(* ****** ****** *)

macdef getc = fgetc

(* ****** ****** *)

fun getchar0 ():<!wrt> int = "mac#%"
fun getchar1 (
) :<!wrt> [i:int | i <= UCHAR_MAX] int i = "mac#%"

(* ****** ****** *)
//
symintr fgets
//
fun fgets0
  {sz:int}{n0:pos | n0 <= sz}
(
  buf: &b0ytes(sz) >> bytes(sz), n0: int n0, inp: FILEref
) :<!wrt> Ptr0 = "mac#%" // = addr@(buf) or NULL
fun fgets1
  {sz:int}{n0:pos | n0 <= sz}{m:fm}
(
  pfm: fmlte (m, r)
| buf: &b0ytes(sz) >> bytes(sz), n0: int n0, inp: !FILEptr1 (m)
) :<!wrt> Ptr0 = "mac#%" // = addr@(buf) or NULL
//
overload fgets with fgets0
overload fgets with fgets1
//
dataview
fgets_v (
  sz:int, n0: int, addr, addr
) =
  | {l0:addr}
    fgets_v_fail (sz, n0, l0, null) of b0ytes(sz) @ l0
  | {n:nat | n < n0} {l0:agz}
    fgets_v_succ (sz, n0, l0, l0) of strbuf(sz, n) @ l0
// end of [fgets_v]
//
fun fgets1_err
  {sz,n0:int | sz >= n0; n0 > 0}{l0:addr}{m:fm}
(
  pf_mod: fmlte (m, r), pf_buf: b0ytes (sz) @ l0
| p0: ptr (l0), n0: int (n0), inp: !FILEptr1 (m)
) :<> [l1:addr] (fgets_v (sz, n0, l0, l1) | ptr l1) = "mac#%"
// end of [fgets_err]
//
overload fgets with fgets1_err
//
(* ****** ****** *)
//
// HX-2013-05:
// A complete line is read each time // [nullp] for error
//
fun fgets0_gc
  (bsz: intGte(1), inp: FILEref): Strptr0 = "ext#%"
fun fgets1_gc {m:fm}
(
  pf_mod: fmlte (m, r) | bsz: intGte(1), inp: FILEptr1 (m)
) : Strptr0 = "ext#%" // end of [fget1_gc]

(* ****** ****** *)
(*
//
// int fgetpos(FILE *stream, fpos_t *pos);
//
The [fgetpos] function stores the file position indicator of the given file
stream in the given position variable. The position variable is of type
fpos_t (which is defined in stdio.h) and is an object that can hold every
possible position in a FILE. [fgetpos] returns zero upon success, and a
non-zero value upon failure.
//
*)
//
symintr fgetpos
//
abst@ype fpos_t = $extype"ats_fpos_type"
//
fun fgetpos0
(
  filp: FILEref, pos: &fpos_t? >> opt (fpos_t, i==0)
) :<!wrt> #[i:int | i <= 0] int (i) = "mac#%"
fun fgetpos1
(
  filp: !FILEptr1, pos: &fpos_t? >> opt (fpos_t, i==0)
) :<!wrt> #[i:int | i <= 0] int (i) = "mac#%"
//
overload fgetpos with fgetpos0
overload fgetpos with fgetpos1
//
symintr fgetpos_exn
//
fun fgetpos0_exn 
  (filp: FILEref, pos: &fpos_t? >> _) :<!exnwrt> void = "ext#%"
overload fgetpos_exn with fgetpos0_exn 
//
(* ****** ****** *)
(*
//
// int fputc (int c, FILE *stream)
//
The function [fputc] writes the given character [c] to the given output
stream. The return value is the character, unless there is an error, in
which case the return value is EOF.
//
*)
//
symintr fputc
//
typedef
fputc0_type
  (a:t0p) = (a, FILEref) -<0,!wrt> int
fun fputc0_int : fputc0_type (int) = "mac#%" 
fun fputc0_char : fputc0_type (char) = "mac#%" 
overload fputc with fputc0_int of 0
overload fputc with fputc0_char of 0
//
typedef
fputc1_type
  (a:t0p) = {m:fm}
(
  fmlte (m, w()) | a, !FILEptr1 (m)
) -<0,!wrt> intLte (UCHAR_MAX)
fun fputc1_int : fputc1_type (int) = "mac#%"
fun fputc1_char : fputc1_type (char) = "mac#%"
overload fputc with fputc1_int of 10
overload fputc with fputc1_char of 10
//
symintr fputc_exn
//
typedef
fputc0_exn_type
  (a:t0p) = (a, FILEref) -<0,!exnwrt> void
fun fputc0_exn_int : fputc0_exn_type (int) = "ext#%"
fun fputc0_exn_char : fputc0_exn_type (char) = "ext#%"
overload fputc_exn with fputc0_exn_int of 0
overload fputc_exn with fputc0_exn_char of 0
//
(* ****** ****** *)

macdef putc = fputc

(* ****** ****** *)

fun putchar0 (c: int):<!wrt> int = "mac#%"
fun putchar1
  (c: int):<!wrt> [i:int | i <= UCHAR_MAX] int i = "mac#%"
// end of [putchar1]

(* ****** ****** *)
(*
//
// int fputs (const char* s, FILE *stream)
//
The function [fputs] writes a string to a file. it returns
a non-negative number on success, or EOF on error.
*)

//
symintr fputs
symintr fputs_exn
//
fun fputs0
(
  str: NSH(string), fil: FILEref
) :<!wrt> int = "mac#%"
fun fputs1{m:fm}
(
  pf: fmlte (m, w()) | str: NSH(string), out: !FILEptr1 (m)
) :<!wrt> int = "mac#%"
//
overload fputs with fputs0
overload fputs with fputs1
//
fun fputs0_exn
(
  str: NSH(string), fil: FILEref
) :<!exnwrt> void = "ext#%"
//
overload fputs_exn with fputs0_exn
//
(* ****** ****** *)
//
// [puts] puts a newline at the end
//
fun puts
  (inp: NSH(string)):<!wrt> int = "mac#%"
// end of [puts]
fun puts_exn
  (inp: NSH(string)):<!exnwrt> void = "ext#%"
// end of [puts_exn]

(* ****** ****** *)
(*
//
// size_t fread (void *ptr, size_t size, size_t nmemb, FILE *stream);
//
The function [fread] reads [nmemb] elements of data, each [size] bytes
long, from the stream pointed to by stream, storing them at the location
given by ptr. The return value is the number of items that are actually
read.
//
[fread] does not distinguish between end-of-file and error, and callers
must use [feof] and [ferror] to determine which occurred.
//
*)
//
symintr fread
//
fun
fread0 // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
(
  buf: &bytes(nbf) >> _
, isz: size_t isz, n: size_t n
, inp: FILEref(*none*)
) :<!wrt> sizeLte n = "mac#%"
fun
fread1 // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
  {m:fm}
(
  pfm: fmlte (m, r)
| buf: &bytes(nbf) >> _
, isz: size_t isz, n: size_t n
, inp: !FILEptr1 (m)
) :<!wrt> sizeLte n = "mac#%"
//
overload fread with fread0
overload fread with fread1
//
symintr fread_exn
//
fun
fread0_exn // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
(
  buf: &bytes(nbf) >> _, isz: size_t isz, n: size_t n, inp: FILEref
) :<!exnwrt> sizeLte n = "ext#%" // endfun
overload fread_exn with fread0_exn

(* ****** ****** *)
(*
//
// size_t fwrite (
//   const void *ptr,  size_t size,  size_t nmemb, FILE *stream
// ) ;
//
The function [fwrite] writes [nmemb] elements of data, each [size] bytes
long, to the stream pointed to by stream, obtaining them from the location
given by [ptr]. The return value is the number of items that are actually
written.
//
*)
//
symintr fwrite
//
fun
fwrite0 // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
(
  buf: &RD(bytes(nbf))
, isz: size_t isz, n: size_t n
, out: FILEref
) :<!wrt> sizeLte (n) = "mac#%"
fun
fwrite1 // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
  {m:fm}
(
  pfm: fmlte(m, w())
| buf: &RD(bytes(nbf))
, isz: size_t isz, n: size_t n
, out: !FILEptr1 (m)
) :<!wrt> sizeLte (n) = "mac#%"
//
overload fwrite with fwrite0
overload fwrite with fwrite1
//
symintr fwrite_exn
//
fun
fwrite0_exn // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
(
  buf: &RD(bytes(nbf))
, isz: size_t isz, n: size_t n
, out: FILEref(*none*)
) :<!exnwrt> sizeLte (n) = "ext#%"
overload fwrite_exn with fwrite0_exn

(* ****** ****** *)
(*
//
// int fseek (FILE *stream, long offset, int whence)
//
The [fseek] function sets the file position indicator for the stream
pointed to by stream.  The new position, measured in bytes, is obtained by
adding offset bytes to the position specified by whence.  If whence is set
to [SEEK_SET], [SEEK_CUR], or [SEEK_END], the offset is relative to the
start of the file, the current position indicator, or end-of-file,
respectively.  A successful call to the [fseek] function clears the end-
of-file indicator for the stream and undoes any effects of the [ungetc]
function on the same stream. Upon success, [fseek] returns 0. Otherwise,
it returns -1.
//
*)
//
symintr fseek
symintr fseek_exn
//
fun fseek0
(
  filr: FILEref, offset: lint, whence: whence
) :<!wrt> int = "mac#%"
fun fseek1
(
  f: !FILEptr1(*none*), offset: lint, whence: whence
) :<!wrt> int = "mac#%"
//
overload fseek with fseek0
overload fseek with fseek1
//
fun fseek0_exn
(
  filr: FILEref, offset: lint, whence: whence
) :<!exnwrt> void = "ext#%"
//
overload fseek_exn with fseek0_exn
//
(* ****** ****** *)
(*
//
// void fsetpos(FILE *stream, const fpos_t *pos);
//
The [fsetpos] function moves the file position indicator for the given
stream to a location specified by the position object. The type fpos_t is
defined in stdio.h.  The return value for fsetpos() is zero upon success,
non-zero on failure.
//
*)
//
symintr fsetpos
symintr fsetpos_exn
//
fun fsetpos0
  (filp: FILEref(*none*), pos: &RD(fpos_t)):<!wrt> int = "mac#%"
fun fsetpos1
  (filp: !FILEptr1(*none*), pos: &RD(fpos_t)):<!wrt> int = "mac#%"
//
overload fsetpos with fsetpos0
overload fsetpos with fsetpos1
//
fun fsetpos0_exn
  (filp: FILEref(*none*), pos: &RD(fpos_t)):<!exnwrt> void = "ext#%"
//
overload fsetpos_exn with fsetpos0_exn
//
(* ****** ****** *)

(*
//
// long ftell (FILE *stream)
//
[ftell] returns the current offset of the given file stream upon on
success. Otherwise, -1 is returned and the global variable errno is set to
indicate the error.
//
*)
//
symintr ftell
symintr ftell_exn
//
fun ftell0
  (filr: FILEref):<!wrt> lint = "mac#%"
fun ftell1
  (filp: !FILEptr1(*none*)):<!wrt> lint = "mac#%"
overload ftell with ftell0
overload ftell with ftell1
//
fun ftell0_exn
  (filr: FILEref):<!exnwrt> lint = "ext#%"
//
overload ftell_exn with ftell0_exn
//
(* ****** ****** *)

(*
//
// perror - print a system error message
//
The routine [perror(s)] produces a message on the standard error output,
describing the last error encountered during a call to a system or library
function.  First (if s is not NULL and *s is not NULL) the argument string
s is printed, followed by a colon and a blank.  Then the message and a
newline.
//
*)
fun perror
  (msg: NSH(string)):<!wrt> void = "mac#%"
// end of [perror]

(* ****** ****** *)

abstype pmode_type (m:fm) = string
typedef pmode (m:fm) = pmode_type (m)

absview popen_view (l:addr)
viewdef popen_v (l:addr) = popen_view (l)

praxi popen_v_free_null (pf: popen_v (null)): void

fun popen{m:fm}
(
  cmd: NSH(string), mode: pmode (m)
) : [l:addr] (popen_v (l) | FILEptr (l, m))

fun popen_exn{m:fm}
(
  cmd: NSH(string), mode: pmode (m)
) : FILEref = "ext#%" // endfun

fun pclose0_exn (filr: FILEref): int = "ext#%"
fun pclose1_exn
  {l:agz}{m:fm}
  (pf: popen_v l | filr: FILEptr (l, m)): int= "ext#%"
// end of [pclose1_exn]

(* ****** ****** *)

fun remove
  (inp: NSH(string)):<!wrt> int = "mac#%"
fun remove_exn
  (inp: NSH(string)):<!exnwrt> void = "ext#%"

(* ****** ****** *)

fun rename
(
  oldpath: NSH(string), newpath: NSH(string)
) :<!wrt> int = "mac#%" // end of [fun]

fun rename_exn
(
  oldpath: NSH(string), newpath: NSH(string)
) :<!exnwrt> void = "ext#%" // end of [fun]

(* ****** ****** *)
(*
// HX: [rewind] generates no error
*)
//
symintr rewind
//
fun rewind0
  (fil: FILEref):<!wrt> void = "mac#%"
overload rewind with rewind0
fun rewind1
  (fil: !FILEptr1(*none*)):<!wrt> void = "mac#%"
overload rewind with rewind1

(* ****** ****** *)
//
fun
tmpfile() :<!wrt> FILEptr0 (rw()) = "mac#%"
//
fun
tmpfile_exn() :<!exnwrt> FILEptr1 (rw()) = "ext#%"
//
fun
tmpfile_ref_exn() :<!exnwrt> FILEref(*none*) = "ext#%"
//
(* ****** ****** *)
(*
//
// int ungetc(int c, FILE *stream);
//
[ungetc] pushes [c] back to stream, cast to unsigned char, where it is
available for subsequent read operations.  Pushed-back characters will be
returned in reverse order; only one pushback is guaranteed.
//
*)
//
symintr ungetc
//
fun
ungetc0
  (c: char, f: FILEref):<!wrt> int = "mac#%"
fun
ungetc1
  {l:agz}{m:fm}
(
  pfm: fmlte (m, rw()) | c: char, f: !FILEptr (l, m)
) :<!wrt> [i:int | i <= UCHAR_MAX] int (i) = "mac#%"
//
overload ungetc with ungetc0
overload ungetc with ungetc1
//
symintr ungetc_exn
//
fun ungetc0_exn
  (c: char, f: FILEref) :<!exnwrt> void = "ext#%"
//
overload ungetc_exn with ungetc0_exn
//
(* ****** ****** *)

stacst BUFSIZ : int
praxi BUFSIZ_gtez (): [BUFSIZ >= 0] void
macdef BUFSIZ = $extval (int(BUFSIZ), "BUFSIZ")

(* ****** ****** *)
//
abst@ype bufmode_t = int
//
macdef _IOFBF = $extval (bufmode_t, "_IOFBF") // fully buffered
macdef _IOLBF = $extval (bufmode_t, "_IOLBF") // line buffered
macdef _IONBF = $extval (bufmode_t, "_IONBF") // no buffering
//
(* ****** ****** *)
//
symintr setbuf_null
//
fun setbuf0_null
  (f: FILEref): void = "mac#%"
overload setbuf_null with setbuf0_null
fun setbuf1_null
  (f: !FILEptr1(*none*)): void = "mac#%"
overload setbuf_null with setbuf1_null

(* ****** ****** *)
(*
//
// HX-2010-10-03:
// the buffer can be freed only after it is no longer used by
// the stream to which it is attached!!!
*)
//
symintr setbuffer
//
fun
setbuffer0
  {n1,n2:nat | n2 <= n1}{l:addr}
(
  pf_buf: !b0ytes n1 @ l | f: FILEref, p_buf: ptr l, n2: size_t n2
) : void = "mac#%"
overload setbuffer with setbuffer0
fun
setbuffer1
  {n1,n2:nat | n2 <= n1}{lbf:addr}
(
  pf_buf: !b0ytes n1 @ lbf | f: !FILEptr1(*none*), p_buf: ptr lbf, n2: size_t n2
) : void = "mac#%"
overload setbuffer with setbuffer1

(* ****** ****** *)
//
symintr setlinebuf
//
fun setlinebuf0
  (f: FILEref): void = "mac#%"
overload setlinebuf with setlinebuf0
fun setlinebuf1
  (f: !FILEptr1(*none*)): void = "mac#%"
overload setlinebuf with setlinebuf1

(* ****** ****** *)
//
symintr setvbuf_null
//
fun setvbuf0_null
  (f: FILEref, mode: bufmode_t): int = "mac#%"
overload setvbuf_null with setvbuf0_null
fun setvbuf1_null
  (f: !FILEptr1(*none*), mode: bufmode_t): int = "mac#%"
overload setvbuf_null with setvbuf1_null

(* ****** ****** *)
//
symintr setvbuf
//
fun
setvbuf0
  {n1,n2:nat | n2 <= n1}{lbf:addr}
(
  pf_buf: !b0ytes(n1) @ lbf | fil: FILEref, mode: bufmode_t, n2: size_t n2
) : int = "mac#%"
overload setvbuf with setvbuf0
fun
setvbuf1
  {n1,n2:nat | n2 <= n1}{lbf:addr}
(
  pf_buf: !b0ytes(n1) @ lbf | fil: !FILEptr1(*none*), mode: bufmode_t, n2: size_t n2
) : int = "mac#%"
overload setvbuf with setvbuf1

(* ****** ****** *)

(* end of [stdio.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/fcntl.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)
//
staload
TYPES =
"libc/sys/SATS/types.sats"
//
typedef mode_t = $TYPES.mode_t
//
vtypedef
fildes (i:int) = $TYPES.fildes (i)
//
vtypedef Fildes = $TYPES.Fildes
vtypedef Fildes0 = $TYPES.Fildes0
//
(* ****** ****** *)

praxi
fildes_neg_elim {fd:int | fd < 0} (fd: fildes (fd)): void

(* ****** ****** *)
//
// HX: this is just a castfn
//
fun fildes_get_int
  {fd:int} (fd: !fildes (fd)):<> int (fd) = "mac#%"
//
fun fildes_isgtez
  {fd:int} (fd: !fildes (fd)):<> bool (fd >= 0) = "mac#%"
//
(* ****** ****** *)
//
fun fildes_iget_int
  (fd: int):<> [fd:int] vttakeout0 (fildes (fd)) = "ext#%"
//
(* ****** ****** *)

abst@ype fcntlflags = int
//
macdef O_CREAT  = $extval (fcntlflags, "O_CREAT")
macdef O_EXCL   = $extval (fcntlflags, "O_EXCL")
macdef O_TRUNC  = $extval (fcntlflags, "O_TRUNC")
macdef O_APPEND = $extval (fcntlflags, "O_APPEND")
//
macdef O_RDWR   = $extval (fcntlflags, "O_RDWR")
macdef O_RDONLY = $extval (fcntlflags, "O_RDONLY")
macdef O_WRONLY = $extval (fcntlflags, "O_WRONLY")
//
macdef O_SYNC   = $extval (fcntlflags, "O_SYNC")
macdef O_ASYNC  = $extval (fcntlflags, "O_ASYNC")
//
macdef O_NOCTTY = $extval (fcntlflags, "O_NOCTTY")
//  
(* ****** ****** *)

fun lor_fcntlflags_fcntlflags
  : (fcntlflags, fcntlflags) -<> fcntlflags = "ext#atspre_lor_int_int"
overload lor with lor_fcntlflags_fcntlflags

(* ****** ****** *)

fun open_flags
(
  path: NSH(string), flags: fcntlflags
) : Fildes = "mac#%" // endfun

fun open_flags_mode
(
  path: NSH(string), flags: fcntlflags, mode: mode_t
) : Fildes = "mac#%" // endfun

(* ****** ****** *)

fun fcntl_getfl (fd: !Fildes0): fcntlflags = "mac#%"
fun fcntl_setfl (fd: !Fildes0, flags: fcntlflags): int = "mac#%"

(* ****** ****** *)

(* end of [fcntl.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

typedef sysconfname = int

(* ****** ****** *)
//
// HX: error reporting:
// -1 is returned and errno is set
//
fun sysconf (name: sysconfname): lint = "mac#%"
//
(* ****** ****** *)

macdef _SC_ARG_MAX = $extval (sysconfname, "_SC_ARG_MAX")
macdef _SC_CHILD_MAX = $extval (sysconfname, "_SC_CHILD_MAX")
macdef _SC_CLK_TCK = $extval (sysconfname, "_SC_CLK_TCK")
macdef _SC_NGROUPS_MAX = $extval (sysconfname, "_SC_NGROUPS_MAX")
macdef _SC_OPEN_MAX = $extval (sysconfname, "_SC_OPEN_MAX")
macdef _SC_STREAM_MAX = $extval (sysconfname, "_SC_STREAM_MAX")
macdef _SC_TZNAME_MAX = $extval (sysconfname, "_SC_TZNAME_MAX")
macdef _SC_JOB_CONTROL = $extval (sysconfname, "_SC_JOB_CONTROL")
macdef _SC_SAVED_IDS = $extval (sysconfname, "_SC_SAVED_IDS")
macdef _SC_REALTIME_SIGNALS = $extval (sysconfname, "_SC_REALTIME_SIGNALS")
macdef _SC_PRIORITY_SCHEDULING = $extval (sysconfname, "_SC_PRIORITY_SCHEDULING")
macdef _SC_TIMERS = $extval (sysconfname, "_SC_TIMERS")
macdef _SC_ASYNCHRONOUS_IO = $extval (sysconfname, "_SC_ASYNCHRONOUS_IO")
macdef _SC_PRIORITIZED_IO = $extval (sysconfname, "_SC_PRIORITIZED_IO")
macdef _SC_SYNCHRONIZED_IO = $extval (sysconfname, "_SC_SYNCHRONIZED_IO")
macdef _SC_FSYNC = $extval (sysconfname, "_SC_FSYNC")
macdef _SC_MAPPED_FILES = $extval (sysconfname, "_SC_MAPPED_FILES")
macdef _SC_MEMLOCK = $extval (sysconfname, "_SC_MEMLOCK")
macdef _SC_MEMLOCK_RANGE = $extval (sysconfname, "_SC_MEMLOCK_RANGE")
macdef _SC_MEMORY_PROTECTION = $extval (sysconfname, "_SC_MEMORY_PROTECTION")
macdef _SC_MESSAGE_PASSING = $extval (sysconfname, "_SC_MESSAGE_PASSING")
macdef _SC_SEMAPHORES = $extval (sysconfname, "_SC_SEMAPHORES")
macdef _SC_SHARED_MEMORY_OBJECTS = $extval (sysconfname, "_SC_SHARED_MEMORY_OBJECTS")
macdef _SC_AIO_LISTIO_MAX = $extval (sysconfname, "_SC_AIO_LISTIO_MAX")
macdef _SC_AIO_MAX = $extval (sysconfname, "_SC_AIO_MAX")
macdef _SC_AIO_PRIO_DELTA_MAX = $extval (sysconfname, "_SC_AIO_PRIO_DELTA_MAX")
macdef _SC_DELAYTIMER_MAX = $extval (sysconfname, "_SC_DELAYTIMER_MAX")
macdef _SC_MQ_OPEN_MAX = $extval (sysconfname, "_SC_MQ_OPEN_MAX")
macdef _SC_MQ_PRIO_MAX = $extval (sysconfname, "_SC_MQ_PRIO_MAX")
macdef _SC_VERSION = $extval (sysconfname, "_SC_VERSION")
macdef _SC_PAGESIZE = $extval (sysconfname, "_SC_PAGESIZE")
macdef _SC_PAGE_SIZE = $extval (sysconfname, "_SC_PAGE_SIZE")
macdef _SC_RTSIG_MAX = $extval (sysconfname, "_SC_RTSIG_MAX")
macdef _SC_SEM_NSEMS_MAX = $extval (sysconfname, "_SC_SEM_NSEMS_MAX")
macdef _SC_SEM_VALUE_MAX = $extval (sysconfname, "_SC_SEM_VALUE_MAX")
macdef _SC_SIGQUEUE_MAX = $extval (sysconfname, "_SC_SIGQUEUE_MAX")
macdef _SC_TIMER_MAX = $extval (sysconfname, "_SC_TIMER_MAX")
//
macdef _SC_BC_BASE_MAX = $extval (sysconfname, "_SC_BC_BASE_MAX")
macdef _SC_BC_DIM_MAX = $extval (sysconfname, "_SC_BC_DIM_MAX")
macdef _SC_BC_SCALE_MAX = $extval (sysconfname, "_SC_BC_SCALE_MAX")
macdef _SC_BC_STRING_MAX = $extval (sysconfname, "_SC_BC_STRING_MAX")
macdef _SC_COLL_WEIGHTS_MAX = $extval (sysconfname, "_SC_COLL_WEIGHTS_MAX")
macdef _SC_EQUIV_CLASS_MAX = $extval (sysconfname, "_SC_EQUIV_CLASS_MAX")
macdef _SC_EXPR_NEST_MAX = $extval (sysconfname, "_SC_EXPR_NEST_MAX")
macdef _SC_LINE_MAX = $extval (sysconfname, "_SC_LINE_MAX")
macdef _SC_RE_DUP_MAX = $extval (sysconfname, "_SC_RE_DUP_MAX")
macdef _SC_CHARCLASS_NAME_MAX = $extval (sysconfname, "_SC_CHARCLASS_NAME_MAX")
//
macdef _SC_2_VERSION = $extval (sysconfname, "_SC_2_VERSION")
macdef _SC_2_C_BIND = $extval (sysconfname, "_SC_2_C_BIND")
macdef _SC_2_C_DEV = $extval (sysconfname, "_SC_2_C_DEV")
macdef _SC_2_FORT_DEV = $extval (sysconfname, "_SC_2_FORT_DEV")
macdef _SC_2_FORT_RUN = $extval (sysconfname, "_SC_2_FORT_RUN")
macdef _SC_2_SW_DEV = $extval (sysconfname, "_SC_2_SW_DEV")
macdef _SC_2_LOCALEDEF = $extval (sysconfname, "_SC_2_LOCALEDEF")
//
macdef _SC_PII = $extval (sysconfname, "_SC_PII")
macdef _SC_PII_XTI = $extval (sysconfname, "_SC_PII_XTI")
macdef _SC_PII_SOCKET = $extval (sysconfname, "_SC_PII_SOCKET")
macdef _SC_PII_INTERNET = $extval (sysconfname, "_SC_PII_INTERNET")
macdef _SC_PII_OSI = $extval (sysconfname, "_SC_PII_OSI")
macdef _SC_POLL = $extval (sysconfname, "_SC_POLL")
macdef _SC_SELECT = $extval (sysconfname, "_SC_SELECT")
macdef _SC_UIO_MAXIOV = $extval (sysconfname, "_SC_UIO_MAXIOV")
macdef _SC_IOV_MAX = _SC_UIO_MAXIOV = $extval (sysconfname, "_SC_IOV_MAX = _SC_UIO_MAXIOV")
macdef _SC_PII_INTERNET_STREAM = $extval (sysconfname, "_SC_PII_INTERNET_STREAM")
macdef _SC_PII_INTERNET_DGRAM = $extval (sysconfname, "_SC_PII_INTERNET_DGRAM")
macdef _SC_PII_OSI_COTS = $extval (sysconfname, "_SC_PII_OSI_COTS")
macdef _SC_PII_OSI_CLTS = $extval (sysconfname, "_SC_PII_OSI_CLTS")
macdef _SC_PII_OSI_M = $extval (sysconfname, "_SC_PII_OSI_M")
macdef _SC_T_IOV_MAX = $extval (sysconfname, "_SC_T_IOV_MAX")
//
macdef _SC_THREADS = $extval (sysconfname, "_SC_THREADS")
macdef _SC_THREAD_SAFE_FUNCTIONS =
  $extval (sysconfname, "_SC_THREAD_SAFE_FUNCTIONS")
macdef _SC_GETGR_R_SIZE_MAX = $extval (sysconfname, "_SC_GETGR_R_SIZE_MAX")
macdef _SC_GETPW_R_SIZE_MAX = $extval (sysconfname, "_SC_GETPW_R_SIZE_MAX")
macdef _SC_LOGIN_NAME_MAX = $extval (sysconfname, "_SC_LOGIN_NAME_MAX")
macdef _SC_TTY_NAME_MAX = $extval (sysconfname, "_SC_TTY_NAME_MAX")
macdef _SC_THREAD_DESTRUCTOR_ITERATIONS =
  $extval (sysconfname, "_SC_THREAD_DESTRUCTOR_ITERATIONS")
macdef _SC_THREAD_KEYS_MAX = $extval (sysconfname, "_SC_THREAD_KEYS_MAX")
macdef _SC_THREAD_STACK_MIN = $extval (sysconfname, "_SC_THREAD_STACK_MIN")
macdef _SC_THREAD_THREADS_MAX = $extval (sysconfname, "_SC_THREAD_THREADS_MAX")
macdef _SC_THREAD_ATTR_STACKADDR = $extval (sysconfname, "_SC_THREAD_ATTR_STACKADDR")
macdef _SC_THREAD_ATTR_STACKSIZE = $extval (sysconfname, "_SC_THREAD_ATTR_STACKSIZE")
macdef _SC_THREAD_PRIORITY_SCHEDULING =
  $extval (sysconfname, "_SC_THREAD_PRIORITY_SCHEDULING")
macdef _SC_THREAD_PRIO_INHERIT = $extval (sysconfname, "_SC_THREAD_PRIO_INHERIT")
macdef _SC_THREAD_PRIO_PROTECT = $extval (sysconfname, "_SC_THREAD_PRIO_PROTECT")
macdef _SC_THREAD_PROCESS_SHARED = $extval (sysconfname, "_SC_THREAD_PROCESS_SHARED")
//
macdef _SC_NPROCESSORS_CONF = $extval (sysconfname, "_SC_NPROCESSORS_CONF")
macdef _SC_NPROCESSORS_ONLN = $extval (sysconfname, "_SC_NPROCESSORS_ONLN")
macdef _SC_PHYS_PAGES = $extval (sysconfname, "_SC_PHYS_PAGES")
macdef _SC_AVPHYS_PAGES = $extval (sysconfname, "_SC_AVPHYS_PAGES")
macdef _SC_ATEXIT_MAX = $extval (sysconfname, "_SC_ATEXIT_MAX")
macdef _SC_PASS_MAX = $extval (sysconfname, "_SC_PASS_MAX")
//
macdef _SC_XOPEN_VERSION = $extval (sysconfname, "_SC_XOPEN_VERSION")
macdef _SC_XOPEN_XCU_VERSION = $extval (sysconfname, "_SC_XOPEN_XCU_VERSION")
macdef _SC_XOPEN_UNIX = $extval (sysconfname, "_SC_XOPEN_UNIX")
macdef _SC_XOPEN_CRYPT = $extval (sysconfname, "_SC_XOPEN_CRYPT")
macdef _SC_XOPEN_ENH_I18N = $extval (sysconfname, "_SC_XOPEN_ENH_I18N")
macdef _SC_XOPEN_SHM = $extval (sysconfname, "_SC_XOPEN_SHM")
//
macdef _SC_2_CHAR_TERM = $extval (sysconfname, "_SC_2_CHAR_TERM")
macdef _SC_2_C_VERSION = $extval (sysconfname, "_SC_2_C_VERSION")
macdef _SC_2_UPE = $extval (sysconfname, "_SC_2_UPE")
//
macdef _SC_XOPEN_XPG2 = $extval (sysconfname, "_SC_XOPEN_XPG2")
macdef _SC_XOPEN_XPG3 = $extval (sysconfname, "_SC_XOPEN_XPG3")
macdef _SC_XOPEN_XPG4 = $extval (sysconfname, "_SC_XOPEN_XPG4")
//
macdef _SC_CHAR_BIT = $extval (sysconfname, "_SC_CHAR_BIT")
macdef _SC_CHAR_MAX = $extval (sysconfname, "_SC_CHAR_MAX")
macdef _SC_CHAR_MIN = $extval (sysconfname, "_SC_CHAR_MIN")
macdef _SC_INT_MAX = $extval (sysconfname, "_SC_INT_MAX")
macdef _SC_INT_MIN = $extval (sysconfname, "_SC_INT_MIN")
macdef _SC_LONG_BIT = $extval (sysconfname, "_SC_LONG_BIT")
macdef _SC_WORD_BIT = $extval (sysconfname, "_SC_WORD_BIT")
macdef _SC_MB_LEN_MAX = $extval (sysconfname, "_SC_MB_LEN_MAX")
macdef _SC_NZERO = $extval (sysconfname, "_SC_NZERO")
macdef _SC_SSIZE_MAX = $extval (sysconfname, "_SC_SSIZE_MAX")
macdef _SC_SCHAR_MAX = $extval (sysconfname, "_SC_SCHAR_MAX")
macdef _SC_SCHAR_MIN = $extval (sysconfname, "_SC_SCHAR_MIN")
macdef _SC_SHRT_MAX = $extval (sysconfname, "_SC_SHRT_MAX")
macdef _SC_SHRT_MIN = $extval (sysconfname, "_SC_SHRT_MIN")
macdef _SC_UCHAR_MAX = $extval (sysconfname, "_SC_UCHAR_MAX")
macdef _SC_UINT_MAX = $extval (sysconfname, "_SC_UINT_MAX")
macdef _SC_ULONG_MAX = $extval (sysconfname, "_SC_ULONG_MAX")
macdef _SC_USHRT_MAX = $extval (sysconfname, "_SC_USHRT_MAX")
//
macdef _SC_NL_ARGMAX = $extval (sysconfname, "_SC_NL_ARGMAX")
macdef _SC_NL_LANGMAX = $extval (sysconfname, "_SC_NL_LANGMAX")
macdef _SC_NL_MSGMAX = $extval (sysconfname, "_SC_NL_MSGMAX")
macdef _SC_NL_NMAX = $extval (sysconfname, "_SC_NL_NMAX")
macdef _SC_NL_SETMAX = $extval (sysconfname, "_SC_NL_SETMAX")
macdef _SC_NL_TEXTMAX = $extval (sysconfname, "_SC_NL_TEXTMAX")
//
macdef _SC_XBS5_ILP32_OFF32 = $extval (sysconfname, "_SC_XBS5_ILP32_OFF32")
macdef _SC_XBS5_ILP32_OFFBIG = $extval (sysconfname, "_SC_XBS5_ILP32_OFFBIG")
macdef _SC_XBS5_LP64_OFF64 = $extval (sysconfname, "_SC_XBS5_LP64_OFF64")
macdef _SC_XBS5_LPBIG_OFFBIG = $extval (sysconfname, "_SC_XBS5_LPBIG_OFFBIG")
//
macdef _SC_XOPEN_LEGACY = $extval (sysconfname, "_SC_XOPEN_LEGACY")
macdef _SC_XOPEN_REALTIME = $extval (sysconfname, "_SC_XOPEN_REALTIME")
macdef _SC_XOPEN_REALTIME_THREADS = $extval (sysconfname, "_SC_XOPEN_REALTIME_THREADS")
//
macdef _SC_ADVISORY_INFO =
  $extval (sysconfname, "_SC_ADVISORY_INFO")
macdef _SC_BARRIERS = $extval (sysconfname, "_SC_BARRIERS")
macdef _SC_BASE = $extval (sysconfname, "_SC_BASE")
macdef _SC_C_LANG_SUPPORT =
  $extval (sysconfname, "_SC_C_LANG_SUPPORT")
macdef _SC_C_LANG_SUPPORT_R =
  $extval (sysconfname, "_SC_C_LANG_SUPPORT_R")
macdef _SC_CLOCK_SELECTION = $extval (sysconfname, "_SC_CLOCK_SELECTION")
macdef _SC_CPUTIME = $extval (sysconfname, "_SC_CPUTIME")
macdef _SC_THREAD_CPUTIME = $extval (sysconfname, "_SC_THREAD_CPUTIME")
macdef _SC_DEVICE_IO = $extval (sysconfname, "_SC_DEVICE_IO")
macdef _SC_DEVICE_SPECIFIC = $extval (sysconfname, "_SC_DEVICE_SPECIFIC")
macdef _SC_DEVICE_SPECIFIC_R = $extval (sysconfname, "_SC_DEVICE_SPECIFIC_R")
macdef _SC_FD_MGMT = $extval (sysconfname, "_SC_FD_MGMT")
macdef _SC_FIFO = $extval (sysconfname, "_SC_FIFO")
macdef _SC_PIPE = $extval (sysconfname, "_SC_PIPE")
macdef _SC_FILE_ATTRIBUTES = $extval (sysconfname, "_SC_FILE_ATTRIBUTES")
macdef _SC_FILE_LOCKING = $extval (sysconfname, "_SC_FILE_LOCKING")
macdef _SC_FILE_SYSTEM = $extval (sysconfname, "_SC_FILE_SYSTEM")
macdef _SC_MONOTONIC_CLOCK = $extval (sysconfname, "_SC_MONOTONIC_CLOCK")
macdef _SC_MULTI_PROCESS = $extval (sysconfname, "_SC_MULTI_PROCESS")
macdef _SC_SINGLE_PROCESS = $extval (sysconfname, "_SC_SINGLE_PROCESS")
macdef _SC_NETWORKING = $extval (sysconfname, "_SC_NETWORKING")
macdef _SC_READER_WRITER_LOCKS =
  $extval (sysconfname, "_SC_READER_WRITER_LOCKS")
macdef _SC_SPIN_LOCKS = $extval (sysconfname, "_SC_SPIN_LOCKS")
macdef _SC_REGEXP = $extval (sysconfname, "_SC_REGEXP")
macdef _SC_REGEX_VERSION = $extval (sysconfname, "_SC_REGEX_VERSION")
macdef _SC_SHELL = $extval (sysconfname, "_SC_SHELL")
macdef _SC_SIGNALS = $extval (sysconfname, "_SC_SIGNALS")
macdef _SC_SPAWN = $extval (sysconfname, "_SC_SPAWN")
macdef _SC_SPORADIC_SERVER = $extval (sysconfname, "_SC_SPORADIC_SERVER")
macdef _SC_THREAD_SPORADIC_SERVER =
  $extval (sysconfname, "_SC_THREAD_SPORADIC_SERVER")
macdef _SC_SYSTEM_DATABASE =
  $extval (sysconfname, "_SC_SYSTEM_DATABASE")
macdef _SC_SYSTEM_DATABASE_R =
  $extval (sysconfname, "_SC_SYSTEM_DATABASE_R")
macdef _SC_TIMEOUTS = $extval (sysconfname, "_SC_TIMEOUTS")
macdef _SC_TYPED_MEMORY_OBJECTS =
  $extval (sysconfname, "_SC_TYPED_MEMORY_OBJECTS")
macdef _SC_USER_GROUPS = $extval (sysconfname, "_SC_USER_GROUPS")
macdef _SC_USER_GROUPS_R = $extval (sysconfname, "_SC_USER_GROUPS_R")
macdef _SC_2_PBS = $extval (sysconfname, "_SC_2_PBS")
macdef _SC_2_PBS_ACCOUNTING = $extval (sysconfname, "_SC_2_PBS_ACCOUNTING")
macdef _SC_2_PBS_LOCATE = $extval (sysconfname, "_SC_2_PBS_LOCATE")
macdef _SC_2_PBS_MESSAGE = $extval (sysconfname, "_SC_2_PBS_MESSAGE")
macdef _SC_2_PBS_TRACK = $extval (sysconfname, "_SC_2_PBS_TRACK")
macdef _SC_SYMLOOP_MAX = $extval (sysconfname, "_SC_SYMLOOP_MAX")
macdef _SC_STREAMS = $extval (sysconfname, "_SC_STREAMS")
macdef _SC_2_PBS_CHECKPOINT = $extval (sysconfname, "_SC_2_PBS_CHECKPOINT")
//
macdef _SC_V6_ILP32_OFF32 = $extval (sysconfname, "_SC_V6_ILP32_OFF32")
macdef _SC_V6_ILP32_OFFBIG = $extval (sysconfname, "_SC_V6_ILP32_OFFBIG")
macdef _SC_V6_LP64_OFF64 = $extval (sysconfname, "_SC_V6_LP64_OFF64")
macdef _SC_V6_LPBIG_OFFBIG = $extval (sysconfname, "_SC_V6_LPBIG_OFFBIG")
//
macdef _SC_HOST_NAME_MAX =
  $extval (sysconfname, "_SC_HOST_NAME_MAX")
macdef _SC_TRACE = $extval (sysconfname, "_SC_TRACE")
macdef _SC_TRACE_EVENT_FILTER =
  $extval (sysconfname, "_SC_TRACE_EVENT_FILTER")
macdef _SC_TRACE_INHERIT =
  $extval (sysconfname, "_SC_TRACE_INHERIT")
macdef _SC_TRACE_LOG = $extval (sysconfname, "_SC_TRACE_LOG")
//
macdef _SC_LEVEL1_ICACHE_SIZE =
  $extval (sysconfname, "_SC_LEVEL1_ICACHE_SIZE")
macdef _SC_LEVEL1_ICACHE_ASSOC =
  $extval (sysconfname, "_SC_LEVEL1_ICACHE_ASSOC")
macdef _SC_LEVEL1_ICACHE_LINESIZE =
  $extval (sysconfname, "_SC_LEVEL1_ICACHE_LINESIZE")
macdef _SC_LEVEL1_DCACHE_SIZE =
  $extval (sysconfname, "_SC_LEVEL1_DCACHE_SIZE")
macdef _SC_LEVEL1_DCACHE_ASSOC =
  $extval (sysconfname, "_SC_LEVEL1_DCACHE_ASSOC")
macdef _SC_LEVEL1_DCACHE_LINESIZE =
  $extval (sysconfname, "_SC_LEVEL1_DCACHE_LINESIZE")
macdef _SC_LEVEL2_CACHE_SIZE =
  $extval (sysconfname, "_SC_LEVEL2_CACHE_SIZE")
macdef _SC_LEVEL2_CACHE_ASSOC =
  $extval (sysconfname, "_SC_LEVEL2_CACHE_ASSOC")
macdef _SC_LEVEL2_CACHE_LINESIZE =
  $extval (sysconfname, "_SC_LEVEL2_CACHE_LINESIZE")
macdef _SC_LEVEL3_CACHE_SIZE =
  $extval (sysconfname, "_SC_LEVEL3_CACHE_SIZE")
macdef _SC_LEVEL3_CACHE_ASSOC =
  $extval (sysconfname, "_SC_LEVEL3_CACHE_ASSOC")
macdef _SC_LEVEL3_CACHE_LINESIZE =
  $extval (sysconfname, "_SC_LEVEL3_CACHE_LINESIZE")
macdef _SC_LEVEL4_CACHE_SIZE =
  $extval (sysconfname, "_SC_LEVEL4_CACHE_SIZE")
macdef _SC_LEVEL4_CACHE_ASSOC =
  $extval (sysconfname, "_SC_LEVEL4_CACHE_ASSOC")
macdef _SC_LEVEL4_CACHE_LINESIZE =
  $extval (sysconfname, "_SC_LEVEL4_CACHE_LINESIZE")
//
macdef _SC_IPV6 = $extval (sysconfname, "_SC_IPV6")
macdef _SC_RAW_SOCKETS = $extval (sysconfname, "_SC_RAW_SOCKETS")
//
macdef _SC_V7_ILP32_OFF32 = $extval (sysconfname, "_SC_V7_ILP32_OFF32")
macdef _SC_V7_ILP32_OFFBIG = $extval (sysconfname, "_SC_V7_ILP32_OFFBIG")
macdef _SC_V7_LP64_OFF64 = $extval (sysconfname, "_SC_V7_LP64_OFF64")
macdef _SC_V7_LPBIG_OFFBIG = $extval (sysconfname, "_SC_V7_LPBIG_OFFBIG")
//
macdef _SC_SS_REPL_MAX = $extval (sysconfname, "_SC_SS_REPL_MAX")
//
macdef _SC_TRACE_EVENT_NAME_MAX =
  $extval (sysconfname, "_SC_TRACE_EVENT_NAME_MAX")
macdef _SC_TRACE_NAME_MAX =
  $extval (sysconfname, "_SC_TRACE_NAME_MAX")
macdef _SC_TRACE_SYS_MAX =
  $extval (sysconfname, "_SC_TRACE_SYS_MAX")
macdef _SC_TRACE_USER_EVENT_MAX =
  $extval (sysconfname, "_SC_TRACE_USER_EVENT_MAX")
//
macdef _SC_XOPEN_STREAMS =
  $extval (sysconfname, "_SC_XOPEN_STREAMS")
//
macdef _SC_THREAD_ROBUST_PRIO_INHERIT =
  $extval (sysconfname, "_SC_THREAD_ROBUST_PRIO_INHERIT")
macdef _SC_THREAD_ROBUST_PRIO_PROTEC =
  $extval (sysconfname, "_SC_THREAD_ROBUST_PRIO_PROTEC")

(* ****** ****** *)

(* end of [unistd_sysconf.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

%{#
#include "libc/CATS/unistd.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define SHR(x) x // SHARED // HX: for commenting
#define NSH(x) x // NSHARED // HX: for commenting

(* ****** ****** *)

typedef interr = int

(* ****** ****** *)
//
staload
TYPES =
"libc/sys/SATS/types.sats"
//
typedef off_t = $TYPES.off_t
//
typedef pid_t = $TYPES.pid_t
typedef uid_t = $TYPES.uid_t
typedef gid_t = $TYPES.gid_t
//
stadef fildes_v = $TYPES.fildes_v
//
vtypedef
fildes (i:int) = $TYPES.fildes (i)
//
vtypedef Fildes = $TYPES.Fildes
vtypedef Fildes0 = $TYPES.Fildes0
//
(* ****** ****** *)

macdef STDIN_FILENO = $extval(int, "STDIN_FILENO")
macdef STDOUT_FILENO = $extval(int, "STDOUT_FILENO")
macdef STDERR_FILENO = $extval(int, "STDERR_FILENO")

(* ****** ****** *)
/*
int close (int);
*/
symintr close
symintr close_exn
//
fun close0 (fd: int): interr = "mac#%"
//
// HX-2013-03-25: should this be moved to unistd.sats?
//
dataview
close_v (fd:int, int) =
  | close_v_succ (fd, 0) of ()
  | {i:int | i < 0} close_v_fail (fd, i) of fildes_v (fd)
//
fun close1{fd:nat}
  (fd: fildes (fd)): [i:int] (close_v (fd, i) | int i) = "mac#%"
//
overload close with close0
overload close with close1
//
fun close0_exn (fd: int): void = "ext#%"
fun close1_exn (fd: Fildes0):<!exn> void = "ext#%"
//
overload close_exn with close0_exn
overload close_exn with close1_exn
//
(* ****** ****** *)

fun dup (fildes: int): int = "mac#%"
fun dup_fildes (fd: !Fildes0): Fildes = "mac#%"

(* ****** ****** *)
//
fun dup2
  (fildes: int, fildes2: int): int = "mac#%"
//
// HX-2013-05:
// this one requires that [fd2] be not in use
//
fun dup2_fildes{fd2:nat}
  (fd: !Fildes0, fd2: int (fd2)): Fildes = "mac#%"
//
(* ****** ****** *)
//
// HX: this one requires -D_GNU_SOURCE
//
fun dup3
  (fildes: int, fildes2: int, flags: int): int = "mac#%"
//
(* ****** ****** *)

fun execv {n:pos}{l:addr}
(
  pf: !parray_v (string, l, n) | path: NSH(string), argv: ptr l
) : intLt(0) = "mac#atslib_execv"
fun execv_unsafe // HX: for failure, ~1 is returned
  (path: NSH(string), argv: ptr): intLt(0) = "mac#atslib_execv"

fun execvp {n:pos}{l:addr}
(
  pf: !parray_v (string, l, n) | fname: NSH(string), argv: ptr l
) : intLt(0) = "mac#atslib_execvp"
fun execvp_unsafe // HX: for failure, ~1 is returned
  (fname: NSH(string), argv: ptr): intLt(0) = "mac#atslib_execvp"

(* ****** ****** *)
/*
int execve(const char *filename, char *const argv[], char *const envp[]);
*/
fun execve
  {n1,n2:pos}{l1,l2:addr}
(
  pf1: !parray_v (string, l1, n1)
, pf2: !parray_v (string, l2, n2)
| fname: NSH(string), argv: ptr l1, envp: ptr l2
) : intLt(0) = "mac#atslib_execve"
fun execve_unsafe // HX: for failure, ~1 is returned
  (fname: NSH(string), argv: ptr, envp: ptr): intLt(0) = "mac#atslib_execve"
// end of [execve_unsafe]

(* ****** ****** *)

/*
void encrypt(char block[64], int edflag);
*/
fun encrypt
(
  block: &(@[char][64]), edflag: int
) :<!ref> void = "mac#%" // endfun

(* ****** ****** *)

fun fork ((*void*)): pid_t = "mac#%"

(* ****** ****** *)

dataview
getcwd_v
(
  m:int, l:addr, addr
) =
  | {l>null} {n:nat}
    getcwd_v_succ (m, l, l) of strbuf_v (l, m, n)
  | getcwd_v_fail (m, l, null) of b0ytes (m) @ (l)
// end of [getcwd_v]

fun getcwd
  {m:nat} {l:addr}
(
  pf: !b0ytes (m) @ l >> getcwd_v (m, l, l1) | p: ptr l, m: size_t m
) : #[l1:addr] ptr (l1) = "mac#%" // end of [getcwd]

fun getcwd_gc (): Strptr0 = "ext#%" // HX: this is a convenient function

(* ****** ****** *)
/*
pid_t getpid(void);
pid_t getppid(void);
*/
fun getpid ((*void*)): pid_t = "mac#%"
fun getppid ((*void*)): pid_t = "mac#%"
//
(* ****** ****** *)

fun getuid (): uid_t = "mac#%"
fun setuid (uid: uid_t): int = "mac#%"
fun geteuid (): uid_t = "mac#%"
fun seteuid (uid: uid_t): int = "mac#%"

(* ****** ****** *)

fun getgid (): gid_t = "mac#%"
fun setgid (gid: gid_t): int = "mac#%"
fun getegid (): gid_t = "mac#%"
fun setegid (gid: gid_t): int = "mac#%"
        
(* ****** ****** *)

fun setreuid (ruid: uid_t, euid: uid_t): int = "mac#%"
fun setregid (rgid: gid_t, egid: gid_t): int = "mac#%"

(* ****** ****** *)

fun setresuid (ruid: uid_t, euid: uid_t, suid: uid_t): int = "mac#%"
fun setresgid (rgid: gid_t, egid: gid_t, sgid: gid_t): int = "mac#%"
          
(* ****** ****** *)
//
// HX: these are linux-specific!
//
fun setfsuid(fsuid: uid_t): int = "mac#%"
fun setfsgid(fsgid: gid_t): int = "mac#%"
//
(* ****** ****** *)

fun getlogin (): vStrptr0 = "mac#%"
fun getlogin_r{n:int | n >= 2}
  (buf: &bytes(n), n: size_t n): int = "mac#%"
fun getlogin_r_gc (): Strptr0 = "ext#%"

(* ****** ****** *)
//
// HX: [pause] can only returns -1
//
fun pause ((*void*)): int = "mac#%"
//
(* ****** ****** *)

fun read_err
  {sz,n:nat | n <= sz}
(
  fd: !Fildes0
, buf: &b0ytes(sz) >> bytes(sz), ntotal: size_t(n)
) : ssizeBtw(~1, n+1) = "mac#%" // end-of-fun

fun write_err
  {sz,n:nat | n <= sz}
(
  fd: !Fildes0, buf: &RD(bytes(sz)), ntotal: size_t(n)
) : ssizeBtw(~1, n+1) = "mac#%" // end-of-fun

(* ****** ****** *)

fun pread{n:int}
(
  fd: !Fildes0, buf: &(@[byte][n])>>_, n: size_t (n), ofs: off_t
) : ssize_t = "mac#%" // end of [pread]

fun pwrite{n:int}
(
  fd: !Fildes0, buf: &RD(array(byte, n)), n: size_t (n), ofs: off_t
) : ssize_t = "mac#%" // end of [pwrite]

(* ****** ****** *)
//
absview
alarm_v (n: int) // n: remaining seconds
//
praxi alarm_v_elim (pf: alarm_v (0)): void
//
fun
alarm_set{i:int}
  (t: uint i): (alarm_v (i) | uInt) = "mac#%"
// end of [alarm_set]
fun
alarm_cancel{i:int}
  (pf: alarm_v (i) | (*none*)): uInt = "mac#%"
// end of [alarm_cancel]
//
(* ****** ****** *)
//
// HX: [sleep] may be implemented using SIGARM
//
symintr sleep
//
fun sleep_int
  {i:nat} (t: int i): [j:nat | j <= i] int j = "mac#%"
fun sleep_uint
  {i:int} (t: uint i): [j:nat | j <= i] uint j = "mac#%"
//
overload sleep with sleep_int
overload sleep with sleep_uint
//
(* ****** ****** *)
//
// HX: some systems require that the argument <= 1 million
//
symintr usleep
//
fun usleep_int // succ/fail: 0/~1
  {i:nat | i <= 1000000} (n: int i): intLte(0) = "mac#%"
fun usleep_uint // succ/fail: 0/~1
  {i:int | i <= 1000000} (n: uint i): intLte(0) = "mac#%"
//
overload usleep with usleep_int
overload usleep with usleep_uint
//
(* ****** ****** *)

/*
int rmdir(const char *pathname);
*/
fun rmdir (path: NSH(string)): int = "mac#%"
fun rmdir_exn (path: NSH(string)): void = "ext#%"

(* ****** ****** *)
/*
int link(const char *old, const char *new)
*/
fun link
(
  old: NSH(string)
, new: NSH(string)
) :<!ref> intLte(0) = "mac#%"
fun link_exn
  (old: NSH(string), new: NSH(string)):<!ref> void = "ext#%"
//
(* ****** ****** *)
/*
int symlink(const char *old, const char *new)
*/
fun symlink
(
  old: NSH(string)
, new: NSH(string)
) :<!ref> intLte(0) = "mac#%"
fun symlink_exn
  (old: NSH(string), new: NSH(string)):<!ref> void = "ext#%"
//
(* ****** ****** *)
/*
int unlink(const char *pathname);
*/
fun unlink (path: NSH(string)):<!ref> intLte(0) = "mac#%"
fun unlink_exn (path: NSH(string)):<!exnref> void = "ext#%"

(* ****** ****** *)

fun readlink{n:int}
(
  path: NSH(string), buf: &(@[byte][n]) >> _, n: size_t (n)
) : ssizeLte(n) = "mac#%" // end of [readlink]

fun readlink_gc (path: NSH(string)): Strptr0 = "ext#%"

(* ****** ****** *)

fun sync ((*void*)): void = "mac#%"
fun fsync (fd: !Fildes0): int = "mac#%"
fun fdatasync (fd: !Fildes0): int = "mac#%"

(* ****** ****** *)
//
fun truncate
  (path: NSH(string), ofs: off_t): int = "mac#%"
//
fun ftruncate (fd: !Fildes0, ofs: off_t): int = "mac#%"
//
(* ****** ****** *)

#include "./unistd_sysconf.sats"
#include "./unistd_pathconf.sats"

(* ****** ****** *)

(* end of [unistd.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

typedef pathconfname = int

(* ****** ****** *)
//
fun pathconf
  (path: NSH(string), name: pathconfname): lint = "mac#%"
//
fun fpathconf (fd: int, name: pathconfname): lint = "mac#%"
//
(* ****** ****** *)

macdef _PC_LINK_MAX = $extval (pathconfname, "_PC_LINK_MAX")
macdef _PC_MAX_CANON = $extval (pathconfname, "_PC_MAX_CANON")
macdef _PC_MAX_INPUT = $extval (pathconfname, "_PC_MAX_INPUT")
macdef _PC_NAME_MAX = $extval (pathconfname, "_PC_NAME_MAX")
macdef _PC_PATH_MAX = $extval (pathconfname, "_PC_PATH_MAX")
macdef _PC_PIPE_BUF = $extval (pathconfname, "_PC_PIPE_BUF")
macdef _PC_CHOWN_RESTRICTED = $extval (pathconfname, "_PC_CHOWN_RESTRICTED")
macdef _PC_NO_TRUNC = $extval (pathconfname, "_PC_NO_TRUNC")
macdef _PC_VDISABLE = $extval (pathconfname, "_PC_VDISABLE")
macdef _PC_SYNC_IO = $extval (pathconfname, "_PC_SYNC_IO")
macdef _PC_ASYNC_IO = $extval (pathconfname, "_PC_ASYNC_IO")
macdef _PC_PRIO_IO = $extval (pathconfname, "_PC_PRIO_IO")
macdef _PC_SOCK_MAXBUF = $extval (pathconfname, "_PC_SOCK_MAXBUF")
macdef _PC_FILESIZEBITS = $extval (pathconfname, "_PC_FILESIZEBITS")
macdef _PC_REC_INCR_XFER_SIZE = $extval (pathconfname, "_PC_REC_INCR_XFER_SIZE")
macdef _PC_REC_MAX_XFER_SIZE = $extval (pathconfname, "_PC_REC_MAX_XFER_SIZE")
macdef _PC_REC_MIN_XFER_SIZE = $extval (pathconfname, "_PC_REC_MIN_XFER_SIZE")
macdef _PC_REC_XFER_ALIGN = $extval (pathconfname, "_PC_REC_XFER_ALIGN")
macdef _PC_ALLOC_SIZE_MIN = $extval (pathconfname, "_PC_ALLOC_SIZE_MIN")
macdef _PC_SYMLINK_MAX = $extval (pathconfname, "_PC_SYMLINK_MAX")
macdef _PC_2_SYMLINK = $extval (pathconfname, "_PC_2_SYMLINK")

(* ****** ****** *)

(* end of [unistd_pathconf.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: April, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/math.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

macdef M_E = 2.7182818284590452354	// e
macdef M_PI = 3.14159265358979323846	// pi
macdef M_PI_2 = 1.57079632679489661923	// pi/2
macdef M_PI_4 = 0.78539816339744830962	// pi/4

(* ****** ****** *)

macdef INFINITY = $extval (float, "INFINITY")

(* ****** ****** *)
//
// _XOPEN_SOURCE >= 600 || ...
//
fun{a:t0p} isfinite (x: INV(a)):<> int
fun isfinite_float (x: float):<> int = "mac#%"
fun isfinite_double (x: double):<> int = "mac#%"
fun isfinite_ldouble (x: ldouble):<> int = "mac#%"
//
fun{a:t0p} isnormal (x: INV(a)):<> int
fun isnormal_float (x: float):<> int = "mac#%"
fun isnormal_double (x: double):<> int = "mac#%"
fun isnormal_ldouble (x: ldouble):<> int = "mac#%"
//
fun{a:t0p} fpclassify (x: INV(a)):<> int
fun fpclassify_float (x: float):<> int = "mac#%"
fun fpclassify_double (x: double):<> int = "mac#%"
fun fpclassify_ldouble (x: ldouble):<> int = "mac#%"

(* ****** ****** *)
//
// _BSD_SOURCE || _XOPEN_SOURCE || ...
//
fun{a:t0p} isnan (x: INV(a)):<> int
fun isnan_float (x: float):<> int = "mac#%"
fun isnan_double (x: double):<> int = "mac#%"
fun isnan_ldouble (x: ldouble):<> int = "mac#%"
//
(* ****** ****** *)
//
// _BSD_SOURCE || _XOPEN_SOURCE >= 600 || ...
//
fun{a:t0p} isinf (x: INV(a)):<> int
fun isinf_float (x: float):<> int = "mac#%"
fun isinf_double (x: double):<> int = "mac#%"
fun isinf_ldouble (x: ldouble):<> int = "mac#%"
//
(* ****** ****** *)
//
fun{a:t0p} ceil (x: INV(a)):<> a
//
fun ceil_float (x: float):<> float = "mac#%"
fun ceil_double (x: double):<> double = "mac#%"
fun ceil_ldouble (x: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)
//
fun{a:t0p} floor (x: INV(a)):<> a
//
fun floor_float (x: float):<> float = "mac#%"
fun floor_double (x: double):<> double = "mac#%"
fun floor_ldouble (x: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)
//
fun{a:t0p} round (x: INV(a)):<> a
//
fun round_float (x: float):<> float = "mac#%"
fun round_double (x: double):<> double = "mac#%"
fun round_ldouble (x: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)
//
fun{a:t0p} trunc (x: INV(a)):<> a
//
fun trunc_float (x: float):<> float = "mac#%"
fun trunc_double (x: double):<> double = "mac#%"
fun trunc_ldouble (x: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)

fun{
a:t0p
} fmod (x1: INV(a), x2: a):<> a
fun fmod_float (x1: float, x2: float):<> float = "mac#%"
fun fmod_double (x1: double, x2: double):<> double = "mac#%"
fun fmod_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)
//
fun{
a:t0p
} fmax (x1: INV(a), x2: a):<> a
fun fmax_float (x1: float, x2: float):<> float = "mac#%"
fun fmax_double (x1: double, x2: double):<> double = "mac#%"
fun fmax_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"
//
fun{
a:t0p
} fmin (x1: INV(a), x2: a):<> a
fun fmin_float (x1: float, x2: float):<> float = "mac#%"
fun fmin_double (x1: double, x2: double):<> double = "mac#%"
fun fmin_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)

fun{
a:t0p
} fdim (x1: INV(a), x2: a):<> a
fun fdim_float (x1: float, x2: float):<> float = "mac#%"
fun fdim_double (x1: double, x2: double):<> double = "mac#%"
fun fdim_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)
//
// HX: fma (x, y, z) = x * y + z
//
fun{a:t0p} fma (x1: INV(a), x2: a, x3: a):<> a
fun fma_float (x1: float, x2: float, x3: float):<> float = "mac#%"
fun fma_double (x1: double, x2: double, x3: double):<> double = "mac#%"
fun fma_ldouble (x1: ldouble, x2: ldouble, x3: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)

fun{a:t0p} sqrt (x: INV(a)):<> a
fun sqrt_float (f: float):<> float = "mac#%"
fun sqrt_double (d: double):<> double = "mac#%"
fun sqrt_ldouble (ld: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} cbrt (x: INV(a)):<> a
fun cbrt_float (f: float):<> float = "mac#%"
fun cbrt_double (d: double):<> double = "mac#%"
fun cbrt_ldouble (ld: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} pow (x1: INV(a), x2: a):<> a
fun pow_float (x1: float, x2: float):<> float = "mac#%"
fun pow_double (x1: double, x2: double):<> double = "mac#%"
fun pow_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} exp (x: INV(a)):<> a
fun exp_float (f: float):<> float = "mac#%"
fun exp_double (d: double):<> double = "mac#%"
fun exp_ldouble (ld: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} log (x: INV(a)):<> a
fun log_float (f: float):<> float = "mac#%"
fun log_double (d: double):<> double = "mac#%"
fun log_ldouble (ld: ldouble):<> ldouble = "mac#%"

fun{a:t0p} log10 (x: INV(a)):<> a
fun log10_float (f: float):<> float = "mac#%"
fun log10_double (d: double):<> double = "mac#%"
fun log10_ldouble (ld: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} sin (x: INV(a)):<> a
fun sin_float (x: float):<> float = "mac#%"
fun sin_double (x: double):<> double = "mac#%"
fun sin_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} cos (x: INV(a)):<> a
fun cos_float (x: float):<> float = "mac#%"
fun cos_double (x: double):<> double = "mac#%"
fun cos_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} tan (x: INV(a)):<> a
fun tan_float (x: float):<> float = "mac#%"
fun tan_double (x: double):<> double = "mac#%"
fun tan_ldouble (x: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} asin (x: INV(a)):<> a
fun asin_float (x: float):<> float = "mac#%"
fun asin_double (x: double):<> double = "mac#%"
fun asin_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} acos (x: INV(a)):<> a
fun acos_float (x: float):<> float = "mac#%"
fun acos_double (x: double):<> double = "mac#%"
fun acos_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} atan (x: INV(a)):<> a
fun atan_float (x: float):<> float = "mac#%"
fun atan_double (x: double):<> double = "mac#%"
fun atan_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} atan2 (x1: INV(a), x2: a):<> a
fun atan2_float (x1: float, x2: float):<> float = "mac#%"
fun atan2_double (x1: double, x2: double):<> double = "mac#%"
fun atan2_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} sinh (x: INV(a)):<> a
fun sinh_float (x: float):<> float = "mac#%"
fun sinh_double (x: double):<> double = "mac#%"
fun sinh_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} cosh (x: INV(a)):<> a
fun cosh_float (x: float):<> float = "mac#%"
fun cosh_double (x: double):<> double = "mac#%"
fun cosh_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} tanh (x: INV(a)):<> a
fun tanh_float (x: float):<> float = "mac#%"
fun tanh_double (x: double):<> double = "mac#%"
fun tanh_ldouble (x: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} asinh (x: INV(a)):<> a
fun asinh_float (x: float):<> float = "mac#%"
fun asinh_double (x: double):<> double = "mac#%"
fun asinh_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} acosh (x: INV(a)):<> a
fun acosh_float (x: float):<> float = "mac#%"
fun acosh_double (x: double):<> double = "mac#%"
fun acosh_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} atanh (x: INV(a)):<> a
fun atanh_float (x: float):<> float = "mac#%"
fun atanh_double (x: double):<> double = "mac#%"
fun atanh_ldouble (x: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

(* end of [math.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/errno.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

typedef errno_t = int

(* ****** ****** *)
//
macdef ENONE = $extval (errno_t, "ENONE") // = 0
//
macdef E2BIG = $extval (errno_t, "E2BIG") // POSIX.1
macdef EACCES = $extval (errno_t, "EACCES") // POSIX.1
macdef EADDRINUSE = $extval (errno_t, "EADDRINUSE") // POSIX.1
macdef EADDRNOTAVAIL = $extval (errno_t, "EADDRNOTAVAIL") // POSIX.1
macdef EAGAIN = $extval (errno_t, "EAGAIN") // POSIX.1
macdef EALREADY = $extval (errno_t, "EALREADY") // POSIX.1
macdef EBADE = $extval (errno_t, "EBADE")
macdef EBADF = $extval (errno_t, "EBADF") // POSIX.1
macdef EBADFD = $extval (errno_t, "EBADFD")
macdef EBADMSG = $extval (errno_t, "EBADMSG") // POSIX.1
macdef EBADR = $extval (errno_t, "EBADR")
macdef EBUSY = $extval (errno_t, "EBUSY") // POSIX.1
macdef ECANCELED = $extval (errno_t, "ECANCELED") // POSIX.1
macdef ECHILD = $extval (errno_t, "ECHILD") // POSIX.1
macdef ECONNABORTED = $extval (errno_t, "ECONNABORTED") // POSIX.1
macdef ECONNREFUSED = $extval (errno_t, "ECONNREFUSED") // POSIX.1
macdef ECONNRESET = $extval (errno_t, "ECONNRESET") // POSIX.1
macdef EDEADLK = $extval (errno_t, "EDEADLK") // POSIX.1
macdef EDEADLOCK = $extval (errno_t, "EDEADLOCK") // POSIX.1
macdef EDESTADDRREQ = $extval (errno_t, "EDESTADDRREQ") // POSIX.1
macdef EDOM = $extval (errno_t, "EDOM") // POSIX.1 // C99
macdef EDQUOT = $extval (errno_t, "EDQUOT") // POSIX.1
macdef EEXIST = $extval (errno_t, "EEXIST") // POSIX.1
macdef EFAULT = $extval (errno_t, "EFAULT") // POSIX.1
macdef EFBIG = $extval (errno_t, "EFBIG") // POSIX.1
macdef EHOSTDOWN = $extval (errno_t, "EHOSTDOWN")
macdef EHOSTUNREACH = $extval (errno_t, "EHOSTUNREACH") // POSIX.1
macdef EIDRM = $extval (errno_t, "EIDRM") // POSIX.1
macdef EILSEQ = $extval (errno_t, "EILSEQ") // POSIX.1 // C99
macdef EINPROGRESS = $extval (errno_t, "EINPROGRESS") // POSIX.1
macdef EINTR = $extval (errno_t, "EINTR") // POSIX.1
macdef EINVAL = $extval (errno_t, "EINVAL") // POSIX.1
macdef EIO = $extval (errno_t, "EIO") // POSIX.1
macdef EISCONN = $extval (errno_t, "EISCONN") // POSIX.1
macdef EISDIR = $extval (errno_t, "EISDIR") // POSIX.1
macdef ELOOP = $extval (errno_t, "ELOOP") // POSIX.1
macdef EMFILE = $extval (errno_t, "EMFILE") // POSIX.1
macdef EMLINK = $extval (errno_t, "EMLINK") // POSIX.1
macdef EMSGSIZE = $extval (errno_t, "EMSGSIZE") // POSIX.1
macdef EMULTIHOP = $extval (errno_t, "EMULTIHOP") // POSIX.1
macdef ENAMETOOLONG = $extval (errno_t, "ENAMETOOLONG") // POSIX.1
macdef ENETDOWN = $extval (errno_t, "ENETDOWN") // POSIX.1
macdef ENETRESET = $extval (errno_t, "ENETRESET") // POSIX.1
macdef ENETUNREACH = $extval (errno_t, "ENETUNREACH") // POSIX.1
macdef ENFILE = $extval (errno_t, "ENFILE") // POSIX.1
macdef ENOBUFS = $extval (errno_t, "ENOBUFS") // POSIX.1
macdef ENODATA = $extval (errno_t, "ENODATA") // POSIX.1
macdef ENODEV = $extval (errno_t, "ENODEV") // POSIX.1
macdef ENOENT = $extval (errno_t, "ENOENT") // POSIX.1
macdef ENOEXEC = $extval (errno_t, "ENOEXEC") // POSIX.1
macdef ENOLCK = $extval (errno_t, "ENOLCK") // POSIX.1
macdef ENOLINK = $extval (errno_t, "ENOLINK") // POSIX.1
macdef ENOMEM = $extval (errno_t, "ENOMEM") // POSIX.1
macdef ENOMSG = $extval (errno_t, "ENOMSG") // POSIX.1
macdef ENOPROTOOPT = $extval (errno_t, "ENOPROTOOPT") // POSIX.1
macdef ENOSPC = $extval (errno_t, "ENOSPC") // POSIX.1
macdef ENOSR = $extval (errno_t, "ENOSR") // POSIX.1
macdef ENOSTR = $extval (errno_t, "ENOSTR") // POSIX.1
macdef ENOSYS = $extval (errno_t, "ENOSYS") // POSIX.1
macdef ENOTCONN = $extval (errno_t, "ENOTCONN") // POSIX.1
macdef ENOTDIR = $extval (errno_t, "ENOTDIR") // POSIX.1
macdef ENOTEMPTY = $extval (errno_t, "ENOTEMPTY") // POSIX.1
macdef ENOTSOCK = $extval (errno_t, "ENOTSOCK") // POSIX.1
macdef ENOTSUP = $extval (errno_t, "ENOTSUP") // POSIX.1
macdef ENOTTY = $extval (errno_t, "ENOTTY") // POSIX.1
macdef ENXIO = $extval (errno_t, "ENXIO") // POSIX.1
macdef EOPNOTSUPP = $extval (errno_t, "EOPNOTSUPP") // POSIX.1
macdef EOVERFLOW = $extval (errno_t, "EOVERFLOW") // POSIX.1
macdef EPERM = $extval (errno_t, "EPERM") // POSIX.1
macdef EPIPE = $extval (errno_t, "EPIPE") // POSIX.1
macdef EPFNOSUPPORT = $extval (errno_t, "EPFNOSUPPORT")
macdef EPROTO = $extval (errno_t, "EPROTO") // POSIX.1
macdef EPROTONOSUPPORT = $extval (errno_t, "EPROTONOSUPPORT") // POSIX.1
macdef EPROTOTYPE = $extval (errno_t, "EPROTOTYPE") // POSIX.1
macdef ERANGE = $extval (errno_t, "ERANGE") // C99 // POSIX.1
macdef EREMCHG = $extval (errno_t, "EREMCHG")
macdef EREMOTE = $extval (errno_t, "EREMOTE")
macdef EREMOTEIO = $extval (errno_t, "EREMOTEIO")
macdef ERESTART = $extval (errno_t, "ERESTART")
macdef EROFS = $extval (errno_t, "EROFS") // POSIX.1
macdef ESHUTDOWN = $extval (errno_t, "ESHUTDOWN")
macdef ESPIPE = $extval (errno_t, "ESPIPE") // POSIX.1
macdef ESOCKTNOSUPPORT = $extval (errno_t, "ESOCKTNOSUPPORT")
macdef ESRCH = $extval (errno_t, "ESRCH") // POSIX.1
macdef ESTALE = $extval (errno_t, "ESTALE") // POSIX.1
macdef ESTRPIPE = $extval (errno_t, "ESTRPIPE")
macdef ETIME = $extval (errno_t, "ETIME")
macdef ETIMEDOUT = $extval (errno_t, "ETIMEDOUT")
macdef ETXTBSY = $extval (errno_t, "ETXTBSY")
macdef EUCLEAN = $extval (errno_t, "EUCLEAN")
macdef EUNATCH = $extval (errno_t, "EUNATCH")
macdef EUSERS = $extval (errno_t, "EUSERS")
macdef EWOULDBLOCK = $extval (errno_t, "EWOULDBLOCK") // POSIX.1
macdef EXDEV = $extval (errno_t, "EXDEV")
macdef EXFULL = $extval (errno_t, "EXFULL")

(* ****** ****** *)
//
// HX: these functions are reentrant!
//
fun the_errno_get ():<> errno_t = "mac#%"
fun the_errno_set (eno: errno_t):<> void = "mac#%"
//
fun the_errno_reset ():<> void = "mac#%"
//
fun the_errno_test (errno_t):<> bool = "mac#%"
//
(* ****** ****** *)

(* end of [errno.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/malloc.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)
//
abst@ype
mallopt_param = int
//
macdef M_MXFAST = $extval (mallopt_param, "M_MXFAST")
macdef M_TRIM_THRESHOLD = $extval (mallopt_param, "M_TRIM_THRESHOLD")
macdef M_TOP_PAD = $extval (mallopt_param, "M_TOP_PAD")
macdef M_MMAP_THRESHOLD = $extval (mallopt_param, "M_MMAP_THRESHOLD")
macdef M_MMAP_MAX = $extval (mallopt_param, "M_MMAP_MAX")
macdef M_CHECK_ACTION = $extval (mallopt_param, "M_CHECK_ACTION")
//
(* ****** ****** *)

fun mallopt
(
  param: mallopt_param, value: int(*bsz*)
) : int = "mac#%" // endfun // succ/fail: 1/0

(* ****** ****** *)

fun malloc_trim
  (pad: size_t): int (*1/0:some/none*) = "mac#%"

(* ****** ****** *)

fun malloc_usable_size
  {l:addr} (!mfree_libc_v l | ptr l): size_t = "mac#%"
// end of [malloc_usable_size]

(* ****** ****** *)

fun malloc_stats (): void = "mac#%" // it outputs to stderr

(* ****** ****** *)

(*
fun malloc_get_state (): ptr = "mac#%"
fun malloc_set_state (ptr: ptr): int = "mac#%"
*)

(* ****** ****** *)

(* end of [malloc.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/dirent.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

staload
TYPES = "libc/sys/SATS/types.sats"
typedef ino_t = $TYPES.ino_t
typedef off_t = $TYPES.off_t

(* ****** ****** *)

(*
abst@ype
DIR_t0ype = $extype"atslib_DIR_type" // = DIR
typedef DIR = DIR_t0ype
*)
absvtype DIRptr_vtype (l:addr)  = ptr
vtypedef DIRptr (l:addr) = DIRptr_vtype (l)
vtypedef DIRptr0 = [l:addr | l >= null] DIRptr (l)
vtypedef DIRptr1 = [l:addr | l >  null] DIRptr (l)

absview DIR_view (l:addr)
viewdef DIR_v (l:addr) = DIR_view (l)

(* ****** ****** *)

praxi
DIRptr_free_null (dirp: DIRptr (null)): void

(* ****** ****** *)

castfn
DIRptr2ptr{l:addr} (dirp: !DIRptr l):<> ptr (l)
overload ptrcast with DIRptr2ptr

(* ****** ****** *)

abst@ype
dirent_t0ype =
$extype"atslib_dirent_type" // = struct dirent
typedef dirent = dirent_t0ype

(* ****** ****** *)

fun{}
dirent$PC_NAME_MAX (): intGte(0) // HX: default=256

(* ****** ****** *)

absvtype direntp_vtype (l:addr) = ptr
vtypedef direntp (l:addr) = direntp_vtype (l)
vtypedef Direntp0 = [l:addr] direntp (l)
vtypedef Direntp1 = [l:addr | l > null] direntp (l)

(* ****** ****** *)
//
castfn
direntp2ptr{l:addr} (x: !direntp (l)):<> ptr (l)
overload ptrcast with direntp2ptr
//
(* ****** ****** *)

castfn
direntp_get_viewptr{l:agz}
(
  x: !direntp l
) :<> (
  dirent @ l, minus (direntp l, dirent @ l) | ptr l
) // end of [direntp_get_viewptr]

praxi
direntp_free_null (direntp (null)): void

fun direntp_free (x: Direntp0): void = "mac#%"

(* ****** ****** *)

fun dirent_get_d_ino (ent: &RD(dirent)):<> ino_t = "mac#%"

(* ****** ****** *)
//
fun
dirent_get_d_name
  (ent: &RD(dirent)):<> vStrptr1 = "mac#%"
fun{}
dirent_get_d_name_gc (ent: &RD(dirent)):<!wrt> Strptr1
//
(* ****** ****** *)
//
fun
direntp_get_d_name
  (entp: !Direntp1):<> vStrptr1 = "mac#%"
fun{}
direntp_get_d_name_gc (entp: !Direntp1):<!wrt> Strptr1
//
(* ****** ****** *)
//
fun{}
compare_dirent_string
  (ent: &RD(dirent), str: NSH(string)):<> int
//
(* ****** ****** *)

fun opendir (dname: NSH(string)): DIRptr0 = "mac#%"
fun opendir_exn (dname: NSH(string)): DIRptr1 = "ext#%"

(* ****** ****** *)

fun closedir{l:agz}
(
  dirp: !DIRptr (l) >> ptr l
) :<!wrt>
  [i:int | i <= 0]
(
  option_v (DIR_v (l), i < 0) | int i
) = "mac#%" // end of [closedir]

fun closedir_exn (dirp: DIRptr1):<!exnwrt> void = "ext#%"

(* ****** ****** *)

fun readdir
(
  dirp: !DIRptr1
) :<!refwrt> [l:addr]
(
  option_v (vtakeout0 (dirent@l), l > null) | ptr (l)
) = "mac#%" // end of [readdir]

(* ****** ****** *)

fun readdir_r
(
  dirp: !DIRptr1
, ent: &dirent? >> opt (dirent, l > null)
, result: &ptr? >> ptr(l)
) :<!wrt> #[l:addr;i:int | i >= 0] int(i) = "mac#%"

fun{} readdir_r_gc (dirp: !DIRptr1): Direntp0

(* ****** ****** *)

/*
int scandir
(
  const char *dirp
, struct dirent ***namelist
, int (*filter)(const struct dirent *)
, int (*compar)(const struct dirent **, const struct dirent**)
) ;
*/
fun scandir
(
  dirp: NSH(string)
, namelst: &(ptr?) >> ptr(*direntpp*)
, filter: (&dirent) -> int
, compar: (&ptr(*direntp*), &ptr(*direntp*)) -> int
) : int = "mac#%" // endfun

fun alphasort // POSIX-2008
  (entp1: &ptr, entp2: &ptr):<> int = "mac#%"
fun versionsort // GNU-extension
  (entp1: &ptr, entp2: &ptr):<> int = "mac#%"

(* ****** ****** *)

fun rewinddir (dirp: !DIRptr1): void = "mac#%"

(* ****** ****** *)

fun seekdir
  (dirp: !DIRptr1, off: off_t): void = "mac#%"
// end of [seekdir]

(* ****** ****** *)

fun telldir (dirp: !DIRptr1): off_t = "mac#%"

(* ****** ****** *)

(* end of [dirent.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: July, 2012
//
(* ****** ****** *)

typedef
size_t0ype = g0uint(size_kind)

(* ****** ****** *)

abst@ype
wchar_t0ype = $extype"wchar_t"
abst@ype
ptrdiff_t0ype = $extype"ptrdiff_t"

(* ****** ****** *)

typedef size = size_t0ype
typedef size_t = size_t0ype
typedef wchar = wchar_t0ype
typedef wchar_t = wchar_t0ype
typedef ptrdiff = ptrdiff_t0ype
typedef ptrdiff_t = ptrdiff_t0ype

(* ****** ****** *)

(* end of [stddef.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/strings.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

symintr index
fun index_int (s: string, c: int): Ptr0 = "mac#%"
fun index_char (s: string, c: char): Ptr0 = "mac#%"
overload index with index_int
overload index with index_char

(* ****** ****** *)

symintr rindex
fun rindex_int (s: string, c: int): Ptr0 = "mac#%"
fun rindex_char (s: string, c: char): Ptr0 = "mac#%"
overload rindex with rindex_int
overload rindex with rindex_char

(* ****** ****** *)
                      
fun strcasecmp (x1: string, x2: string):<> int = "mac#%"
fun strncasecmp (x1: string, x2: string, n: size_t):<> int = "mac#%"

(* ****** ****** *)

(* end of [strings.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/netinet/CATS/in.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)
//
staload
SOCKET = "libc/sys/SATS/socket.sats"  
typedef sa_family_t = $SOCKET.sa_family_t
typedef socklen_t(n:int) = $SOCKET.socklen_t(n)
typedef sockaddr_struct(n:int) = $SOCKET.sockaddr_struct(n)
//
(* ****** ****** *)

stadef socklen_max = $SOCKET.socklen_max

(* ****** ****** *)
//
abst@ype
in_port_t = $extype"in_port_t"
//
abst@ype
in_port_nbo_t = $extype"in_port_t"
//
(* ****** ****** *)
//
abst@ype in_addr_hbo_t = $extype"in_addr_t"
abst@ype in_addr_nbo_t = $extype"in_addr_t"
//
(* ****** ****** *)
//
abst@ype
ipproto_t = int
//
macdef IPPROTO_IP = $extval (ipproto_t, "IPPROTO_IP")
macdef IPPROTO_HOPOPTS = $extval (ipproto_t, "IPPROTO_HOPOPTS")
macdef IPPROTO_ICMP = $extval (ipproto_t, "IPPROTO_ICMP")
macdef IPPROTO_IGMP = $extval (ipproto_t, "IPPROTO_IGMP")
macdef IPPROTO_IPIP = $extval (ipproto_t, "IPPROTO_IPIP")
macdef IPPROTO_TCP = $extval (ipproto_t, "IPPROTO_TCP")
macdef IPPROTO_EGP = $extval (ipproto_t, "IPPROTO_EGP")
macdef IPPROTO_PUP = $extval (ipproto_t, "IPPROTO_PUP")
macdef IPPROTO_UDP = $extval (ipproto_t, "IPPROTO_UDP")
macdef IPPROTO_IDP = $extval (ipproto_t, "IPPROTO_IDP")
macdef IPPROTO_TP = $extval (ipproto_t, "IPPROTO_TP")
macdef IPPROTO_DCCP = $extval (ipproto_t, "IPPROTO_DCCP")
macdef IPPROTO_IPV6 = $extval (ipproto_t, "IPPROTO_IPV6")
macdef IPPROTO_ROUTING = $extval (ipproto_t, "IPPROTO_ROUTING")
macdef IPPROTO_FRAGMENT = $extval (ipproto_t, "IPPROTO_FRAGMENT")
macdef IPPROTO_RSVP = $extval (ipproto_t, "IPPROTO_RSVP")
macdef IPPROTO_GRE = $extval (ipproto_t, "IPPROTO_GRE")
macdef IPPROTO_ESP = $extval (ipproto_t, "IPPROTO_ESP")
macdef IPPROTO_AH = $extval (ipproto_t, "IPPROTO_AH")
macdef IPPROTO_ICMPV6 = $extval (ipproto_t, "IPPROTO_ICMPV6")
macdef IPPROTO_NONE = $extval (ipproto_t, "IPPROTO_NONE")
macdef IPPROTO_DSTOPTS = $extval (ipproto_t, "IPPROTO_DSTOPTS")
macdef IPPROTO_MTP = $extval (ipproto_t, "IPPROTO_MTP")
macdef IPPROTO_ENCAP = $extval (ipproto_t, "IPPROTO_ENCAP")
macdef IPPROTO_PIM = $extval (ipproto_t, "IPPROTO_PIM")
macdef IPPROTO_COMP = $extval (ipproto_t, "IPPROTO_COMP")
macdef IPPROTO_SCTP = $extval (ipproto_t, "IPPROTO_SCTP")
macdef IPPROTO_UDPLITE = $extval (ipproto_t, "IPPROTO_UDPLITE")
macdef IPPROTO_RAW = $extval (ipproto_t, "IPPROTO_RAW")
macdef IPPROTO_MAX = $extval (ipproto_t, "IPPROTO_MAX")
//
(* ****** ****** *)
//
macdef IPPORT_ECHO = $extval (in_port_t, "IPPORT_ECHO")
macdef IPPORT_DISCARD = $extval (in_port_t, "IPPORT_DISCARD")
macdef IPPORT_SYSTAT = $extval (in_port_t, "IPPORT_SYSTAT")
macdef IPPORT_DAYTIME = $extval (in_port_t, "IPPORT_DAYTIME")
macdef IPPORT_NETSTAT = $extval (in_port_t, "IPPORT_NETSTAT")
macdef IPPORT_FTP = $extval (in_port_t, "IPPORT_FTP")
macdef IPPORT_TELNET = $extval (in_port_t, "IPPORT_TELNET")
macdef IPPORT_SMTP = $extval (in_port_t, "IPPORT_SMTP")
macdef IPPORT_TIMESERVER = $extval (in_port_t, "IPPORT_TIMESERVER")
macdef IPPORT_NAMESERVER = $extval (in_port_t, "IPPORT_NAMESERVER")
macdef IPPORT_WHOIS = $extval (in_port_t, "IPPORT_WHOIS")
macdef IPPORT_MTP = $extval (in_port_t, "IPPORT_MTP")
macdef IPPORT_TFTP = $extval (in_port_t, "IPPORT_TFTP")
macdef IPPORT_RJE = $extval (in_port_t, "IPPORT_RJE")
macdef IPPORT_FINGER = $extval (in_port_t, "IPPORT_FINGER")
macdef IPPORT_TTYLINK = $extval (in_port_t, "IPPORT_TTYLINK")
macdef IPPORT_SUPDUP = $extval (in_port_t, "IPPORT_SUPDUP")
macdef IPPORT_EXECSERVER = $extval (in_port_t, "IPPORT_EXECSERVER")
macdef IPPORT_LOGINSERVER = $extval (in_port_t, "IPPORT_LOGINSERVER")
macdef IPPORT_CMDSERVER = $extval (in_port_t, "IPPORT_CMDSERVER")
macdef IPPORT_EFSSERVER = $extval (in_port_t, "IPPORT_EFSSERVER")
macdef IPPORT_BIFFUDP = $extval (in_port_t, "IPPORT_BIFFUDP")
macdef IPPORT_WHOSERVER = $extval (in_port_t, "IPPORT_WHOSERVER")
macdef IPPORT_ROUTESERVER = $extval (in_port_t, "IPPORT_ROUTESERVER")
macdef IPPORT_RESERVED = $extval (in_port_t, "IPPORT_RESERVED")
macdef IPPORT_USERRESERVED = $extval (in_port_t, "IPPORT_USERRESERVED")
//
(* ****** ****** *)

(*
//
// for IPv4 dotted-decimal
macdef INET_ADDRSTRLEN = 16 // string
//
macdef INET6_ADDRSTRLEN = 46 // for IPv6 hex string
//
*)

(* ****** ****** *)
//
fun
in_port_nbo_int (int): in_port_nbo_t = "mac#%"
fun
in_port_nbo_uint (uint): in_port_nbo_t = "mac#%"
//
symintr in_port_nbo
overload in_port_nbo with in_port_nbo_int
overload in_port_nbo with in_port_nbo_uint
//
(* ****** ****** *)
//
fun
in_addr_hbo2nbo (in_addr_hbo_t): in_addr_nbo_t = "mac#%"
//
(* ****** ****** *)
//
(* constant addresses in host-byte-order *)
//
// Address to accept any incoming messages: 0x00000000
//
macdef INADDR_ANY = $extval (in_addr_hbo_t, "INADDR_ANY")
//
// Address to send to all hosts: 0xffffffff
//
macdef INADDR_BROADCAST	= $extval (in_addr_hbo_t, "INADDR_BROADCAST")
//
// Address indicating an error return: 0xffffffff
//
macdef INADDR_NONE = $extval (in_addr_hbo_t, "INADDR_NONE")
//
// Network number for local host loopback
//
#define	IN_LOOPBACKNET 127
//
// Address to loopback in software to local host: 127.0.0.1
//
macdef INADDR_LOOPBACK = $extval (in_addr_hbo_t, "INADDR_LOOPBACK")
//
(* ****** ****** *)
//
(*
** Defined for Multicast
*)
//
// 0xe0000000 // 224.0.0.0
//
macdef
INADDR_UNSPEC_GROUP =
$extval (in_addr_hbo_t, "INADDR_UNSPEC_GROUP")
//
// 0xe0000001 // 224.0.0.1
//
macdef
INADDR_ALLHOSTS_GROUP =
$extval (in_addr_hbo_t, "INADDR_ALLHOSTS_GROUP")
//
// 0xe0000002 // 224.0.0.2
//
macdef
INADDR_ALLRTRS_GROUP =
$extval (in_addr_hbo_t, "INADDR_ALLRTRS_GROUP")
//
// 0xe00000ff // 224.0.0.255
//
macdef
INADDR_MAX_LOCAL_GROUP =
$extval (in_addr_hbo_t, "INADDR_MAX_LOCAL_GROUP")
//
(* ****** ****** *)
//
(*
** HX: [in_addr_struct] is taken by C++
*)
typedef
in_addr_struct =
$extype_struct
"in_addr_structats" of {
  s_addr= in_addr_nbo_t // IPv4 address of ulint
} (* end of [in_addr_struct] *)
//
(* ****** ****** *)
//
(*
** HX: [in6_addr_struct] may be taken by C++
*)
typedef
in6_addr_struct =
$extype_struct
"in6_addr_structats" of {
  s6_addr= @[uint8][16] // IPv6 address of 16 bytes
} (* end of [in6_addr_struct] *)

(* ****** ****** *)

(* end of [in.sats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: November, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_NETINET_IN_CATS
#define ATSLIB_LIBC_NETINET_IN_CATS

/* ****** ****** */
//
#include <arpa/inet.h>
#include <netinet/in.h>
//
/* ****** ****** */
//
typedef
struct in_addr in_addr_structats;
typedef
struct in6_addr in6_addr_structats;
//
/* ****** ****** */
//
typedef
struct sockaddr_in sockaddr_in_struct ;
typedef
struct sockaddr_in6 sockaddr_in6_struct ;
//
#define atslib_socklen_in (sizeof(sockaddr_in_struct))
#define atslib_socklen_in6 (sizeof(sockaddr_in6_struct))
//
/* ****** ****** */

#define atslib_in_port_nbo_int(nport) htons(nport)
#define atslib_in_port_nbo_uint(nport) htons(nport)

/* ****** ****** */

ATSinline()
in_addr_t
atslib_in_addr_hbo2nbo
  (in_addr_t addr_hbo) { return htonl (addr_hbo) ; }
/* end of [atslib_in_addr_hbo2nbo] */

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_NETINET_IN_CATS

/* ****** ****** */

/* end of [in.cats] */
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/arpa/CATS/inet.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

staload IN = "libc/netinet/SATS/in.sats"
typedef in_port_nbo_t = $IN.in_port_nbo_t
typedef in_addr_hbo_t = $IN.in_addr_hbo_t
typedef in_addr_nbo_t = $IN.in_addr_nbo_t
typedef in_addr_struct = $IN.in_addr_struct

(* ****** ****** *)
//
abst@ype
uint16_t0ype_netbyteord = uint16
typedef uint16_nbo = uint16_t0ype_netbyteord
//
fun htons
  (i: uint16): uint16_nbo = "mac#%"
fun ntohs
  (i: uint16_nbo): uint16 = "mac#%"
//
(* ****** ****** *)
//
abst@ype
uint32_t0ype_netbyteord = uint32
typedef uint32_nbo = uint32_t0ype_netbyteord
//
fun htonl (i: uint32): uint32_nbo = "mac#%"
fun ntohl (i: uint32_nbo): uint32 = "mac#%"
//
(* ****** ****** *)
//
castfn
in_port_of_uint16_nbo (x: uint16_nbo): in_port_nbo_t
castfn
uint16_of_in_port_nbo (x: in_port_nbo_t): uint16_nbo
//
(* ****** ****** *)

fun
inet_aton
(
  cp: string
, inp: &in_addr_struct? >> opt(in_addr_struct, b)
) : #[b:bool] bool(b) = "mac#%" // end-of-function

(* ****** ****** *)
//
// HX: note that this one cannot tell
// -1 from 255.255.255.255 (a valid address)
//
fun inet_addr (cp: string): in_addr_nbo_t = "mac#%"
fun inet_network (cp: string): in_addr_hbo_t = "mac#%"
//
(* ****** ****** *)
//
fun
inet_makeaddr
  (net: int, host: int): in_addr_struct = "mac#%"
// end of [inet_makeaddr]
//
(* ****** ****** *)
//
// HX: this function is not reentrant
//
fun
inet_ntoa
  (inp: in_addr_struct) :<!ref> vStrptr1 = "mac#%"
//
(* ****** ****** *)
//
fun
inet_lnaof
  (addr: in_addr_struct): in_addr_hbo_t = "mac#%"
//
fun inet_netof
  (addr: in_addr_struct): in_addr_hbo_t = "mac#%"
//
(* ****** ****** *)

fun
inet4_pton
(
  cp: string // af=AF_INET
, inp: &in_addr_struct? >> opt (in_addr_struct, i > 0)
) : #[i:int] int (i) = "mac#%" // end-of-fun

fun
inet6_pton
(
  cp: string // af= AF_INET6
, inp: &in_addr_struct? >> opt (in_addr_struct, i > 0)
) : #[i:int] int (i) = "mac#%" // end-of-fun

(* ****** ****** *)

(* end of [inet.sats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: November, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_ARPA_INET_CATS
#define ATSLIB_LIBC_ARPA_INET_CATS

/* ****** ****** */
//
#include <arpa/inet.h>
#include <netinet/in.h>
//
/* ****** ****** */

#ifndef EXIT_SUCCESS
#define	EXIT_SUCCESS 0
#endif // EXIT_SUCCESS
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif // EXIT_FAILURE

/* ****** ****** */
//
#define atslib_htons htons
#define atslib_ntohs ntohs
//
#define atslib_htonl htonl
#define atslib_ntohl ntohl
//
/* ****** ****** */

extern
int
inet_aton
(
  const char *cp, struct in_addr *inp
) ; // end of [inet_aton]

ATSinline()
atstype_bool
atslib_inet_aton
(
  atstype_ptr cp, atstype_ref inp
) {
//
  int rtn ;
//
  rtn =
  inet_aton((char*)cp, (struct in_addr*)inp) ;
//
  return (rtn ? atsbool_true : atsbool_false) ;
//
} // end of [atslib_inet_aton]

/* ****** ****** */

#define atslib_inet_addr inet_addr
#define atslib_inet_network inet_network

/* ****** ****** */

#define atslib_inet_makeaddr inet_makeaddr

/* ****** ****** */

#define atslib_inet_ntoa inet_ntoa

/* ****** ****** */

#define atslib_inet4_pton(cp, inp) inet_pton(AF_INET4, cp, inp)
#define atslib_inet6_pton(cp, inp) inet_pton(AF_INET6, cp, inp)

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_ARPA_INET_CATS

/* ****** ****** */

/* end of [inet.cats] */
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: July, 2013
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc.gdbm_gdbm"
#define ATS_STALOADFLAG 0 // no static loading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

%{#
#include "libc/gdbm/CATS/gdbm.cats"
%} // end of [%{#]

(* ****** ****** *)

staload FCNTL = "libc/SATS/fcntl.sats"
staload TYPES = "libc/sys/SATS/types.sats"
typedef mode_t = $TYPES.mode_t

(* ****** ****** *)

#include "./SHARE/datum.hats"

(* ****** ****** *)

absvtype GDBMfilptr (lf:addr) = ptr

vtypedef GDBMfilptr = [lf:addr] GDBMfilptr (lf)
vtypedef GDBMfilptr0 = [lf:addr | lf >= null] GDBMfilptr (lf)
vtypedef GDBMfilptr1 = [lf:addr | lf >  null] GDBMfilptr (lf)

(* ****** ****** *)

praxi
GDBMfilptr_free_null (GDBMfilptr (null)): void
castfn
GDBMfilptr2ptr {lf:addr} (!GDBMfilptr lf):<> ptr (lf)
overload ptrcast with GDBMfilptr2ptr

(* ****** ****** *)
//
typedef GDBMerror = int
//
macdef
GDBM_NO_ERROR = $extval (GDBMerror, "GDBM_NO_ERROR")
macdef
GDBM_MALLOC_ERROR = $extval (GDBMerror, "GDBM_MALLOC_ERROR")
macdef
GDBM_BLOCK_SIZE_ERROR = $extval (GDBMerror, "GDBM_BLOCK_SIZE_ERROR")
macdef
GDBM_FILE_OPEN_ERROR = $extval (GDBMerror, "GDBM_FILE_OPEN_ERROR")
macdef
GDBM_FILE_WRITE_ERROR = $extval (GDBMerror, "GDBM_FILE_WRITE_ERROR")
macdef
GDBM_FILE_SEEK_ERROR = $extval (GDBMerror, "GDBM_FILE_SEEK_ERROR")
macdef
GDBM_FILE_READ_ERROR = $extval (GDBMerror, "GDBM_FILE_READ_ERROR")
macdef
GDBM_BAD_MAGIC_NUMBER = $extval (GDBMerror, "GDBM_BAD_MAGIC_NUMBER")
macdef
GDBM_EMPTY_DATABASE = $extval (GDBMerror, "GDBM_EMPTY_DATABASE")
macdef
GDBM_CANT_BE_READER = $extval (GDBMerror, "GDBM_CANT_BE_READER")
macdef
GDBM_CANT_BE_WRITER = $extval (GDBMerror, "GDBM_CANT_BE_WRITER")
macdef
GDBM_READER_CANT_DELETE = $extval (GDBMerror, "GDBM_READER_CANT_DELETE")
macdef
GDBM_READER_CANT_STORE = $extval (GDBMerror, "GDBM_READER_CANT_STORE")
macdef
GDBM_READER_CANT_REORGANIZE = $extval (GDBMerror, "GDBM_READER_CANT_REORGANIZE")
macdef
GDBM_UNKNOWN_UPDATE = $extval (GDBMerror, "GDBM_UNKNOWN_UPDATE")
macdef
GDBM_ITEM_NOT_FOUND = $extval (GDBMerror, "GDBM_ITEM_NOT_FOUND")
macdef
GDBM_REORGANIZE_FAILED = $extval (GDBMerror, "GDBM_REORGANIZE_FAILED")
macdef
GDBM_CANNOT_REPLACE = $extval (GDBMerror, "GDBM_CANNOT_REPLACE")
macdef
GDBM_ILLEGAL_DATA = $extval (GDBMerror, "GDBM_ILLEGAL_DATA")
macdef
GDBM_OPT_ALREADY_SET = $extval (GDBMerror, "GDBM_OPT_ALREADY_SET")
macdef
GDBM_OPT_ILLEGAL = $extval (GDBMerror, "GDBM_OPT_ILLEGAL")
macdef
GDBM_BYTE_SWAPPED = $extval (GDBMerror, "GDBM_BYTE_SWAPPED")
macdef
GDBM_BAD_FILE_OFFSET = $extval (GDBMerror, "GDBM_BAD_FILE_OFFSET")
macdef
GDBM_BAD_OPEN_FLAGS = $extval (GDBMerror, "GDBM_BAD_OPEN_FLAGS")
//
(* ****** ****** *)
//
fun gdbm_errno_get (): GDBMerror = "mac#%"
//
(* ****** ****** *)
//
// statically-allocated
//
val gdbm_version : string = "mac#%"
val gdbm_version_number : array (int, 3) = "mac#mac%"
//
(* ****** ****** *)

fun gdm_version_cmp
  (v1: &(@[int][3]), v2: &(@[int][3])):<> int = "mac#%"
// end of [gdm_version_cmp]
  
(* ****** ****** *)

(*
#define  GDBM_READER  0		/* A reader. */
#define  GDBM_WRITER  1		/* A writer. */
#define  GDBM_WRCREAT 2		/* A writer.  Create the db if needed. */
#define  GDBM_NEWDB   3		/* A writer.  Always create a new db. */
*)
macdef GDBM_READER = $extval (int, "GDBM_READER")
macdef GDBM_WRITER = $extval (int, "GDBM_WRITER")
macdef GDBM_WRCREAT = $extval (int, "GDBM_WRCREAT")
macdef GDBM_NEWDB = $extval (int, "GDBM_NEWDB")

(*
#define  GDBM_FAST    0x10	/* Write fast! => No fsyncs.  OBSOLETE. */
#define  GDBM_SYNC    0x20	/* Sync operations to the disk. */
#define  GDBM_NOLOCK  0x40	/* Don't do file locking operations. */
*)
macdef GDBM_FAST = $extval (int, "GDBM_FAST")
macdef GDBM_SYNC = $extval (int, "GDBM_SYNC")
macdef GDBM_NOLOCK = $extval (int, "GDBM_NOLOCK")


(* ****** ****** *)

(*
GDBM_FILE gdbm_open
  (name, block_size, flags, mode, fatal_func);
*)
//
// fatal_func: (string) -> void
//
fun gdbm_open
(
  name: string
, block_size: int, flags: int, mode: mode_t, fatal_func: ptr
) : GDBMfilptr0 = "mac#%" // end of [gdbm_open]

(* ****** ****** *)

(*
void gdbm_close(dbf);
*)
fun gdbm_close (dbf: GDBMfilptr) : void = "mac#%"

(* ****** ****** *)

(*
int gdbm_store(dbf, key, content, flag);
*)
(*
#define  GDBM_INSERT  0		/* Never replace old data with new. */
#define  GDBM_REPLACE 1		/* Always replace old data with new. */
*)
macdef GDBM_INSERT = $extval (int, "GDBM_INSERT")
macdef GDBM_REPLACE = $extval (int, "GDBM_REPLACE")

fun gdbm_store
  {l1,l2:addr}{n1,n2:nat}
(
  dbf: !GDBMfilptr1, key: !datum(l1, n1), content: !datum(l2, n2), flag: int
) : int(*err*) = "mac#%" // end of [gdbm_store]

(* ****** ****** *)

(*
datum gdbm_fetch(dbf, key);
*)
//
// HX: the return value is allocated
//
fun gdbm_fetch
  {l:agz}{n:int}
  (dbf: !GDBMfilptr1, key: !datum (l, n)): datum0 = "mac#%"
// end of [gdbm_fetch]

(* ****** ****** *)

(*
int gdbm_exists(dbf, key);
*)
fun gdbm_exists
  {l:agz}{n:int} // true/false: 0/1
  (dbf: !GDBMfilptr1, key: !datum (l, n)): int = "mac#%"
// end of [gdbm_exists]

(* ****** ****** *)

(*
int gdbm_delete(dbf, key);
*)
fun gdbm_delete
  {l:agz}{n:int} // succ/fail: 0/-1
  (dbf: !GDBMfilptr1, key: !datum (l, n)) : int = "mac#%"
// end of [gdbm_delete]

(* ****** ****** *)

(*
datum gdbm_firstkey(dbf);
*)
fun gdbm_firstkey (dbf: !GDBMfilptr1): datum0 = "mac#%"

(* ****** ****** *)

(*
datum gdbm_nextkey(dbf, key);
*)

fun gdbm_nextkey
  {l:agz}{n:int}
  (dbf: !GDBMfilptr, key: !datum(l, n) >> _): datum0 = "mac#%"
// end of [gdbm_nextkey]

(* ****** ****** *)

(*
int gdbm_reorganize(dbf);
*)
fun gdbm_reorganize (!GDBMfilptr1): int = "mac#%"

(* ****** ****** *)

(*
void gdbm_sync(dbf);
*)
fun gdbm_sync (dbf: !GDBMfilptr1): void = "mac#%"

(* ****** ****** *)

(*
int gdbm_export
(
  GDBM FILE dbf
, const char *exportfile,int flag, int mode
) ;
*)
fun gdbm_export
(
  dbf: !GDBMfilptr1
, exportfile: string, flag: int, mode: mode_t
) : int = "mac#%" // end of [gdbm_export]

(* ****** ****** *)

(*
int gdbm_import
(
  GDBM FILE dbf , const char *importfile , int flag
) ;
*)
fun gdbm_import
(
  dbf: !GDBMfilptr1, importfile: string, flag: int
) : int = "mac#%" // end of [gdbm_import]

(* ****** ****** *)

(*
char *gdbm_strerror(int errno);
*)
fun gdbm_strerror
  (errno: GDBMerror): string(*pre-allocated*) = "mac#%"
// end of [gdbm_strerror]

(* ****** ****** *)

(*
int gdbm_setopt(dbf, option, value, size);
*)
abst@ype
gdbmsetopt_t0ype (a:t@ype) = int
stadef gdbmsetopt = gdbmsetopt_t0ype
abst@ype
gdbmgetopt_t0ype (a:t@ype) = int
stadef gdbmgetopt = gdbmgetopt_t0ype
//
macdef
GDBM_CACHESIZE = $extval (gdbmsetopt(size_t), "GDBM_CACHESIZE")
macdef
GDBM_SETCACHESIZE = $extval (gdbmsetopt(size_t), "GDBM_SETCACHESIZE")
macdef
GDBM_GETCACHESIZE = $extval (gdbmgetopt(size_t), "GDBM_GETCACHESIZE")
//
macdef GDBM_GETFLAGS = $extval (gdbmgetopt(int), "GDBM_GETFLAGS")
//
macdef GDBM_FASTMODE = $extval (gdbmsetopt(int), "GDBM_FASTMODE")
//
macdef
GDBM_SYNCMODE = $extval (gdbmsetopt(int), "GDBM_SYNCMODE")
macdef
GDBM_SETSYNCMODE = $extval (gdbmsetopt(int), "GDBM_SETSYNCMODE")
macdef
GDBM_GETSYNCMODE = $extval (gdbmgetopt(int), "GDBM_GETSYNCMODE")
//
macdef
GDBM_COALESCEBLKS = $extval (gdbmsetopt(int), "GDBM_COALESCEBLKS")
macdef
GDBM_SETCOALESCEBLKS = $extval (gdbmsetopt(int), "GDBM_SETCOALESCEBLKS")
macdef
GDBM_GETCOALESCEBLKS = $extval (gdbmgetopt(int), "GDBM_GETCOALESCEBLKS")
//
macdef
GDBM_SETMAXMAPSIZE = $extval (gdbmsetopt(size_t), "GDBM_SETMAXMAPSIZE")
macdef
GDBM_GETMAXMAPSIZE = $extval (gdbmgetopt(size_t), "GDBM_GETMAXMAPSIZE")
//
macdef
GDBM_SETMMAP = $extval (gdbmsetopt(int), "GDBM_SETMMAP")
macdef
GDBM_GETMMAP = $extval (gdbmgetopt(int), "GDBM_GETMMAP")
//
macdef
GDBM_GETDBNAME = $extval (gdbmgetopt(ptr), "GDBM_GETDBNAME")
//
(* ****** ****** *)

fun
gdbm_setopt
  {a:t@ype} (
  dbf: !GDBMfilptr1
, option: gdbmsetopt(a), value: &a, size: sizeof_t(a)
) : int(*err*) = "mac#%" // end of [gdbm_setopt]
fun
gdbm_getopt
  {a:t@ype} (
  dbf: !GDBMfilptr1
, option: gdbmgetopt(a), value: &a? >> a, size: sizeof_t(a)
) : int(*err*) = "mac#%" // end of [gdbm_getopt]

fun gdbm_getdbname (dbf: !GDBMfilptr1): Strptr0 = "mac#%"

(* ****** ****** *)

(*
int gdbm_fdesc(dbf);
*)
fun gdbm_fdesc (!GDBMfilptr1): int(*fd*) = "mac#%" // no failure

(* ****** ****** *)

(* end of [gdbm.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: July, 2013
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc.gdbm_ndbm"
#define ATS_STALOADFLAG 0 // no static loading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

%{#
#include "libc/gdbm/CATS/ndbm.cats"
%} // end of [%{#]

(* ****** ****** *)

(* end of [ndbm.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: July, 2013
//
(* ****** ****** *)

absvtype
dptr_addr_int_vtype (addr, int)
//
vtypedef dptr
  (l:addr, n:int) = dptr_addr_int_vtype (l, n)
//
(* ****** ****** *)

viewdef dptrout
  (l:addr, n:int) = dptr (l, n) -<lin,prf> void

(* ****** ****** *)

castfn dptr2ptr
  {l:addr} {n:int} (x: !dptr(l, n)):<> ptr (l)
overload ptrcast with dptr2ptr

(* ****** ****** *)

vtypedef
datum
  (l:addr, n:int) =
$extype_struct
"atslib_datum_type" of { dptr= dptr(l, n), dsize= int(n) }
// end of [datum]

(* ****** ****** *)

vtypedef
datum0 = [l:addr;n:int] datum (l, n)
vtypedef // for valid data
datum1 = [l:addr;n:int | l > null; n >= 0] datum (l, n)

(* ****** ****** *)

fun datum_is_valid
  {l:addr}{n:int}
  (x: datum (l, n))
: bool (l > null) = "mac#atslib_gdbm_datum_is_valid"
// end of [datum_is_valid]

fun datum_takeout_ptr
  {l:addr}{n:int}
  (datum (l, n)):<> dptr (l, n) = "mac#atslib_gdbm_datum_takeout_ptr"
// end of [datum_takeout_ptr]

(* ****** ****** *)
//
// HX: implemented in [gdbm.cats]
//
fun
datum_make0_string
  (string)
: [l:agz;n:nat]
(
  dptrout (l, n) | datum (l, n)
) = "mac#atslib_gdbm_datum_make0_string"
//
fun datum_make1_string
  (string): datum1 = "mac#atslib_gdbm_datum_make1_string"
//
(* ****** ****** *)

fun datum_free (x: datum0): void = "mac#atslib_gdbm_datum_free"

(* ****** ****** *)

(* end of [datum.hats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-20?? Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: July, 2013
//
/* ****** ****** */

#include "libc/CATS/string.cats"

/* ****** ****** */

typedef datum atslib_datum_type ;

/* ****** ****** */

ATSinline()
atstype_bool
atslib_gdbm_datum_is_valid
  (datum x) { return (x.dptr != 0) ; }
// end of [atslib_gdbm_datum_is_valid]

ATSinline()
atstype_ptr
atslib_gdbm_datum_takeout_ptr
  (datum x) { return x.dptr ; }
// end of [atslib_gdbm_datum_takeout_ptr]

/* ****** ****** */

ATSinline()
datum
atslib_gdbm_datum_make0_string
  (char *str) {
  datum res ;
  res.dptr = str ;
  res.dsize = (int)(atslib_strlen(str) + 1) ; // HX: account for the trailing null char!
  return res ;
} // end of [atslib_gdbm_datum_make0_string]

ATSinline()
datum
atslib_gdbm_datum_make1_string
  (char *str) {
  datum res ;
  res.dptr = (char*)atslib_strdup_gc(str) ;
  res.dsize = (int)(atslib_strlen(str) + 1) ; // HX: account for the trailing null char!
  return res ;
} // end of [atslib_gdbm_datum_make1_string]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atslib_gdbm_datum_free
  (datum x) {
  if (x.dptr) atspre_mfree_gc(x.dptr) ; return ;
} // end of [atslib_gdbm_datum_free]

/* ****** ****** */

/* end of [datum.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-20?? Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: July, 2013
//
/* ****** ****** */

#include <gdbm.h>

/* ****** ****** */

#include "libc/gdbm/CATS/datum.cats"

/* ****** ****** */

ATSinline()
gdbm_error
atslib_gdbm_errno_get () { return gdbm_errno ; }

/* ****** ****** */

#define atslib_gdbm_open gdbm_open
#define atslib_gdbm_close gdbm_close

#define atslib_gdbm_store gdbm_store

#define atslib_gdbm_fetch gdbm_fetch
#define atslib_gdbm_exists gdbm_exists

#define atslib_gdbm_delete gdbm_delete

#define atslib_gdbm_firstkey gdbm_firstkey
#define atslib_gdbm_nextkey gdbm_nextkey

#define atslib_gdbm_reorganize gdbm_reorganize

#define atslib_gdbm_sync gdbm_sync

#define atslib_gdbm_export gdbm_export
#define atslib_gdbm_import gdbm_import

#define atslib_gdbm_strerror gdbm_strerror

/* ****** ****** */

#define atslib_gdbm_setopt gdbm_setopt
#define atslib_gdbm_getopt gdbm_setopt

/* ****** ****** */

#ifdef GDBM_GETDBNAME
ATSinline()
gdbm_getdbname
(
  atstype_ptr dbf
) {
  int err ; char *dbname ;
  err = gdbm_setopt((GDBM_FILE)dbf, GDBM_GETDBNAME, &dbname, sizeof(void*)) ;
  if (err < 0) return (char*)0 ;
  return dbname ;
} // end of [gdbm_getdbname]
#endif // end of [GDBM_GETDBNAME]

/* ****** ****** */

#define atslib_gdbm_fdesc gdbm_fdesc

/* ****** ****** */

/* end of [gdbm.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/fnmatch.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_FNMATCH
#define ATSLIB_LIBC_CATS_FNMATCH

/* ****** ****** */

#include <fnmatch.h>

/* ****** ****** */

#define atslib_fnmatch_null(pat, str) fnmatch((char*)pat, (char*)str, 0)
#define atslib_fnmatch_flags(pat, str, flags) fnmatch((char*)pat, (char*)str, flags)

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_FNMATCH

/* ****** ****** */

/* end of [fnmatch.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/strings.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_STRINGS
#define ATSLIB_LIBC_CATS_STRINGS

/* ****** ****** */

#include <strings.h>

/* ****** ****** */

#define atslib_index_int index
#define atslib_index_char(c) index((int)c)

#define atslib_rindex_int rindex
#define atslib_rindex_char(c) rindex((int)c)

/* ****** ****** */

#define atslib_strcasecmp strcasecmp
#define atslib_strncasecmp strncasecmp

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_STRINGS

/* ****** ****** */

/* end of [strings.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/unistd.atxt
** Time of generation: Wed Sep 23 16:09:13 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_UNISTD
#define ATSLIB_LIBC_CATS_UNISTD

/* ****** ****** */

#include <unistd.h>

/* ****** ****** */

#include "share/H/pats_atslib.h"

/* ****** ****** */

#define atslib_close close
#define atslib_close0 atslib_close
#define atslib_close1 atslib_close
#define atslib_close0_exn atslib_close_exn
#define atslib_close1_exn atslib_close_exn

/* ****** ****** */

#define atslib_dup dup
#define atslib_dup_fildes dup
#define atslib_dup2 dup2
#define atslib_dup3 dup3

/* ****** ****** */

#define atslib_execv(path, argv) execv((char*)path, (char**)argv)
#define atslib_execvp(path, argv) execvp((char*)path, (char**)argv)

/* ****** ****** */

#define atslib_encrypt encrypt

/* ****** ****** */

#define atslib_fork fork

/* ****** ****** */

#define atslib_getcwd getcwd

/* ****** ****** */

#define atslib_getlogin getlogin
#define atslib_getlogin_r getlogin_r

/* ****** ****** */

#define atslib_getpid getpid
#define atslib_getppid getppid

/* ****** ****** */

#define atslib_getuid getuid
#define atslib_setuid setuid
#define atslib_geteuid geteuid
#define atslib_seteuid seteuid

/* ****** ****** */

#define atslib_getgid getgid
#define atslib_setgid setgid
#define atslib_getegid getegid
#define atslib_setegid setegid

/* ****** ****** */

#define atslib_setreuid setreuid
#define atslib_setregid setregid
#define atslib_setresuid setresuid
#define atslib_setresgid setresgid

/* ****** ****** */

#define atslib_setfsuid setfsuid
#define atslib_setfsgid setfsgid

/* ****** ****** */

#define atslib_pause pause

/* ****** ****** */

#define atslib_read_err read
#define atslib_write_err write

/* ****** ****** */

#define atslib_pread pread
#define atslib_pwrite pwrite

/* ****** ****** */

#define atslib_alarm alarm
#define atslib_alarm_set alarm
#define atslib_alarm_cancel() alarm(0)

/* ****** ****** */

#define atslib_sleep_int sleep
#define atslib_sleep_uint sleep

/* ****** ****** */

#define atslib_usleep_int usleep
#define atslib_usleep_uint usleep

/* ****** ****** */

#define atslib_rmdir rmdir

/* ****** ****** */

#define atslib_link link
#define atslib_unlink unlink

/* ****** ****** */

#define atslib_symlink symlink
#define atslib_readlink readlink

/* ****** ****** */

#define atslib_sync sync
#define atslib_fsync fsync
#define atslib_fdatasync fdatasync

/* ****** ****** */

#define atslib_truncate truncate
#define atslib_ftruncate ftruncate

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_UNISTD

/* ****** ****** */

/* end of [unistd.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/time.atxt
** Time of generation: Wed Sep 23 16:09:13 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_TIME
#define ATSLIB_LIBC_CATS_TIME

/* ****** ****** */

#include <time.h>

/* ****** ****** */

typedef time_t atslib_time_type ;
typedef struct tm atslib_tm_struct_type ;

/* ****** ****** */

typedef clock_t atslib_clock_type ;

/* ****** ****** */

typedef struct timespec atslib_timespec_type ;

/* ****** ****** */

#define atslib_difftime difftime

/* ****** ****** */

#define atslib_time_get() time((time_t*)0)

ATSinline()
atstype_bool
atslib_time_getset
(
  atstype_ref tval
) {
  return (time((time_t*)tval) >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atslib_time_getset]

/* ****** ****** */

#define atslib_ctime ctime
#define atslib_ctime_r ctime_r

/* ****** ****** */

ATSinline()
atstype_int
atslib_tm_get_sec
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_sec ;
} // end of [atslib_tm_get_sec]

ATSinline()
atstype_int
atslib_tm_get_min
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_min ;
} // end of [atslib_tm_get_min]

ATSinline()
atstype_int
atslib_tm_get_hour
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_hour ;
} // end of [atslib_tm_get_hour]

ATSinline()
atstype_int
atslib_tm_get_mday
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_mday ;
} // end of [atslib_tm_get_mday]

ATSinline()
atstype_int
atslib_tm_get_mon
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_mon ;
} // end of [atslib_tm_get_mon]

ATSinline()
atstype_int
atslib_tm_get_year
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_year ;
} // end of [atslib_tm_get_year]

ATSinline()
atstype_int
atslib_tm_get_wday
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_wday ;
} // end of [atslib_tm_get_wday]

ATSinline()
atstype_int
atslib_tm_get_yday
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_yday ;
} // end of [atslib_tm_get_yday]

ATSinline()
atstype_int
atslib_tm_get_isdst
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_isdst ;
} // end of [atslib_tm_get_isdst]

/* ****** ****** */

#define atslib_mktime mktime

/* ****** ****** */

#define atslib_asctime asctime

/* ****** ****** */

#define atslib_gmtime gmtime
#define atslib_gmtime_r gmtime_r

/* ****** ****** */

#define atslib_localtime localtime
#define atslib_localtime_r localtime_r

/* ****** ****** */

#define atslib_tzset tzset

/* ****** ****** */

#define atslib_clock clock

#define atslib_clock_getres clock_getres

/* ****** ****** */

#define atslib_clock_gettime clock_gettime
#define atslib_clock_settime clock_settime

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_TIME

/* ****** ****** */

/* end of [time.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/fcntl.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_FCNTL
#define ATSLIB_LIBC_CATS_FCNTL

/* ****** ****** */

#include <sys/types.h>
#include <fcntl.h> // HX: after sys/types

/* ****** ****** */

#define atslib_fildes_get_int(fd) (fd)

/* ****** ****** */

ATSinline()
atstype_bool
atslib_fildes_isgtez
  (atstype_int fd)
{
  return (fd >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atslib_fildes_isgtez]

/* ****** ****** */

#define atslib_fcntlflags_lor(x1, x2) ((x1)|(x2))

/* ****** ****** */

#define atslib_open_flags(path, flags) open((char*)path, flags)
#define atslib_open_flags_mode(path, flags, mode) open((char*)path, flags, mode)

/* ****** ****** */

#define atslib_fcntl_getfl(fd) fcntl(fd, F_GETFL)
#define atslib_fcntl_setfl(fd, flags) fcntl(fd, F_SETFL, flags)

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_FCNTL

/* ****** ****** */

/* end of [fcntl.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/stdlib.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_STDLIB
#define ATSLIB_LIBC_CATS_STDLIB

/* ****** ****** */

#include <stdlib.h>

/* ****** ****** */

#include "share/H/pats_atslib.h"

/* ****** ****** */

#define atslib__Exit _Exit
#define atslib_atexit atexit

/* ****** ****** */

#define atslib_abort abort

/* ****** ****** */

#define atslib_abs abs
#define atslib_labs labs
#define atslib_llabs llabs

/* ****** ****** */

#define atslib_div div
#define atslib_ldiv ldiv
#define atslib_lldiv lldiv

/* ****** ****** */

#define atslib_a64l a64l
#define atslib_l64a l64a

/* ****** ****** */

#define atslib_atoi atoi
#define atslib_atol atol
#define atslib_atoll atoll
#define atslib_atof atof

/* ****** ****** */

#define atslib_strtol0(nptr, base) atslib_strtol_unsafe(nptr, 0, base)
#define atslib_strtol1(nptr, endptr, base) atslib_strtol_unsafe(nptr, endptr, base)
#define atslib_strtol_unsafe(nptr, endptr, base) strtol((char*)(nptr), (char**)(endptr), base)

/* ****** ****** */

#define atslib_strtoll0(nptr, base) atslib_strtoll_unsafe(nptr, 0, base)
#define atslib_strtoll1(nptr, endptr, base) atslib_strtoll_unsafe(nptr, endptr, base)
#define atslib_strtoll_unsafe(nptr, endptr, base) strtoll((char*)(nptr), (char**)(endptr), base)

/* ****** ****** */

#define atslib_strtof0(nptr) atslib_strtof_unsafe(nptr, 0)
#define atslib_strtof1(nptr, endptr) atslib_strtof_unsafe(nptr, endptr)
#define atslib_strtof_unsafe(nptr, endptr) strtof((char*)(nptr), (char**)(endptr))

/* ****** ****** */

#define atslib_strtod0(nptr) atslib_strtod_unsafe(nptr, 0)
#define atslib_strtod1(nptr, endptr) atslib_strtod_unsafe(nptr, endptr)
#define atslib_strtod_unsafe(nptr, endptr) strtod((char*)(nptr), (char**)(endptr))

/* ****** ****** */

#define atslib_getenv getenv
#define atslib_putenv putenv
#define atslib_setenv setenv
#define atslib_unsetenv unsetenv

/* ****** ****** */

#define atslib_rand rand
#define atslib_srand srand
#define atslib_rand_r rand_r

/* ****** ****** */

#define atslib_random random
#define atslib_srandom srandom

/* ****** ****** */

#define atslib_drand48 drand48
#define atslib_erand48 erand48
#define atslib_lrand48 lrand48
#define atslib_nrand48 nrand48
#define atslib_mrand48 mrand48
#define atslib_jrand48 jrand48
#define atslib_srand48 srand48
#define atslib_seed48 seed48
#define atslib_lcong48 lcong48

/* ****** ****** */

#define \
atslib_qsort(base, nmemb, size, compar) \
  qsort(base, nmemb, size, (void*)compar)

/* ****** ****** */

#define \
atslib_bsearch(key, base, nmemb, size, compar) \
  bsearch(key, base, nmemb, size, (void*)compar)

/* ****** ****** */

#define atslib_mkstemp mkstemp
#define atslib_mkostemp mkostemp

/* ****** ****** */

#define atslib_mfree_libc free
#define atslib_malloc_libc malloc

/* ****** ****** */

#define atslib_system system

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_STDLIB

/* ****** ****** */

/* end of [stdlib.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/signal.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_SIGNAL
#define ATSLIB_LIBC_CATS_SIGNAL

/* ****** ****** */

#include <signal.h>

/* ****** ****** */

typedef int signum_t ;
typedef void (*sighandler_t)(signum_t) ;

/* ****** ****** */

typedef struct sigaction atslib_sigaction_struct ;

/* ****** ****** */

#define atslib_sigaddset sigaddset
#define atslib_sigdelset sigdelset
#define atslib_sigemptyset sigemptyset
#define atslib_sigfillset sigfillset

/* ****** ****** */

#define atslib_signal signal

/* ****** ****** */

#define atslib_sigaction sigaction
#define atslib_sigaction_null(sgn, act) \
  atslib_sigaction(sgn, act, (atslib_sigaction_struct*)0)

/* ****** ****** */

#define atslib_sigset sigset
#define atslib_sighold sighold
#define atslib_sigignore sigignore
#define atslib_sigrelse sigrelse

/* ****** ****** */

#define atslib_kill kill
#define atslib_killpg killpg
#define atslib_raise raise

/* ****** ****** */

#define atslib_sigwait sigwait

/* ****** ****** */

#define atslib_sigpause sigpause
#define atslib_sigsuspend sigsuspend

/* ****** ****** */

#define atslib_sigpending sigpending
#define atslib_siginterrupt siginterrupt

/* ****** ****** */

#define atslib_psignal psignal

/* ****** ****** */

/*
extern
char* strsignal (int signum) ; // declared in <string.h>
*/
#define atslib_strsignal strsignal

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_SIGNAL

/* ****** ****** */

/* end of [signal.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/malloc.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_MALLOC
#define ATSLIB_LIBC_CATS_MALLOC

/* ****** ****** */

#include <malloc.h>

/* ****** ****** */

#define atslib_mallopt mallopt
#define atslib_malloc_trim malloc_trim
#define atslib_malloc_usable_size malloc_usable_size
#define atslib_malloc_stats malloc_stats
#define atslib_malloc_get_state malloc_get_state
#define atslib_malloc_set_state malloc_set_state

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_MALLOC

/* ****** ****** */

/* end of [malloc.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/alloca.atxt
** Time of generation: Wed Sep 23 16:09:10 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: February, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_ALLOCA
#define ATSLIB_LIBC_CATS_ALLOCA

/* ****** ****** */

#include <alloca.h>

/* ****** ****** */
//
#define atslib_alloca(bsz) alloca(bsz)
//
/* ****** ****** */
//
#define atslib_ptr_alloca_tsz(tsz) alloca(tsz)
//
#define atslib_array_ptr_alloca_tsz(asz, tsz) alloca((asz)*(tsz))
//
/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_ALLOCA

/* ****** ****** */

/* end of [alloca.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/math.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_MATH
#define ATSLIB_LIBC_CATS_MATH

/* ****** ****** */

#include <math.h>

/* ****** ****** */

#define atslib_isfinite_float isfinite
#define atslib_isfinite_double isfinite
#define atslib_isfinite_ldouble isfinite

/* ****** ****** */

#define atslib_isnormal_float isnormal
#define atslib_isnormal_double isnormal
#define atslib_isnormal_ldouble isnormal

/* ****** ****** */

#define atslib_isinf_float isinf
#define atslib_isinf_double isinf
#define atslib_isinf_ldouble isinf

/* ****** ****** */

#define atslib_isnan_float isnan
#define atslib_isnan_double isnan
#define atslib_isnan_ldouble isnan

/* ****** ****** */

#define atslib_fpclassify_float fpclassify
#define atslib_fpclassify_double fpclassify
#define atslib_fpclassify_ldouble fpclassify

/* ****** ****** */

#define atslib_ceil_float ceilf
#define atslib_ceil_double ceil
#define atslib_ceil_ldouble ceill

/* ****** ****** */

#define atslib_floor_float floorf
#define atslib_floor_double floor
#define atslib_floor_ldouble floorl

/* ****** ****** */

#define atslib_round_float roundf
#define atslib_round_double round
#define atslib_round_ldouble roundl

/* ****** ****** */

#define atslib_trunc_float truncf
#define atslib_trunc_double trunc
#define atslib_trunc_ldouble truncl

/* ****** ****** */

#define atslib_fmod_float fmodf
#define atslib_fmod_double fmod
#define atslib_fmod_ldouble fmodl

/* ****** ****** */

#define atslib_fmax_float fmaxf
#define atslib_fmax_double fmax
#define atslib_fmax_ldouble fmaxl

/* ****** ****** */

#define atslib_fmin_float fminf
#define atslib_fmin_double fmin
#define atslib_fmin_ldouble fminl

/* ****** ****** */

#define atslib_fdim_float fdimf
#define atslib_fdim_double fdim
#define atslib_fdim_ldouble fdiml

/* ****** ****** */

#define atslib_fma_float fmaf
#define atslib_fma_double fma
#define atslib_fma_ldouble fmal

/* ****** ****** */

#define atslib_sqrt_float sqrtf
#define atslib_sqrt_double sqrt
#define atslib_sqrt_ldouble sqrtl

/* ****** ****** */

#define atslib_cbrt_float cbrtf
#define atslib_cbrt_double cbrt
#define atslib_cbrt_ldouble cbrtl

/* ****** ****** */

#define atslib_pow_float powf
#define atslib_pow_double pow
#define atslib_pow_ldouble powl

/* ****** ****** */

#define atslib_exp_float expf
#define atslib_exp_double exp
#define atslib_exp_ldouble expl

/* ****** ****** */
//
#define atslib_log_float logf
#define atslib_log_double log
#define atslib_log_ldouble logl
//
#define atslib_log10_float log10f
#define atslib_log10_double log10
#define atslib_log10_ldouble log10l
//
/* ****** ****** */
//
#define atslib_sin_float sinf
#define atslib_sin_double sin
#define atslib_sin_ldouble sinl
//
#define atslib_cos_float cosf
#define atslib_cos_double cos
#define atslib_cos_ldouble cosl
//
#define atslib_tan_float tanf
#define atslib_tan_double tan
#define atslib_tan_ldouble tanl
//
/* ****** ****** */
//
#define atslib_asin_float asinf
#define atslib_asin_double asin
#define atslib_asin_ldouble asinl
//
#define atslib_acos_float acosf
#define atslib_acos_double acos
#define atslib_acos_ldouble cosl
//
#define atslib_atan_float atanf
#define atslib_atan_double atan
#define atslib_atan_ldouble atanl
//
#define atslib_atan2_float atan2f
#define atslib_atan2_double atan2
#define atslib_atan2_ldouble atan2l
//
/* ****** ****** */
//
#define atslib_sinh_float sinhf
#define atslib_sinh_double sinh
#define atslib_sinh_ldouble sinhl
//
#define atslib_cosh_float coshf
#define atslib_cosh_double cosh
#define atslib_cosh_ldouble coshl
//
#define atslib_tanh_float tanhf
#define atslib_tanh_double tanh
#define atslib_tanh_ldouble tanhl
//
/* ****** ****** */

#define atslib_asinh_float asinhf
#define atslib_asinh_double asinh
#define atslib_asinh_ldouble asinhl
//
#define atslib_acosh_float acoshf
#define atslib_acosh_double acosh
#define atslib_acosh_ldouble acoshl
//
#define atslib_atanh_float atanhf
#define atslib_atanh_double atanh
#define atslib_atanh_ldouble atanhl
//
/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_MATH

/* ****** ****** */

/* end of [math.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/errno.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_ERRNO
#define ATSLIB_LIBC_CATS_ERRNO

/* ****** ****** */

#include <errno.h>

/* ****** ****** */

typedef int errno_t ;

/* ****** ****** */

#define ENONE 0

/* ****** ****** */

#define atslib_the_errno_get() (errno)
#define atslib_the_errno_set(eno) (errno = (eno))
#define atslib_the_errno_reset() (errno = ENONE)

ATSinline()
atstype_bool
atslib_the_errno_test(errno_t eno)
{
  return (errno==(eno)) ? atsbool_true : atsbool_false ;
}

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_ERRNO

/* ****** ****** */

/* end of [errno.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/dirent.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_DIRENT
#define ATSLIB_LIBC_CATS_DIRENT

/* ****** ****** */

#include <sys/types.h>
#include <dirent.h> // HX: after sys/types

/* ****** ****** */

#include "share/H/pats_atslib.h"

/* ****** ****** */

typedef DIR atslib_DIR_type ;
typedef struct dirent atslib_dirent_type ;

/* ****** ****** */

#define atslib_direntp_free(x) atspre_mfree_gc(x)

/* ****** ****** */

#define atslib_dirent_get_d_ino(ent) (((atslib_dirent_type*)ent)->d_ino)
#define atslib_dirent_get_d_name(ent) (((atslib_dirent_type*)ent)->d_name)

/* ****** ****** */

#define atslib_direntp_get_d_name(entp) (((atslib_dirent_type*)entp)->d_name)

/* ****** ****** */

#define atslib_alphasort alphasort
#define atslib_versionsort versionsort

/* ****** ****** */

#define atslib_opendir opendir

/* ****** ****** */

#define atslib_closedir closedir

/* ****** ****** */

#define atslib_readdir readdir
#define \
atslib_readdir_r(dirp, ent, res) \
  readdir_r((DIR*)dirp, (atslib_dirent_type*)ent, (atslib_dirent_type**)res)

/* ****** ****** */

#define \
atslib_scandir(dirp, namelst, filter, compar) \
  scandir((char*)dirp, (atslib_dirent_type***)namelst, (void*)filter, (void*)compar)

/* ****** ****** */

#define atslib_rewinddir rewinddir

/* ****** ****** */

#define atslib_seekdir seekdir
#define atslib_telldir telldir

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_DIRENT

/* ****** ****** */

/* end of [dirent.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/string.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_STRING
#define ATSLIB_LIBC_CATS_STRING

/* ****** ****** */

#include <errno.h>
#include <string.h>

/* ****** ****** */

#define atslib_strcmp strcmp
#define atslib_strncmp strncmp

/* ****** ****** */

#define atslib_strcoll strcoll

/* ****** ****** */

#define atslib_strspn strspn
#define atslib_strcspn strcspn

/* ****** ****** */

#define atslib_strlen strlen
#define atslib_strnlen strnlen

/* ****** ****** */

#define atslib_strcat strcat
#define atslib_strcat_unsafe strcat
#define atslib_strncat_unsafe strncat

/* ****** ****** */

#define atslib_strcpy strcpy
#define atslib_strcpy_unsafe strcpy
#define atslib_strncpy_unsafe strncpy

/* ****** ****** */

#define atslib_strdup strdup
#define atslib_strndup strndup
#define atslib_strdup_free atsruntime_mfree_libc

#define atslib_strdupa strdupa
#define atslib_strndupa strndupa
#define atslib_strdupa_free atsruntime_afree_libc

/* ****** ****** */

#define atslib_strfry strfry

/* ****** ****** */

#define atslib_memcpy memcpy
#define atslib_memcpy_unsafe memcpy

/* ****** ****** */

#define atslib_memccpy_unsafe memccpy

/* ****** ****** */

#define atslib_mempcpy mempcpy
#define atslib_mempcpy_unsafe mempcpy

/* ****** ****** */

#define atslib_memset_unsafe memset

/* ****** ****** */

#define atslib_memmove_unsafe memmove

/* ****** ****** */

#define atslib_strerror strerror
#define atslib_strerror_r strerror_r

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_strdup_gc
  (atstype_string src)
{
  char *dst ;
  size_t len, len1 ;
  len = atslib_strlen((char*)src) ;
  len1 = len + 1;
  dst = atspre_malloc_gc(len1) ;
  return atslib_memcpy(dst, src, len1) ;
} // end of [atslib_strdup_gc]

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_STRING

/* ****** ****** */

/* end of [string.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/float.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: October, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_FLOAT
#define ATSLIB_LIBC_CATS_FLOAT

/* ****** ****** */

#include <float.h>

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_FLOAT

/* ****** ****** */

/* end of [float.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/stdio.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_STDIO
#define ATSLIB_LIBC_CATS_STDIO

/* ****** ****** */

#include <stdio.h>
/*
extern
void perror (const char* str) ; // in [stdio.h]
*/
extern void exit (int status) ; // in [stdlib.h]

/* ****** ****** */

#include "share/H/pats_atslib.h"

/* ****** ****** */

#define \
atslib_clearerr(p) clearerr(((FILE*)p))

/* ****** ****** */

#define atslib_fopen fopen
#define atslib_fopen_ref_exn atslib_fopen_exn

/* ****** ****** */

#define atslib_fclose fclose
#define atslib_fclose0 atslib_fclose
#define atslib_fclose1 atslib_fclose
#define atslib_fclose0_exn atslib_fclose_exn
#define atslib_fclose1_exn atslib_fclose_exn

/*
#define atslib_fclose_stdin() atslib_fclose_exn(stdin)
#define atslib_fclose_stdout() atslib_fclose_exn(stdout)
#define atslib_fclose_stderr() atslib_fclose_exn(stderr)
*/

/* ****** ****** */
//
#define atslib_fflush0_exn atslib_fflush_exn
//
#define atslib_fflush_all() atslib_fclose_exn((FILE*)0)
#define atslib_fflush_stdout() atslib_fclose_exn(stdout)
//
/* ****** ****** */

#define atslib_fileno fileno
#define atslib_fileno0 atslib_fileno
#define atslib_fileno1 atslib_fileno

/* ****** ****** */

#define atslib_fdopen fdopen

/* ****** ****** */

#define \
atslib_feof(p) feof(((FILE*)p))
#define atslib_feof0 atslib_feof
#define atslib_feof1 atslib_feof

/* ****** ****** */

#define \
atslib_ferror(p) ferror(((FILE*)p))
#define atslib_ferror0 atslib_ferror
#define atslib_ferror1 atslib_ferror

/* ****** ****** */

#define atslib_fgetc fgetc
#define atslib_fgetc0 atslib_fgetc
#define atslib_fgetc1 atslib_fgetc

/* ****** ****** */

#define atslib_getchar getchar
#define atslib_getchar0 atslib_getchar
#define atslib_getchar1 atslib_getchar

/* ****** ****** */

#define atslib_fputc fputc
#define atslib_fputc0_int atslib_fputc
#define atslib_fputc0_char(c, fp) atslib_fputc((int)c, fp)
#define atslib_fputc1_int atslib_fputc
#define atslib_fputc1_char(c, fp) atslib_fputc((int)c, fp)

#define atslib_fputc0_exn_int atslib_fputc_exn
#define atslib_fputc0_exn_char atslib_fputc_exn

/* ****** ****** */

#define atslib_putchar putchar
#define atslib_putchar0 atslib_putchar
#define atslib_putchar1 atslib_putchar

/* ****** ****** */

#define atslib_fgets fgets
#define atslib_fgets0 atslib_fgets
#define atslib_fgets1 atslib_fgets
#define atslib_fgets1_err atslib_fgets
#define atslib_fgets0_gc atslib_fgets_gc
#define atslib_fgets1_gc atslib_fgets_gc

/* ****** ****** */

#define atslib_fputs fputs
#define atslib_fputs0 atslib_fputs
#define atslib_fputs1 atslib_fputs
#define atslib_fputs0_exn atslib_fputs_exn
#define atslib_fputs1_exn atslib_fputs_exn

/* ****** ****** */

#define atslib_puts puts

/* ****** ****** */

#define atslib_fread fread
#define atslib_fread0 atslib_fread
#define atslib_fread1 atslib_fread

/* ****** ****** */

#define atslib_fwrite fwrite
#define atslib_fwrite0 atslib_fwrite
#define atslib_fwrite1 atslib_fwrite

/* ****** ****** */

#define atslib_fseek fseek
#define atslib_fseek0 atslib_fseek
#define atslib_fseek1 atslib_fseek

/* ****** ****** */

#define atslib_ftell ftell
#define atslib_ftell0 atslib_ftell
#define atslib_ftell1 atslib_ftell

/* ****** ****** */

#define atslib_perror perror

/* ****** ****** */

#define atslib_popen popen

/* ****** ****** */

#define atslib_pclose0_exn atslib_pclose_exn
#define atslib_pclose1_exn atslib_pclose_exn

/* ****** ****** */

#define atslib_rewind rewind
#define atslib_rewind0 atslib_rewind
#define atslib_rewind1 atslib_rewind

/* ****** ****** */

#define atslib_tmpfile tmpfile
#define atslib_tmpfile_ref_exn atslib_tmpfile_exn

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_STDIO

/* ****** ****** */

/* end of [stdio.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/dlfcn.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: December, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_DLFCN
#define ATSLIB_LIBC_CATS_DLFCN

/* ****** ****** */

#include <dlfcn.h>

/* ****** ****** */

#define atslib_dlopen dlopen
#define atslib_dlclose dlclose

/* ****** ****** */

#define atslib_dlerror dlerror

/* ****** ****** */

#define atslib_dlsym dlsym

/* ****** ****** */

#define atslib_dladdr dladdr
#define atslib_dlvsym dlvsym

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_DLFCN

/* ****** ****** */

/* end of [dlfcn.cats] */
(*
** HX-2013-09:
** This file contains toplevel defines
*)
(* ****** ****** *)
//
(*
** Various defines for packages
*)
#include "./HATS/atspre_define_pkgreloc.hats"
//
(* ****** ****** *)

(* end of [atspre_define.hats] *)
(*
** This is mostly for staloading
** template code in ATSLIB/prelude
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// AuthorEmail: gmhwxiATgmailCOM
//
(* ****** ****** *)

#ifndef SHARE_ATSPRE_STALOAD
#define SHARE_ATSPRE_STALOAD 1

(* ****** ****** *)
//
#define
PATSPRE_targetloc "$PATSHOME/prelude"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/basics.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/pointer.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/integer.dats"
staload _ = "{$PATSPRE}/DATS/integer_ptr.dats"
staload _ = "{$PATSPRE}/DATS/integer_fixed.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/char.dats"
staload _ = "{$PATSPRE}/DATS/bool.dats"
staload _ = "{$PATSPRE}/DATS/float.dats"
//
(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/tuple.dats"

(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/memory.dats"

(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/string.dats"
staload _ = "{$PATSPRE}/DATS/strptr.dats"

(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/reference.dats"

(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/filebas.dats"
staload _ = "{$PATSPRE}/DATS/intrange.dats"

(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/gorder.dats"
staload _ = "{$PATSPRE}/DATS/gnumber.dats"
staload _ = "{$PATSPRE}/DATS/grandom.dats"

(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/list.dats"
staload _ = "{$PATSPRE}/DATS/list_vt.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/option.dats"
staload _ = "{$PATSPRE}/DATS/option_vt.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/array.dats"
staload _ = "{$PATSPRE}/DATS/arrayptr.dats"
staload _ = "{$PATSPRE}/DATS/arrayref.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/matrix.dats"
staload _ = "{$PATSPRE}/DATS/matrixptr.dats"
staload _ = "{$PATSPRE}/DATS/matrixref.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/stream.dats"
staload _ = "{$PATSPRE}/DATS/stream_vt.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/gprint.dats"
//
staload _ = "{$PATSPRE}/DATS/tostring.dats"
//
(* ****** ****** *)
//
staload UNSAFE = "{$PATSPRE}/SATS/unsafe.sats"
//
staload _(*UNSAFE*) = "{$PATSPRE}/DATS/unsafe.dats"
//
(* ****** ****** *)

staload _(*CHECKAST*) = "{$PATSPRE}/DATS/checkast.dats"

(* ****** ****** *)

#endif // end of [#ifndef SHARE_ATSPRE_STALOAD]

(* ****** ****** *)

(* end of [atspre_staload.hats] *)
(*
** This is mostly for
** staloading ATSLIB/libats/ML
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// AuthorEmail: gmhwxiATgmailCOM
//
(* ****** ****** *)

#ifndef SHARE_ATSPRE_STALOAD_LIBATS_ML
#define SHARE_ATSPRE_STALOAD_LIBATS_ML 1

(* ****** ****** *)

#define
PATSLIBATS_targetloc "$PATSHOME/libats"

(* ****** ****** *)

staload "{$PATSLIBATS}/ML/SATS/basis.sats"

(* ****** ****** *)
//
staload "{$PATSLIBATS}/ML/SATS/list0.sats"
//
staload "{$PATSLIBATS}/ML/SATS/option0.sats"
//
staload "{$PATSLIBATS}/ML/SATS/array0.sats"
//
staload "{$PATSLIBATS}/ML/SATS/matrix0.sats"
//
staload "{$PATSLIBATS}/ML/SATS/string.sats"
staload "{$PATSLIBATS}/ML/SATS/strarr.sats"
//
staload "{$PATSLIBATS}/ML/SATS/filebas.sats"
staload "{$PATSLIBATS}/ML/SATS/intrange.sats"
//
staload "{$PATSLIBATS}/ML/SATS/stdlib.sats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/list0.dats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/option0.dats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/array0.dats"
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/matrix0.dats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/string.dats"
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/strarr.dats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/filebas.dats"
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/intrange.dats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/stdlib.dats"
//
(* ****** ****** *)
//
staload "{$PATSLIBATS}/ML/SATS/funmap.sats"
//
staload "{$PATSLIBATS}/ML/SATS/funset.sats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/funmap.dats"
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/funset.dats"
//
(* ****** ****** *)
//
staload "{$PATSLIBATS}/ML/SATS/hashtblref.sats"
//
staload _(*anon*) = "{$PATSLIBATS}/DATS/hashfun.dats"
staload _(*anon*) = "{$PATSLIBATS}/DATS/linmap_list.dats"
staload _(*anon*) = "{$PATSLIBATS}/DATS/hashtbl_chain.dats"
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/hashtblref.dats"
//
(* ****** ****** *)

#endif // SHARE_ATSPRE_STALOAD_LIBATS_ML

(* ****** ****** *)

(* end of [atslib_staload_libats_ML.hats] *)
(*
** For staloading
** some commonly used libc packages
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// AuthorEmail: gmhwxiATgmailCOM
//
(* ****** ****** *)

#ifndef SHARE_ATSLIB_STALOAD_LIBC
#define SHARE_ATSLIB_STALOAD_LIBC 1

(* ****** ****** *)

#define
PATSLIBC_targetloc "$PATSHOME/libc"

(* ****** ****** *)

staload ERRNO = "{$PATSLIBC}/SATS/errno.sats"
staload _(*ERRNO*) = "{$PATSLIBC}/DATS/errno.dats"

(* ****** ****** *)

staload DIRENT = "{$PATSLIBC}/SATS/dirent.sats"
staload _(*DIRENT*) = "{$PATSLIBC}/DATS/dirent.dats"

(* ****** ****** *)

staload MATH = "{$PATSLIBC}/SATS/float.sats"
staload _(*MATH*) = "{$PATSLIBC}/DATS/float.dats"

(* ****** ****** *)

staload MATH = "{$PATSLIBC}/SATS/math.sats"
staload _(*MATH*) = "{$PATSLIBC}/DATS/math.dats"

(* ****** ****** *)

staload SIGNAL = "{$PATSLIBC}/SATS/signal.sats"

(* ****** ****** *)

staload STDDEF = "{$PATSLIBC}/SATS/stddef.sats"

(* ****** ****** *)

staload STDIO = "{$PATSLIBC}/SATS/stdio.sats"
staload _(*STDIO*) = "{$PATSLIBC}/DATS/stdio.dats"

(* ****** ****** *)

staload STDLIB = "{$PATSLIBC}/SATS/stdlib.sats"
staload _(*STDLIB*) = "{$PATSLIBC}/DATS/stdlib.dats"

(* ****** ****** *)

staload STRING = "{$PATSLIBC}/SATS/string.sats"
staload _(*STRING*) = "{$PATSLIBC}/DATS/string.dats"
staload STRINGS = "{$PATSLIBC}/SATS/strings.sats"
staload _(*STRINGS*) = "{$PATSLIBC}/DATS/strings.dats"

(* ****** ****** *)

staload TIME = "{$PATSLIBC}/SATS/time.sats"
staload _(*TIME*) = "{$PATSLIBC}/DATS/time.dats"

(* ****** ****** *)

staload UNISTD = "{$PATSLIBC}/SATS/unistd.sats"
staload _(*UNISTD*) = "{$PATSLIBC}/DATS/unistd.dats"

(* ****** ****** *)

#endif // SHARE_ATSLIB_STALOAD_LIBC

(* ****** ****** *)

(* end of [atslib_staload_libc.hats] *)
(*
** For ATS2-package relocation
*)
(* ****** ****** *)
//
// HX-2014-08:
// PATSHOME is pre-defined
// PATSHOMERELOC is pre-defined
//
#define
PATSHOME_targetloc "$PATSHOME"
#define
PATSHOMERELOC_targetloc "$PATSHOMERELOC"
//
(* ****** ****** *)
//
#define
PATSPRE_targetloc "$PATSHOME/prelude"
#define
PATSLIBC_targetloc "$PATSHOME/libc"
#define
PATSLIBATS_targetloc "$PATSHOME/libats"
//
(* ****** ****** *)
//
#define
ATSLANGWEB "http://www.ats-lang.org"
#define
ATSLANGWEBLIB "http://www.ats-lang.org/LIBRARY"
//
(* ****** ****** *)
//
#define
PCRE_sourceloc "$ATSLANGWEBLIB/contrib/pcre"
#define
PCRE_targetloc "$PATSHOMERELOC/contrib/pcre"
//
(* ****** ****** *)
//
#define
LIBGMP_sourceloc "$ATSLANGWEBLIB/contrib/libgmp"
#define
LIBGMP_targetloc "$PATSHOMERELOC/contrib/libgmp"
//
(* ****** ****** *)
//
#define
ZLOG_targetloc "$PATSHOMERELOC/contrib/zlog"
//
(* ****** ****** *)
//
#define
ZEROMQ_targetloc "$PATSHOMERELOC/contrib/zeromq"
//
(* ****** ****** *)
//
#define
JSONC_sourceloc "$ATSLANGWEBLIB/contrib/json-c"
#define
JSONC_targetloc "$PATSHOMERELOC/contrib/json-c"
//
(* ****** ****** *)
//
#define
HIREDIS_sourceloc "$ATSLANGWEBLIB/contrib/hiredis"
#define
HIREDIS_targetloc "$PATSHOMERELOC/contrib/hiredis"
//
(* ****** ****** *)
//
#define
OPENSSL_sourceloc "$ATSLANGWEBLIB/contrib/OpenSSL"
#define
OPENSSL_targetloc "$PATSHOMERELOC/contrib/OpenSSL"
//
(* ****** ****** *)
//
#define
LIBCURL_sourceloc "$ATSLANGWEBLIB/contrib/libcurl"
#define
LIBCURL_targetloc "$PATSHOMERELOC/contrib/libcurl"
//
(* ****** ****** *)
//
#define
GTK_sourceloc "$ATSLANGWEBLIB/contrib/GTK"
#define
GTK_targetloc "$PATSHOMERELOC/contrib/GTK"
//
(* ****** ****** *)
//
#define
GLIB_sourceloc "$ATSLANGWEBLIB/contrib/glib"
#define
GLIB_targetloc "$PATSHOMERELOC/contrib/glib"
//
(* ****** ****** *)
//
#define
CAIRO_sourceloc "$ATSLANGWEBLIB/contrib/cairo"
#define
CAIRO_targetloc "$PATSHOMERELOC/contrib/cairo"
//
(* ****** ****** *)
//
#define
JNI_targetloc "$PATSHOMERELOC/contrib/JNI"
//
(* ****** ****** *)
//
#define
SDL2_targetloc "$PATSHOMERELOC/contrib/SDL2"
//
(* ****** ****** *)
//
#define
GUROBI_targetloc "$PATSHOMERELOC/contrib/gurobi"
//
(* ****** ****** *)
//
#define
KERNELATS_targetloc "$PATSHOMERELOC/contrib/kernelats"
//
(* ****** ****** *)
//
#define
LIBATSCC_targetloc
"$PATSHOMERELOC/contrib/libatscc"
//
#define
LIBATSCC2JS_targetloc
"$PATSHOMERELOC/contrib/libatscc/libatscc2js"
//
#define
LIBATSCC2ERL_targetloc
"$PATSHOMERELOC/contrib/libatscc/libatscc2erl"
//
#define
LIBATSCC2PHP_targetloc
"$PATSHOMERELOC/contrib/libatscc/libatscc2php"
//
#define
LIBATSCC2PL_targetloc
"$PATSHOMERELOC/contrib/libatscc/libatscc2pl"
//
#define
LIBATSCC2PY_targetloc
"$PATSHOMERELOC/contrib/libatscc/libatscc2py"
//
(* ****** ****** *)
//
// HX-2014-05-12:
// This is for backward compatibility
//
#define
LIBATSHWXI_sourceloc "$ATSLANGWEBLIB/contrib/libats-/hwxi"
#define
LIBATSHWXI_targetloc "$PATSHOMERELOC/contrib/libats-/hwxi"
//
#define
LIBATS_HWXI_sourceloc "$ATSLANGWEBLIB/contrib/libats-/hwxi"
#define
LIBATS_HWXI_targetloc "$PATSHOMERELOC/contrib/libats-/hwxi"
//
(* ****** ****** *)
//
// For applying ATS to AVR programming
//
#define AVR_sourceloc "$ATSLANGWEBLIB/contrib/AVR"
#define AVR_targetloc "$PATSHOMERELOC/contrib/AVR"
//
#define ARDUINO_sourceloc "$ATSLANGWEBLIB/contrib/arduino"
#define ARDUINO_targetloc "$PATSHOMERELOC/contrib/arduino"
//
(* ****** ****** *)
//
// For applying ATS to Linux kernel programming
//
#define LINUX_sourceloc "$ATSLANGWEBLIB/contrib/linux"
#define LINUX_targetloc "$PATSHOMERELOC/contrib/linux"
//
(* ****** ****** *)

#define EXTSOLVE_sourceloc "$ATSLANGWEBLIB/contrib/extsolve"
#define EXTSOLVE_targetloc "$PATSHOMERELOC/contrib/extsolve"

(* ****** ****** *)

(* end of [atspre_define_pkgreloc.hats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

#ifndef PATS_ATSLIB_H
#define PATS_ATSLIB_H

/* ****** ****** */

#include <errno.h> // for [errno]
#include <stdio.h> // for [perror]

/* ****** ****** */

#define \
ATSLIBfailexit(cmd) \
do { \
  fprintf(stderr, "exit(ATSLIB): [%s] failed\n", cmd) ; exit(1) ; \
} while (0) \

/* ****** ****** */

#define \
ATSLIBfailexit2(cmd) \
do { \
  perror(cmd) ; \
  fprintf(stderr, "exit(ATSLIB): [%s] failed\n", cmd) ; exit(1) ; \
} while (0) \

/* ****** ****** */

#endif // ifndef PATS_ATSLIB_H

/* ****** ****** */

/* end of [pats_atslib.h] */
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: March, 2013
//
(* ****** ****** *)
//
// HX-2013-03:
// lmacrodef: local macro definitions
//
(* ****** ****** *)
//
macdef :+= (x, a) = let val v = ,(x) in ,(x) := ,(a) + v end
macdef :-= (x, a) = let val v = ,(x) in ,(x) := ,(a) - v end
macdef :*= (x, a) = let val v = ,(x) in ,(x) := ,(a) * v end
macdef :/= (x, a) = let val v = ,(x) in ,(x) := ,(a) / v end
//
(* ****** ****** *)
//
macdef :=+ (x, a) = let val v = ,(x) in ,(x) := v + ,(a) end
macdef :=- (x, a) = let val v = ,(x) in ,(x) := v - ,(a) end
macdef :=* (x, a) = let val v = ,(x) in ,(x) := v * ,(a) end
macdef :=/ (x, a) = let val v = ,(x) in ,(x) := v / ,(a) end
//
(* ****** ****** *)

(*

//
// HX-2012-08:
//
// this example makes use of recursive macrodef
//
local

macrodef
rec
auxlist
  (xs, y) =
(
//
if iscons! (xs) then
  `(print ,(car! xs); ,(auxlist (cdr! xs, y)))
else y // end of [if]
//
) // end of [auxlist]

in // in of [local]

macdef
print_mac (x) =
,(
  if islist! (x) then auxlist (x, `()) else `(print ,(x))
) // end of [print_mac]

macdef
println_mac (x) =
,(
  if islist! (x)
    then auxlist (x, `(print_newline())) else `(print ,(x))
  // end of [if]
) // end of [println_mac]

end // end of [local]

*)

(* ****** ****** *)

(* end of [lmacrodef.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: July, 2012
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_gen.sats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)
//
fun
{a:t0p}
gidentity (x: INV(a)):<> a
//
fun
{a:vt0p}
gidentity_vt (x: INV(a)):<> a
//
(* ****** ****** *)
//
fun
{a:t0p}
gcopy_val (x: INV(a)):<> a
//
fun
{a:vt0p}
gcopy_ref (x: &INV(a)):<!wrt> a
//
(* ****** ****** *)

fun
{a:vt0p}
gfree_val (x: INV(a)):<!wrt> void

(* ****** ****** *)

fun
{a:vt0p}
ginit_ref (x: &a? >> a):<!wrt> void

(* ****** ****** *)

fun
{a:vt0p}
gclear_ref (x: &a >> a?):<!wrt> void

(* ****** ****** *)
//
fun
{a:t0p}
gequal_val_val (x: a, y: a):<> bool
//
fun
{a:vt0p}
gequal_ref_ref (x: &INV(a), y: &a):<> bool
//
(* ****** ****** *)

fun{a:t0p}
tostring_val (x: a):<> string
fun{a:vt0p}
tostring_ref (x: &INV(a)):<> string

(* ****** ****** *)

fun{a:t0p}
tostrptr_val (x: a):<!wrt> Strptr1
fun{a:vt0p}
tostrptr_ref (x: &INV(a)):<!wrt> Strptr1

(* ****** ****** *)

fun{a:t0p}
fprint_val (out: FILEref, x: a): void
fun{a:vt0p}
fprint_ref (out: FILEref, x: &INV(a)): void

(* ****** ****** *)

(*
//
fun{a:t0p}
print_val (x: a): void // = fprint_val (stdout_ref, x)
fun{a:t0p}
prerr_val (x: a): void // = fprint_val (stderr_ref, x)
//
fun{a:vt0p}
print_ref (x: &INV(a)): void // = fprint_ref (stdout_ref, x)
fun{a:vt0p}
prerr_ref (x: &INV(a)): void // = fprint_ref (stderr_ref, x)
//
*)

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_gen.sats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [basics_gen.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: May, 2012
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

(*
** HX: short form
*)
//
// [orelse] and [andalso] are declared as infix ops
//
macdef
orelse (x, y) = (if ,(x) then true else ,(y)): bool
macdef
andalso (x, y) = (if ,(x) then ,(y) else false): bool
//
(* ****** ****** *)

macdef assign (lv, rv) = ,(lv) := ,(rv)

(* ****** ****** *)

macdef exitloc (x) = exit_errmsg (,(x), $mylocation)

(* ****** ****** *)

macdef assertloc (x) = assert_errmsg (,(x), $mylocation)

(* ****** ****** *)
//
macdef
assertlocmsg
  (x, msg) = assert_errmsg2 (,(x), $mylocation, ,(msg))
macdef
assertmsgloc
  (x, msg) = assert_errmsg2 (,(x), ,(msg), $mylocation)
//
(* ****** ****** *)

macdef ignoret (x) = let val x = ,(x) in (*nothing*) end

(* ****** ****** *)

macdef foldret (x) = let val x = ,(x) in fold@ (x); x end

(* ****** ****** *)
//
macdef showtype (x) = $showtype ,(x)
//
macdef showview (x) = pridentity_v ($showtype ,(x))
//
macdef showvtype (x) = pridentity_vt ($showtype ,(x))
macdef showviewtype (x) = pridentity_vt ($showtype ,(x))
//
(* ****** ****** *)

(* end of [macrodef.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: September, 2011
//
(* ****** ****** *)
//
#define VERBOSE_FIXITY 0
(*
#define VERBOSE_FIXITY 1 (* used in [prelude/fixity.ats] *)
*)
//
(* ****** ****** *)
//
#define VERBOSE_PRELUDE 0
(*
#define VERBOSE_PRELUDE 1 (* mainly for the purpose of debugging *)
*)
//
(* ****** ****** *)

(* end of [params.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: hwxiATcsDOTbuDOTedu
//
// This one was
// there at the very beginning of ATS
//
(* ****** ****** *)
//
(*
HX: fixity declarations
*)
#include "prelude/params.hats"
//
(* ****** ****** *)

#if VERBOSE_FIXITY #then
#print "Loading [fixity.ats] starts!\n"
#endif // end of [VERBOSE_FIXITY]

(* ****** ****** *)
//
(*
prefix 00 ! (* static *)
*)
//
prefix 99 ! (* dynamic *)
//
(* ****** ****** *)

(*
prefix 81 ID (* identity *)
*)

(* ****** ****** *)

(*
postfix 80 .lab // dynamic
postfix 80 ->lab // dynamic
*)

(* ****** ****** *)

(*
prefix 79 & // dynamic
*)

(* ****** ****** *)

(*
infixl 70 app
*)

(* ****** ****** *)

(*
postfix 69 ?
*)

(* ****** ****** *)
//
// HX-2015-08-04:
// mostly following the Fortran convention
//
(* ****** ****** *)

infixr 61 ** (*exp*)

(* ****** ****** *)
//
// multiplicative
//
infixl 60 * / % mod
//
(*
infixl 60 nmul ndiv nmod
*)
//
(* ****** ****** *)

prefix 51 ~ (*negative*)

(* ****** ****** *)
//
infixl 50 + - (*additive*)
//
(*
infixr (+) ++ // concatenative
*)
//
(* ****** ****** *)

infixl 41 asl asr
infixl 41 lsl lsr

(* ****** ****** *)
//
infix 40 < <= > >=
//
(*
//
// HX-2012-07: removed
//
infixl ( < ) ilt flt plt ult
infixl ( <= ) ilte flte plte ulte
infixl ( > ) igt fgt pgt ugt
infixl ( >= ) igte fgte pgte ugte
*)
//
(* ****** ****** *)

infixr 40 :: @

(* ****** ****** *)

infix 30 = == != <>

(* ****** ****** *)

(*
//
// HX-2012-07: removed
//
infix ( = ) ieq feq peq ueq
infix ( <> ) ineq fneq pneq uneq
*)

(* ****** ****** *)

infixl 21 &&
infixl ( && ) andalso land

(* ****** ****** *)

infixl 20 ||
infixl ( || ) orelse lor lxor

(* ****** ****** *)

infixr 10 ->

(* ****** ****** *)

infix 0 := // HX: assign
infix 0 :=: // HX: exchange

(* ****** ****** *)

infixl 0 << (* g0int_asl, g0uint_lsl *)
infixr 0 >> (* g0int_asr, g0uint_lsr *)

(* ****** ****** *)

prefix 0 ++ -- // inc and dec
prefix 0 !++ --! // getinc and decget
infixr 0 =++ --= // setinc and decset

(* ****** ****** *)

infix 0 :+= :-= :*= :/= // x:=x+a, x:=x-a, ...
infix 0 :=+ :=- :=* :=/ // x:=a+x, x:=a-x, ...

(* ****** ****** *)

#if VERBOSE_FIXITY #then
#print "Loading [fixity.ats] finishes!\n"
#endif // end of [VERBOSE_FIXITY]

(* end of [fixity.ats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: September, 2011
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_pre.sats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)
//
// HX:
// some built-in static boolean constants
//
stacst true_bool : bool and false_bool : bool
stadef true = true_bool and false = false_bool
//
stacst neg_bool
  : bool -> bool (* boolean negation *)
stadef ~ = neg_bool // overloaded
//
stacst add_bool_bool
  : (bool, bool) -> bool (* disjunction *)
stacst mul_bool_bool
  : (bool, bool) -> bool (* conjunction *)
stadef + = add_bool_bool and * = mul_bool_bool
stadef || = add_bool_bool and && = mul_bool_bool
//
stacst lt_bool_bool : (bool, bool) -> bool
stacst lte_bool_bool : (bool, bool) -> bool
stacst gt_bool_bool : (bool, bool) -> bool
stacst gte_bool_bool : (bool, bool) -> bool
stadef < = lt_bool_bool
stadef <= = lte_bool_bool
stadef > = gt_bool_bool
stadef >= = gte_bool_bool
//
stacst eq_bool_bool : (bool, bool) -> bool
stacst neq_bool_bool : (bool, bool) -> bool
stadef == = eq_bool_bool
stadef != = neq_bool_bool
stadef <> = neq_bool_bool // backward compatibility // deprecated
//
(* ****** ****** *)

(*
//
// HX-2012-06-12: removed
//
stacst
eq_char_char : (char, char) -> bool
stacst
neq_char_char : (char, char) -> bool
//
stadef == = eq_char_char
stadef != = neq_char_char
stadef <> = neq_char_char // backward compatibility // deprecated
//
*)

(* ****** ****** *)
//
stacst neg_int : (int) -> int
stadef ~ = neg_int // overloaded
//
stacst
add_int_int : (int, int) -> int
stacst
sub_int_int : (int, int) -> int
stacst
mul_int_int : (int, int) -> int
stacst
div_int_int : (int, int) -> int
//
stadef + = add_int_int
stadef - = sub_int_int
stadef * = mul_int_int
stadef / = div_int_int
//
// HX: ndiv: divisor is positive
// HX: idiv: alias for div_int_int
//
stacst
ndiv_int_int : (int, int) -> int
stacst
idiv_int_int : (int, int) -> int
//
stadef ndiv = ndiv_int_int
stadef idiv = idiv_int_int
//
stadef
nmod_int_int
(
  x:int, y:int
) = x - y * (x \ndiv_int_int y)
//
stadef mod = nmod_int_int
stadef nmod = nmod_int_int
stadef % (*adopted from C*) = nmod_int_int
//
(* ****** ****** *)
//
stacst lt_int_int : (int, int) -> bool
stacst lte_int_int : (int, int) -> bool
stacst gt_int_int : (int, int) -> bool
stacst gte_int_int : (int, int) -> bool
stadef < = lt_int_int and <= = lte_int_int
stadef > = gt_int_int and >= = gte_int_int
//
stacst eq_int_int : (int, int) -> bool
stacst neq_int_int : (int, int) -> bool
stadef == = eq_int_int
stadef != = neq_int_int
stadef <> = neq_int_int // HX: backward compatibility
//
(* ****** ****** *)
//
stacst abs_int : (int) -> int
stadef abs = abs_int
stadef absrel_int_int
  (x: int, v: int): bool =
  (x >= 0 && x == v) || (x <= 0 && ~x == v)
stadef absrel = absrel_int_int
//
stacst sgn_int : (int) -> int
stadef sgn = sgn_int
stadef sgnrel_int_int
  (x: int, v: int): bool =
  (x > 0 && v==1) || (x==0 && v==0) || (x < 0 && v==(~1))
stadef sgnrel = sgnrel_int_int
//
stacst max_int_int : (int, int) -> int
stadef max = max_int_int
stacst min_int_int : (int, int) -> int
stadef min = min_int_int
stadef maxrel_int_int_int
  (x: int, y: int, v: int): bool =
  (x >= y && x == v) || (x <= y && y == v)
stadef maxrel = maxrel_int_int_int
stadef minrel_int_int_int
  (x: int, y: int, v: int): bool =
  (x >= y && y == v) || (x <= y && x == v)
stadef minrel = minrel_int_int_int
//
stadef nsub (x:int, y:int) = max (x-y, 0)
//
stadef
ndivrel_int_int_int // HX: y > 0
  (x: int, y: int, q: int): bool =
  (q * y <= x) && (x < q * y + y)
stadef ndivrel = ndivrel_int_int_int
//
stadef
idivrel_int_int_int
  (x: int, y: int, q: int) = ( // HX: y != 0
  x >= 0 && y > 0 && ndivrel_int_int_int ( x,  y,  q)
) || (
  x >= 0 && y < 0 && ndivrel_int_int_int ( x, ~y, ~q)
) || (
  x <  0 && y > 0 && ndivrel_int_int_int (~x,  y, ~q)
) || (
  x <  0 && y < 0 && ndivrel_int_int_int (~x, ~y,  q)
) // end of [idivrel_int_int_int]
//
stadef idivrel = idivrel_int_int_int
//
stadef
divmodrel_int_int_int_int
  (x: int, y: int, q: int, r: int) : bool =
  (0 <= r && r < y && x == q*y + r)
stadef divmodrel = divmodrel_int_int_int_int
//
(* ****** ****** *)

stacst
ifint_bool_int_int
  : (bool, int, int) -> int
stadef ifint = ifint_bool_int_int
stadef
ifintrel_bool_int_int_int
  (b:bool, x:int, y:int, r:int): bool =
  (b && r==x) || (~b && r==y)
// end of [ifintrel]

(* ****** ****** *)

stadef
bool2int(b: bool): int = ifint (b, 1, 0)
stadef int2bool (i: int): bool = (i != 0)
stadef b2i = bool2int and i2b = int2bool

(* ****** ****** *)

(*
** HX: [char] = [int8]
** HX-2012-06-12: removed
//
stacst int_of_char: char -> int
stacst char_of_int : int -> char
stadef c2i = int_of_char and i2c = char_of_int
//
*)

(* ****** ****** *)

(*
** HX: pointer <-> integer
*)
stacst int_of_addr: addr -> int
stacst addr_of_int: int -> addr
stadef a2i = int_of_addr and i2a = addr_of_int

(* ****** ****** *)
//
stadef pow2_7 = 128
stadef pow2_8 = 256
stadef i2u_int8 (i:int) = ifint (i >= 0, i, i+pow2_8)
stadef i2u8 = i2u_int8
stadef u2i_int8 (u:int) = ifint (u < pow2_7, u, u-pow2_8)
stadef u2i8 = u2i_int8
//
stadef pow2_15 = 32768
stadef pow2_16 = 65536
stadef i2u_int16 (i:int) = ifint (i >= 0, i, i+pow2_16)
stadef i2u16 = i2u_int16
stadef u2i_int16 (u:int) = ifint (u < pow2_15, u, u-pow2_16)
stadef u2i16 = u2i_int16
//
(* ****** ****** *)

stadef pow2_32 = 0x100000000
stadef pow2_64 = 0x10000000000000000

(* ****** ****** *)

stacst null_addr : addr
stadef null = null_addr
stadef NULL = null_addr

stacst add_addr_int : (addr, int) -> addr
stacst sub_addr_int : (addr, int) -> addr
stacst sub_addr_addr : (addr, addr) -> int
stadef + = add_addr_int
stadef - = sub_addr_int
stadef - = sub_addr_addr

stacst lt_addr_addr : (addr, addr) -> bool
stacst lte_addr_addr : (addr, addr) -> bool
stadef < = lt_addr_addr
stadef <= = lte_addr_addr

stacst gt_addr_addr : (addr, addr) -> bool
stacst gte_addr_addr : (addr, addr) -> bool
stadef > = gt_addr_addr
stadef >= = gte_addr_addr

stacst eq_addr_addr : (addr, addr) -> bool
stacst neq_addr_addr : (addr, addr) -> bool
stadef == = eq_addr_addr
stadef != = neq_addr_addr and <> = neq_addr_addr

(* ****** ****** *)
//
// HX-2013-09:
// for supporting inheritance in OOP
//
stacst lte_cls_cls : (cls, cls) -> bool
stacst gte_cls_cls : (cls, cls) -> bool
stadef <= = lte_cls_cls
stadef >= = gte_cls_cls
//
stadef
lterel_cls_cls
(
  c1: cls, c2: cls, lterel_cls_cls_res: bool
) : bool = lterel_cls_cls_res
stadef
gterel_cls_cls
(
  c1: cls, c2: cls, gterel_cls_cls_res: bool
) : bool = gterel_cls_cls_res
//
(* ****** ****** *)
//
// HX: this is a special constant!
//
stacst
sizeof_t0ype_int : t@ype -> int
stadef
sizeof (a:viewt@ype): int = sizeof_t0ype_int (a?)
//
(* ****** ****** *)

sortdef nat = { i:int | i >= 0 } // natural numbers
sortdef pos = { i:int | i > 0 }
sortdef neg = { i:int | i < 0 }
sortdef npos = { i:int | i <= 0 } // non-positive integers

sortdef nat1 = { n:nat | n < 1 } // for 0
sortdef nat2 = { n:nat | n < 2 } // for 0, 1
sortdef nat3 = { n:nat | n < 3 } // for 0, 1, 2
sortdef nat4 = { n:nat | n < 4 } // for 0, 1, 2, 3

sortdef sgn = { i:int | ~1 <= i; i <= 1 }

sortdef agz = { l:addr | l > null }
sortdef agez = { l:addr | l >= null }
sortdef alez = { l:addr | l <= null }

(* ****** ****** *)

#define CHAR_MAX 127
#define CHAR_MIN ~128
#define UCHAR_MAX 0xFF

(* ****** ****** *)
//
stacst effnil : eff // nothing
stacst effall : eff // everything
//
stacst effntm : eff // nonterm
stacst effexn : eff // exception
stacst effref : eff // reference
stacst effwrt : eff // writeover
//
stacst add_eff_eff : (eff, eff) -> eff
stadef + = add_eff_eff // union of effsets
stacst sub_eff_eff : (eff, eff) -> eff
stadef - = add_eff_eff // difference of effsets
//
(* ****** ****** *)
//
// HX: some overloaded symbols
//
symintr ~ not
(*
symintr && || // macros
*)
symintr lnot lor lxor land
symintr + - * / % mod ndiv nmod
symintr < <= > >= = == != <> compare
symintr isltz isltez isgtz isgtez iseqz isneqz
symintr neg abs max min
symintr succ pred half double
symintr square sqrt cube cbrt pow
//
symintr [] // for subscripting
symintr << >> // for L/R-shifting
//
symintr inc dec
symintr ++ -- // inc and dec
symintr get set exch
symintr getinc setinc exchinc
symintr decget decset decexch
symintr !++ --! // getinc and decget
symintr =++ --= // setinc and decset
//
symintr assert
//
symintr encode decode
//
symintr g0ofg1 g1ofg0 // casting: dpt <-> ndpt
symintr ptrcast (* for functions taking the address of a boxed val *)
//
symintr copy free length
//
symintr print prerr fprint
//
(*
//
symintr forall
symintr iforall
//
symintr foreach
symintr foreach2
symintr iforeach
symintr rforeach
//
*)
//
symintr ofstring ofstrptr
symintr tostring tostrptr
//
(* ****** ****** *)
//
// HX-2014-02:
// for dot-notation overloading
//
symintr .size
symintr .length
symintr .get .set .exch
symintr .nrow .ncol
symintr .head .tail
symintr .next .prev
symintr .init .last
symintr .eval
//
(* ****** ****** *)
//
// HX-2012-05-23: for template args
//
abstype atstkind_type (tk: tkind)
abst@ype atstkind_t0ype (tk: tkind)
//
typedef
tkind_type (tk:tkind) = atstkind_type (tk)
typedef
tkind_t0ype (tk:tkind) = atstkind_t0ype (tk)
//
(* ****** ****** *)

absview // S2Eat
at_vt0ype_addr_view (vt@ype+, addr)
stadef @ = at_vt0ype_addr_view // HX: @ is infix

(* ****** ****** *)
//
absvt@ype
clo_t0ype_t0ype (a: t@ype) = a
absvt@ype
clo_vt0ype_vt0ype (a: vt@ype) = a
//
(* ****** ****** *)
(*
absview
read_view_int_int_view
  (v:view, stamp:int, n:int)
stadef READ = read_view_int_int_view
viewdef READ (v:view) = [s,n:int] READ (v, s, n)
stadef RD = READ
//
absview
readout_view_int_view (v:view, stamp:int)
stadef READOUT = readout_view_int_view
viewdef READOUT (v:view) = [s:int] READOUT (v, s)
//
absvt@ype
read_vt0ype_int_int_vt0ype
  (a:vt@ype, stamp:int, n:int) = a
stadef READ = read_vt0ype_int_int_vt0ype
vtypedef READ (a:vt@ype) = [s,n:int] READ (a, s, n)
stadef RD = READ
//
absvt@ype
readout_vt0ype_int_vt0ype (a:vt@ype, stamp: int) = a
stadef READOUT = readout_vt0ype_int_vt0ype
vtypedef READOUT (a:vt@ype) = [s:int] READOUT (a, s)
*)

(* ****** ****** *)

(*
absvt@ype
write_vt0ype_vt0ype (a: vt@ype) = a
vtypedef
WRITE (a:vt@ype) = write_vt0ype_vt0ype (a)
stadef WRT = WRITE
*)

(* ****** ****** *)
//
vtypedef READ (a:vt@ype) = a // HX: used as a comment
vtypedef WRITE (a:vt@ype) = a // HX: used as a comment (rarely)
//
(*
vtypedef SHARED (a:vt@ype) = a // HX: used as a comment
vtypedef NSHARED (a:vt@ype) = a // HX: used as a comment (rarely)
*)
//
(* ****** ****** *)
//
absprop invar_prop_prop (a:prop)
absview invar_view_view (a:view)
//
abst@ype // S2Einvar
invar_t0ype_t0ype (a:t@ype) = a
absvt@ype // S2Einvar
invar_vt0ype_vt0ype (a:vt@ype) = a
//
// HX: this order is significant
// 
viewdef
INV (a: view) = invar_view_view (a)
propdef
INV (a: prop) = invar_prop_prop (a)
//
vtypedef INV
  (a:vt@ype) = invar_vt0ype_vt0ype (a)
//
vtypedef
INV (a: t@ype) = invar_t0ype_t0ype (a)
//
(* ****** ****** *)
(*
//
absprop optarg_prop_prop (a:prop)
absview optarg_view_view (a:view)
//
abst@ype
optarg_t0ype_t0ype (a:t@ype) = a
absvt@ype
optarg_vt0ype_vt0ype (a:vt@ype) = a
//
// HX: this order is significant
// 
viewdef
OPT (a: view) = optarg_view_view (a)
propdef
OPT (a: prop) = optarg_prop_prop (a)
//
vtypedef OPT
  (a:vt@ype) = optarg_vt0ype_vt0ype (a)
//
vtypedef
OPT (a: t@ype) = optarg_t0ype_t0ype (a)
//
*)
(* ****** ****** *)
//
abst@ype
stamped_t0ype (a:t@ype, int) = a
stadef stamped_t = stamped_t0ype
//
absvt@ype
stamped_vt0ype (a:vt@ype, int) = a
stadef stamped_vt = stamped_vt0ype
//
(* ****** ****** *)
//
absview
vcopyenv_view_view (v:view)
stadef vcopyenv_v = vcopyenv_view_view
absvt@ype
vcopyenv_vt0ype_vt0ype (vt: vt0ype) = vt
stadef vcopyenv_vt = vcopyenv_vt0ype_vt0ype
//
(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_pre.sats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [basics_pre.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: September, 2011
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_sta.sats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

#define RD(x) x // for commenting: read-only

(* ****** ****** *)
(*
//
// HX-2012-05-24:
// the following two styles are equivalent:
//
stadef
bool_kind = $extkind"atstype_bool"
tkindef bool_kind = "atstype_bool"
*)
(* ****** ****** *)
//
tkindef bool_kind = "atstype_bool"
//
abst@ype
bool_t0ype = tkind_t0ype (bool_kind)
stadef bool = bool_t0ype // shorthand
abst@ype
bool_bool_t0ype (b: bool) = bool_t0ype
stadef bool = bool_bool_t0ype // shorthand
//
typedef Bool = [b:bool] bool (b)
typedef boolLte
  (b1:bool) = [b2:bool] bool (b2 <= b1) // b2 -> b1
typedef boolGte
  (b1:bool) = [b2:bool] bool (b2 >= b1) // b1 -> b2
//
abst@ype atstype_bool // HX-2013-09: for internal use
//
(* ****** ****** *)

tkindef
byte_kind = "atstype_byte"
abst@ype
byte_t0ype = tkind_t0ype (byte_kind)
stadef byte = byte_t0ype

(* ****** ****** *)
//
// char is signed
//
sortdef int8 = {
  i:int | ~128 <= i; i < 128
} // end of [int8]
sortdef uint8 =
  { i:int | 0 <= i; i < 256 }
// end of [uint8]
//
tkindef char_kind = "atstype_char"
//
abst@ype
char_t0ype = tkind_t0ype (char_kind)
stadef char = char_t0ype // shorthand
abst@ype
char_int_t0ype (c:int) = char_t0ype
stadef char = char_int_t0ype // shorthand
typedef Char = [c:int8] char (c)
typedef charNZ = [c:int8 | c != 0] char (c)
//
// signed characters
//
tkindef schar_kind = "atstype_schar"
//
abst@ype
schar_t0ype = tkind_t0ype (schar_kind)
stadef schar = schar_t0ype // shorthand
abst@ype
schar_int_t0ype (c:int) = schar_t0ype
stadef schar = schar_int_t0ype // shorthand
typedef sChar = [c:int8] schar (c)
//
// unsigned characters
//
tkindef uchar_kind = "atstype_uchar"
//
abst@ype
uchar_t0ype = tkind_t0ype (uchar_kind)
stadef uchar = uchar_t0ype // shorthand
abst@ype
uchar_int_t0ype (c:int) = uchar_t0ype
stadef uchar = uchar_int_t0ype // shorthand
typedef uChar = [c:uint8] uchar (c)
//
(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)
//
abst@ype
g0int_t0ype (tk:tk) = tkind_t0ype (tk)
stadef g0int = g0int_t0ype // shorthand
abst@ype
g1int_int_t0ype (tk:tkind, int) = g0int (tk)
stadef g1int = g1int_int_t0ype // shorthand
//
typedef g1int (tk:tkind) = [i:int] g1int (tk, i)
typedef g1int0 (tk:tkind) = [i:int | i >= 0] g1int (tk, i)
typedef g1int1 (tk:tkind) = [i:int | i >= 1] g1int (tk, i)
//
(* ****** ****** *)
//
typedef g1intLt
  (tk:tk, n:int) = [i:int | i < n] g1int (tk, i)
typedef g1intLte
  (tk:tk, n:int) = [i:int | i <= n] g1int (tk, i)
typedef g1intGt
  (tk:tk, n:int) = [i:int | i > n] g1int (tk, i)
typedef g1intGte
  (tk:tk, n:int) = [i:int | i >= n] g1int (tk, i)
typedef g1intBtw
  (tk:tk, lb:int, ub:int) = [i: int | lb <= i; i < ub] g1int (tk, i)
typedef g1intBtwe
  (tk:tk, lb:int, ub:int) = [i: int | lb <= i; i <= ub] g1int (tk, i)
//
(* ****** ****** *)
//
abst@ype
g0uint_t0ype (tk:tkind) = tkind_t0ype (tk)
stadef g0uint = g0uint_t0ype // shorthand
abst@ype
g1uint_int_t0ype (tk:tkind, int) = g0uint (tk)
stadef g1uint = g1uint_int_t0ype // shorthand
//
typedef g1uint (tk:tk) = [i:int] g1uint (tk, i)
typedef g1uint0 (tk:tk) = [i:int | i >= 0] g1uint (tk, i)
typedef g1uint1 (tk:tk) = [i:int | i >= 1] g1uint (tk, i)
//
(* ****** ****** *)
//
typedef g1uintLt
  (tk:tk, n:int) = [i:nat | i < n] g1uint (tk, i)
typedef g1uintLte
  (tk:tk, n:int) = [i:nat | i <= n] g1uint (tk, i)
typedef g1uintGt
  (tk:tk, n:int) = [i:int | i > n] g1uint (tk, i)
typedef g1uintGte
  (tk:tk, n:int) = [i:int | i >= n] g1uint (tk, i)
typedef g1uintBtw
  (tk:tk, lb:int, ub:int) = [i: int | lb <= i; i < ub] g1uint (tk, i)
typedef g1uintBtwe
  (tk:tk, lb:int, ub:int) = [i: int | lb <= i; i <= ub] g1uint (tk, i)
//
(* ****** ****** *)
//
tkindef int_kind = "atstype_int"
//
typedef int0 = g0int (int_kind)
typedef int1 (i:int) = g1int (int_kind, i)
//
stadef int = int1 // 2nd-select
stadef int = int0 // 1st-select
//
typedef Int = [i:int] int1 (i)
typedef Nat = [i:int | i >= 0] int1 (i)
//
typedef intLt (n:int) = g1intLt (int_kind, n)
typedef intLte (n:int) = g1intLte (int_kind, n)
typedef intGt (n:int) = g1intGt (int_kind, n)
typedef intGte (n:int) = g1intGte (int_kind, n)
typedef intBtw (lb:int, ub:int) = g1intBtw (int_kind, lb, ub)
typedef intBtwe (lb:int, ub:int) = g1intBtwe (int_kind, lb, ub)
//
typedef Two = intBtw (0, 2)
typedef Sgn = intBtwe (~1, 1)
//
typedef natLt (n:int) = intBtw (0, n)
typedef natLte (n:int) = intBtwe (0, n)
//
tkindef uint_kind = "atstype_uint"
//
typedef uint0 = g0uint (uint_kind)
typedef uint1 (n:int) = g1uint (uint_kind, n)
//
stadef uint = uint1 // 2nd-select
stadef uint = uint0 // 1st-select
//
stadef uInt = [n:int] uint1 (n)
//
typedef uintLt (n:int) = g1uintLt (uint_kind, n)
typedef uintLte (n:int) = g1uintLte (uint_kind, n)
typedef uintGt (n:int) = g1uintGt (uint_kind, n)
typedef uintGte (n:int) = g1uintGte (uint_kind, n)
typedef uintBtw (lb:int, ub:int) = g1uintBtw (uint_kind, lb, ub)
typedef uintBtwe (lb:int, ub:int) = g1uintBtwe (uint_kind, lb, ub)
//
abst@ype atstype_int // HX-2013-09: for internal use
abst@ype atstype_uint // HX-2013-09: for internal use
//
(* ****** ****** *)
//
tkindef
lint_kind = "atstype_lint"
typedef
lint0 = g0int (lint_kind)
typedef
lint1 (i:int) = g1int (lint_kind, i)
stadef lint = lint1 // 2nd-select
stadef lint = lint0 // 1st-select
//
tkindef
ulint_kind = "atstype_ulint"
typedef
ulint0 = g0uint (ulint_kind)
typedef
ulint1 (i:int) = g1uint (ulint_kind, i)
stadef ulint = ulint1 // 2nd-select
stadef ulint = ulint0 // 1st-select
//
tkindef
llint_kind = "atstype_llint"
typedef llint0 = g0int (llint_kind)
typedef llint1 (i:int) = g1int (llint_kind, i)
stadef llint = llint1 // 2nd-select
stadef llint = llint0 // 1st-select
//
tkindef
ullint_kind = "atstype_ullint"
typedef
ullint0 = g0uint (ullint_kind)
typedef
ullint1 (i:int) = g1uint (ullint_kind, i)
stadef ullint = ullint1 // 2nd-select
stadef ullint = ullint0 // 1st-select
//
(* ****** ****** *)
//
tkindef
intptr_kind = "atstype_intptr"
typedef
intptr0 = g0int (intptr_kind)
typedef
intptr1 (i:int) = g1int (intptr_kind, i)
stadef intptr = intptr1 // 2nd-select
stadef intptr = intptr0 // 1st-select
//
tkindef
uintptr_kind = "atstype_uintptr"
typedef
uintptr0 = g0uint (uintptr_kind)
typedef
uintptr1 (i:int) = g1uint (uintptr_kind, i)
stadef uintptr = uintptr1 // 2nd-select
stadef uintptr = uintptr0 // 1st-select
//
(* ****** ****** *)
//
tkindef
sint_kind = "atstype_sint"
typedef
sint0 = g0int (sint_kind)
typedef
sint1 (i:int) = g1int (sint_kind, i)
stadef sint = sint1 // 2nd-select
stadef sint = sint0 // 1st-select
//
tkindef
usint_kind = "atstype_usint"
typedef
usint0 = g0uint (usint_kind)
typedef
usint1 (i:int) = g1uint (usint_kind, i)
stadef usint = usint1 // 2nd-select
stadef usint = usint0 // 1st-select
//
(* ****** ****** *)
//
tkindef
size_kind = "atstype_size"
typedef size0_t = g0uint (size_kind)
typedef size1_t (i:int) = g1uint (size_kind, i)
//
stadef size_t = size1_t // 2nd-select
stadef size_t = size0_t // 1st-select
//
typedef Size =
  [i:int | i >= 0] g1uint (size_kind, i)
typedef Size_t = Size
//
typedef sizeLt (n:int) = g1uintLt (size_kind, n)
typedef sizeLte (n:int) = g1uintLte (size_kind, n)
typedef sizeGt (n:int) = g1uintGt (size_kind, n)
typedef sizeGte (n:int) = g1uintGte (size_kind, n)
typedef sizeBtw (lb:int, ub:int) = g1uintBtw (size_kind, lb, ub)
typedef sizeBtwe (lb:int, ub:int) = g1uintBtwe (size_kind, lb, ub)
//
tkindef
ssize_kind = "atstype_ssize"
typedef ssize0_t = g0int (ssize_kind)
typedef ssize1_t (i:int) = g1int (ssize_kind , i) 
//
stadef ssize_t = ssize1_t // 2nd-select
stadef ssize_t = ssize0_t // 1st-select
//
typedef SSize =
  [i:int] g1int (ssize_kind, i)
typedef SSize_t = SSize
//
typedef ssizeLt (n:int) = g1intLt (ssize_kind, n)
typedef ssizeLte (n:int) = g1intLte (ssize_kind, n)
typedef ssizeGt (n:int) = g1intGt (ssize_kind, n)
typedef ssizeGte (n:int) = g1intGte (ssize_kind, n)
typedef ssizeBtw (lb:int, ub:int) = g1intBtw (ssize_kind, lb, ub)
typedef ssizeBtwe (lb:int, ub:int) = g1intBtwe (ssize_kind, lb, ub)
//
abst@ype atstype_size // HX-2013-09: for internal use
abst@ype atstype_ssize // HX-2013-09: for internal use
//
(* ****** ****** *)

typedef sizeof_t (a:vt@ype) = size_t (sizeof(a?))

(* ****** ****** *)
//
tkindef
int8_kind = "atstype_int8"
typedef
int8_0 = g0int (int8_kind)
typedef
int8_1
  (i:int) = g1int (int8_kind, i)
//
stadef int8 = int8_1 // 2nd-select
stadef int8 = int8_0 // 1st-select
stadef Int8 = [i:int] int8_1 (i)
//
tkindef
uint8_kind = "atstype_uint8"
typedef
uint8_0 = g0uint (uint8_kind)
typedef
uint8_1
  (i:int) = g1uint (uint8_kind, i)
//
stadef uint8 = uint8_1 // 2nd-select
stadef uint8 = uint8_0 // 1st-select
stadef uInt8 = [i:nat] uint8_1 (i)
//
(* ****** ****** *)
//
tkindef
int16_kind = "atstype_int16"
typedef
int16_0 = g0int (int16_kind)
typedef
int16_1
  (i:int) = g1int (int16_kind, i)
//
stadef int16 = int16_1 // 2nd-select
stadef int16 = int16_0 // 1st-select
stadef Int16 = [i:int] int16_1 (i)
//
tkindef
uint16_kind = "atstype_uint16"
typedef
uint16_0 = g0uint (uint16_kind)
typedef
uint16_1
  (i:int) = g1uint (uint16_kind, i)
//
stadef uint16 = uint16_1 // 2nd-select
stadef uint16 = uint16_0 // 1st-select
stadef uInt16 = [i:nat] uint16_1 (i)
//
(* ****** ****** *)
//
tkindef
int32_kind = "atstype_int32"
typedef
int32_0 = g0int (int32_kind)
typedef
int32_1
  (i:int) = g1int (int32_kind, i)
//
stadef int32 = int32_1 // 2nd-select
stadef int32 = int32_0 // 1st-select
stadef Int32 = [i:int] int32_1 (i)
//
tkindef
uint32_kind = "atstype_uint32"
typedef
uint32_0 = g0uint (uint32_kind)
typedef
uint32_1
  (i:int) = g1uint (uint32_kind, i)
//
stadef uint32 = uint32_1 // 2nd-select
stadef uint32 = uint32_0 // 1st-select
stadef uInt32 = [i:nat] uint32_1 (i)
//
(* ****** ****** *)
//
tkindef
int64_kind = "atstype_int64"
typedef
int64_0 = g0int (int64_kind)
typedef
int64_1
  (i:int) = g1int (int64_kind, i)
//
stadef int64 = int64_1 // 2nd-select
stadef int64 = int64_0 // 1st-select
stadef Int64 = [i:int] int64_1 (i)
//
tkindef
uint64_kind = "atstype_uint64"
typedef
uint64_0 = g0uint (uint64_kind)
typedef
uint64_1
  (i:int) = g1uint (uint64_kind, i)
//
stadef uint64 = uint64_1 // 2nd-select
stadef uint64 = uint64_0 // 1st-select
stadef uInt64 = [i:nat] uint64_1 (i)
//
(* ****** ****** *)
//
abst@ype
g0float_t0ype (tk:tk) = tkind_t0ype (tk)
stadef g0float = g0float_t0ype // shorthand
//
tkindef float_kind = "atstype_float"
typedef float = g0float (float_kind)
//
tkindef double_kind = "atstype_double"
typedef double = g0float (double_kind)
//
tkindef ldouble_kind = "atstype_ldouble"
typedef ldouble = g0float (ldouble_kind)
//
(* ****** ****** *)
//
// HX: unindexed type for pointers
//
tkindef ptr_kind = "atstype_ptrk"
abstype ptr_type = tkind_type (ptr_kind)
stadef ptr = ptr_type // a shorthand
abstype ptr_addr_type (l:addr) = ptr_type
stadef ptr = ptr_addr_type // a shorthand
typedef Ptr = [l:addr] ptr (l)
typedef Ptr0 = [l:addr | l >= null] ptr (l)
typedef Ptr1 = [l:addr | l >  null] ptr (l)
typedef
Ptrnull (l:addr) =
  [l1:addr | l1 == null || l1 == l] ptr (l1)
// end of [Ptrnull]
//
// HX-2012-02-14: it is an expriment for now:
//
stadef ptr (n:int) = ptr_addr_type (addr_of_int(n))
//
(* ****** ****** *)

(*
** HX: persistent read-only strings
*)
(*
//
// HX-2013-04: this confuses type-erasure
//
abstype
string_type = $extype"atstype_string"
*)
abstype
string_type = ptr // = char* in C
abstype
string_int_type (n: int) = string_type
//
stadef string0 = string_type
stadef string1 = string_int_type
stadef string = string1 // 2nd-select
stadef string = string0 // 1st-select
typedef String = [n:int] string_int_type (n)
typedef String0 = [n:int | n >= 0] string_int_type (n)
typedef String1 = [n:int | n >= 1] string_int_type (n)
//
(* ****** ****** *)

abstype
stropt_int_type (n:int) = ptr
stadef stropt = stropt_int_type
typedef Stropt = [n:int] stropt_int_type (n)
typedef Stropt0 = [n:int] stropt_int_type (n)
typedef Stropt1 = [n:int | n >= 0] stropt_int_type (n)
stadef stropt = Stropt // HX: this may be a bit confusing :)

(* ****** ****** *)

(*
** HX: linear mutable strings
*)
absvtype
strptr_addr_vtype (l:addr) = ptr
stadef strptr = strptr_addr_vtype
vtypedef Strptr0 = [l:addr] strptr (l)
vtypedef Strptr1 = [l:addr | l > null] strptr (l)
stadef strptr = Strptr0

absvtype
strnptr_addr_int_vtype (l:addr, n:int) = ptr
stadef strnptr = strnptr_addr_int_vtype
vtypedef strnptr (n:int) = [l:addr] strnptr (l, n)
vtypedef Strnptr0 = [l:addr;n:int] strnptr (l, n)
vtypedef Strnptr1 = [l:addr;n:int | n >= 0] strnptr (l, n)

(* ****** ****** *)

(*
** HX: persistent mutable strings
*)
abstype
strref_addr_type (l:addr) = ptr
stadef strref = strref_addr_type
typedef Strref0 = [l:addr] strref (l)
typedef Strref1 = [l:addr | l > null] strref (l)

(* ****** ****** *)

abst@ype
atsvoid_t0ype
(*
= $extype"atsvoid_t0ype"
*)
typedef void = atsvoid_t0ype // = C-void

(* ****** ****** *)
//
absvtype
exception_vtype = $extype"atstype_exnconptr"
//
vtypedef exn = exception_vtype // boxed vtype
//
(* ****** ****** *)

absvt@ype // covariance
opt_vt0ype_bool_vt0ype (a:vt@ype+, opt:bool) = a
stadef opt = opt_vt0ype_bool_vt0ype

(* ****** ****** *)

typedef bytes (n:int) = @[byte][n]
viewdef bytes_v (l:addr, n:int) = bytes (n) @ l
typedef b0ytes (n:int) = @[byte?][n]
viewdef b0ytes_v (l:addr, n:int) = b0ytes (n) @ l

(* ****** ****** *)
//
abstype
cloref_t0ype_type (a:t@ype) = ptr
stadef cloref = cloref_t0ype_type
//
absvtype
cloptr_vt0ype_vtype (a:t@ype) = ptr
stadef cloptr = cloptr_vt0ype_vtype
vtypedef cloptr0 = cloptr_vt0ype_vtype (void)
//
(* ****** ****** *)
//
typedef
stamped_t(a:t@ype) = [x:int] stamped_t(a, x)
vtypedef
stamped_vt(a:vt@ype) = [x:int] stamped_vt(a, x)
//
(* ****** ****** *)
//
// HX: for memory deallocation (with/without GC)
//
absview
mfree_gc_addr_view (addr)
stadef mfree_gc_v = mfree_gc_addr_view
absview
mfree_ngc_addr_view (addr)
stadef mfree_ngc_v = mfree_ngc_addr_view
//
absview
mfree_libc_addr_view (addr) // libc-mfree
stadef mfree_libc_v = mfree_libc_addr_view
//
(* ****** ****** *)

absvt@ype
arrpsz_vt0ype_int_vt0ype
  (a:vt@ype+, n:int) = $extype"atstype_arrpsz"
stadef arrpsz = arrpsz_vt0ype_int_vt0ype

(* ****** ****** *)

absprop // invariance
vbox_view_prop (v:view)
propdef vbox (v:view) = vbox_view_prop (v)

abstype // invariance
ref_vt0ype_type (a:vt@ype) = ptr
typedef ref (a:vt@ype) = ref_vt0ype_type (a)

(* ****** ****** *)
//
viewdef vtakeout
  (v1: view, v2: view) = (v2, v2 -<lin,prf> v1)
viewdef vtakeout0 (v:view) = vtakeout (void, v)
//
vtypedef vttakeout
  (vt1: vt@ype, vt2: vt@ype) = (vt2 -<lin,prf> vt1 | vt2)
viewdef vttakeout0 (vt:vt@ype) = vttakeout (void, vt)
//
(* ****** ****** *)
//
vtypedef
vtakeoutptr
  (a:vt@ype) = [l:addr] (a@l, a@l -<lin,prf> void | ptr l)
//
(* ****** ****** *)
//
vtypedef
vstrptr (l:addr) = vttakeout0 (strptr l)
//
vtypedef vStrptr0 = [l:addr] vstrptr (l)
vtypedef vStrptr1 = [l:addr | l > null] vstrptr (l)
//
(* ****** ****** *)

typedef
bottom_t0ype_uni = {a:t@ype} (a)
typedef
bottom_t0ype_exi = [a:t@ype | false] (a)

vtypedef
bottom_vt0ype_uni = {a:vt@ype} (a)
vtypedef
bottom_vt0ype_exi = [a:vt@ype | false] (a)

(* ****** ****** *)

typedef
cmpval_fun
  (a: t@ype) = (a, a) -<fun> int
typedef
cmpval_funenv
  (a: t@ype, vt: t@ype) = (a, a, !vt) -<fun> int
stadef cmpval = cmpval_fun
stadef cmpval = cmpval_funenv

(* ****** ****** *)

typedef
cmpref_fun
  (a: vt@ype) = (&RD(a), &RD(a)) -<fun> int
typedef
cmpref_funenv
  (a: vt@ype, vt: vt@ype) = (&RD(a), &RD(a), !vt) -<fun> int
stadef cmpref = cmpref_fun
stadef cmpref = cmpref_funenv

(* ****** ****** *)
//
// HX: [lazy(T)] :
// suspended evaluation of type T
//
abstype
lazy_t0ype_type (t@ype+) = ptr
typedef lazy (a:t@ype) = lazy_t0ype_type (a)
//
(* ****** ****** *)
//
// HX: [lazy_vt(VT)] :
// suspended computation of viewtype VT
//
absvtype
lazy_vt0ype_vtype (vt@ype+) = ptr
vtypedef lazy_vt (a: vt@ype)= lazy_vt0ype_vtype (a)
//
(* ****** ****** *)
//
(*
abst@ype
literal_int(intlit) = $extype"atsliteral_int"
*)
abst@ype
literal_float(float) = $extype"atsliteral_float"
abst@ype
literal_string(string) = $extype"atsliteral_string"
//
(* ****** ****** *)
//
abst@ype
undefined_t0ype = $extype"atstype_undefined"
absvt@ype
undefined_vt0ype = $extype"atstype_undefined"
//
(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_sta.sats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [basics_sta.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: September, 2011
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_dyn.sats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)
//
sortdef t0p = t@ype and vt0p = vt@ype
//
(* ****** ****** *)

datatype TYPE(a:vt@ype) = TYPE(a) of ()

(* ****** ****** *)
//
// HX-2012: In $ATSHOME/ccomp/runtime:
// atsbool_true/atsbool_false are mapped to 1/0
// this mapping is fixed and should never be changed!
//
#define true true_bool // shorthand
val true_bool : bool (true)  = "mac#atsbool_true" // = 1
//
#define false false_bool // shorthand
val false_bool : bool (false) = "mac#atsbool_false" // = 0
//
(* ****** ****** *)
//
// HX: [false] implies all
//
prfun false_elim{X:prop | false} ((*void*)): X
//
(* ****** ****** *)
//
praxi
lemma_subcls_reflexive{c:cls} ((*void*)): [c <= c] void
praxi
lemma_subcls_transitive
  {c1,c2,c3:cls | c1 <= c2; c2 <= c3} (): [c1 <= c3] void
//
(* ****** ****** *)

praxi praxi_int{i:int} ((*void*)): int (i)
praxi praxi_bool{b:bool} ((*void*)): bool (b)
praxi praxi_ptr{l:addr} ((*void*)): ptr (l)

(* ****** ****** *)

dataprop
EQINT (int, int) = {x:int} EQINT (x, x)
//
prfun eqint_make {x,y:int | x == y} (): EQINT (x, y)
//
prfun
eqint_make_gint
  {tk:tk}{x:int} (x: g1int (tk, x)): [y:int] EQINT (x, y)
prfun
eqint_make_guint
  {tk:tk}{x:int} (x: g1uint (tk, x)): [y:int] EQINT (x, y)
//
(* ****** ****** *)

dataprop
EQADDR (addr, addr) = {x:addr} EQADDR (x, x)
//
prfun
eqaddr_make {x,y:addr | x == y} (): EQADDR (x, y)
//
prfun
eqaddr_make_ptr {x:addr} (x: ptr (x)): [y:addr] EQADDR (x, y)
//
(* ****** ****** *)

dataprop
EQBOOL (bool, bool) = {x:bool} EQBOOL (x, x)
//
prfun eqbool_make {x,y:bool | x == y} (): EQBOOL (x, y)
//
prfun eqbool_make_bool {x:bool} (x: bool (x)): [y:bool] EQBOOL (x, y)
//
(* ****** ****** *)

prfun prop_verify{b:bool | b} ():<prf> void
prfun prop_verify_and_add{b:bool | b} ():<prf> [b] void

(* ****** ****** *)

prfun pridentity_v{v:view} (x: !INV(v)): void
prfun pridentity_vt{vt:viewt@ype} (x: !INV(vt)): void

(* ****** ****** *)

dataprop
EQTYPE (vt@ype, vt@ype) = {a:vt@ype} EQTYPE (a, a)

(* ****** ****** *)

castfn
viewptr_match
  {a:vt0p}{l1,l2:addr | l1==l2}
  (pf: INV(a) @ l1 | p: ptr l2):<> [l:addr | l==l1] (a @ l | ptr l)
// end of [viewptr_match]

(* ****** ****** *)
//
val{a:vt@ype} sizeof : size_t (sizeof(a))
//
praxi
lemma_sizeof{a:vt@ype} (): [sizeof(a) >= 0] void
//
(* ****** ****** *)

praxi topize {a:t@ype} (x: !INV(a) >> a?): void

(* ****** ****** *)

castfn dataget {a:vt@ype} (x: !INV(a) >> a): a?!

(* ****** ****** *)
//
// HX: returning the pf to GC
//
praxi
mfree_gc_v_elim
  {l:addr} (pf: mfree_gc_v l):<prf> void
// end of [mfree_gc_v_elim]

(* ****** ****** *)

praxi
mfree_gcngc_v_nullify
  {l:addr} (
  pf1: mfree_gc_v (l), pf1: mfree_ngc_v (l)
) : void // end of [mfree_gcngc_nullify_v]

(* ****** ****** *)
//
fun
cloptr_free
  {a:t0p} (pclo: cloptr (a)):<!wrt> void = "mac#%"
//
(* ****** ****** *)
//
fun{a:t0p}
lazy_force (lazyval: lazy (a)):<!laz> a
fun{a:vt0p}
lazy_vt_force (lazyval: lazy_vt (a)): (a)
//
(* ****** ****** *)
//
// HX-2013:
// macro implemented in [pats_ccomp_instrset]
//
fun
lazy_vt_free
  {a:vt0p} (lazyval: lazy_vt (a)):<!wrt> void = "mac#%"
overload ~ with lazy_vt_free
//
(* ****** ****** *)
//
// HX-2014:
// macro implemented in [pats_ccomp_instrset]
//
fun
lazy2cloref
  {a:t0p}(lazy(a)): ((*void*)) -<cloref1> (a) = "mac#%"
//
(* ****** ****** *)

(*
// HX-2012-05-23: this seems TOO complicated!
(*
** HX-2012-03: handling read-only views and vtypes
*)
castfn
read_getval // copy out a non-linear value
  {a:t@ype}{s:int}{n:int} (x: !READ (a, s, n)):<> a
// end of [read_getval]

praxi
read_takeout{v:view}
  (pf: !v >> READOUT (v, s)): #[s:int] READ (v, s, 0)
// end of [read_takeout]
praxi
read_addback // HX: there is no need to check
  {v1:view}{v2:view}{s:int} // if v1 and v2 match
  (pf1: !READOUT (v1, s) >> v1, pf2: READ (v2, s, 0)): void
// end of [read0_addback]

praxi
read_split
  {v:view}{s:int}{n:int}
  (pf: !READ (v, s, n) >> READ (v, s, n+1)): READ (v, s, 0)
// end of [read_split]
praxi
read_unsplit // HX: there is no need to check
  {v1:view}{v2:view}{s:int}{n1,n2:int} // if v1 and v2 match
  (pf1: READ (v1, s, n1), pf2: READ (v2, s, n2)): READ (v1, s, n1+n2-1)
// end of [read_unsplit]
*)
(* ****** ****** *)
//
castfn
stamp_t{a:t@ype}(x: a):<> stamped_t(a)
castfn
stamp_vt{a:vt@ype}(x: a):<> stamped_vt(a)
//
(* ****** ****** *)

castfn
unstamp_t
  {a:t@ype}{x:int} (x: stamped_t (INV(a), x)):<> a
// end of [unstamp_t]
castfn
unstamp_vt
  {a:vt@ype}{x:int} (x: stamped_vt (INV(a), x)):<> a
// end of [unstamp_vt]

(* ****** ****** *)
//
castfn
stamped_t2vt
  {a:t@ype}{x:int}
  (x: stamped_t(INV(a), x)):<> stamped_vt (a, x)
// end of [stamped_t2vt]
//
castfn
stamped_vt2t
  {a:t@ype}{x:int}
  (x: stamped_vt(INV(a), x)):<> stamped_t (a, x)
// end of [stamped_vt2t]
//
fun{a:t@ype}
stamped_vt2t_ref{x:int}
  (x: &stamped_vt(INV(a), x)):<> stamped_t (a, x)
//
(* ****** ****** *)
//
praxi
vcopyenv_v_decode{v:view} (x: vcopyenv_v (v)): vtakeout0 (v)
castfn
vcopyenv_vt_decode{vt:vt0p} (x: vcopyenv_vt (vt)): vttakeout0 (vt)
//
overload decode with vcopyenv_v_decode
overload decode with vcopyenv_vt_decode
//
(* ****** ****** *)
//
// HX: the_null_ptr = (void*)0
//
val
the_null_ptr : ptr (null) = "mac#atsptr_null"
//
(* ****** ****** *)

praxi
lemma_addr_param{l:addr} (): [l >= null] void

(* ****** ****** *)

praxi
lemma_string_param
  {n:int} (x: string(n)): [n >= 0] void
// end of [lemma_string_param]
praxi
lemma_stropt_param
  {n:int} (x: stropt(n)): [n >= ~1] void
// end of [lemma_stropt_param]

(* ****** ****** *)

dataprop SGN (int, int) =
  | SGNzero (0, 0) | {i:neg} SGNneg (i, ~1) | {i:pos} SGNpos (i,  1)
// end of [SGN] // end of [dataprop]

(* ****** ****** *)
//
// HX-2012-06:
// indication of the failure of
exception AssertExn of () // an assertion
//
(* ****** ****** *)
//
// HX-2012-06:
// indication of something expected
exception NotFoundExn of () // to be found but not
//
(* ****** ****** *)
//
exception GenerallyExn of (string) // for unspecified causes
(*
exception GenerallyExn2 of (string, ptr(*data*)) // for unspecified causes
*)
//
(* ****** ****** *)
//
// HX-2012-07:
// indication of a function argument being
exception IllegalArgExn of (string) // out of its domain
//
(* ****** ****** *)

praxi __vfree_exn (x: exn):<> void // for freeing nullary exception-con

(* ****** ****** *)
//
datatype unit = unit of ()
dataprop unit_p = unit_p of ()
dataview unit_v = unit_v of ()
prfun unit_v_elim (pf: unit_v): void
//
(* ****** ****** *)
//
abstype
boxed_t0ype_type(a:t@ype+) = unit
absvtype
boxed_vt0ype_vtype(a:vt@ype+) = unit
//
vtypedef
boxed(a:vt@ype) = boxed_vt0ype_vtype(a)
vtypedef
boxed_vt(a:vt@ype) = boxed_vt0ype_vtype(a)
//
typedef boxed(a:t@ype) = boxed_t0ype_type(a)
typedef boxed_t(a:t@ype) = boxed_t0ype_type(a)
//
fun{a:type} box: (INV(a)) -> boxed_t(a)
fun{a:type} unbox: boxed_t(INV(a)) -> (a)
fun{a:vtype} box_vt: (INV(a)) -> boxed_vt(a)
fun{a:vtype} unbox_vt: boxed_vt(INV(a)) -> (a)
//
(* ****** ****** *)
//
typedef
array (a, n) = @[a][n]
viewdef
array_v
  (a:vt@ype, l:addr, n:int) = @[a][n] @ l
//
absvtype
arrayptr_vt0ype_addr_int_vtype
  (a:vt0ype+, l:addr, n:int(*size*)) = ptr (l)
stadef
arrayptr = arrayptr_vt0ype_addr_int_vtype
vtypedef
arrayptr
  (a:vt0p, n:int) = [l:addr] arrayptr (a, l, n)
//
abstype
arrayref_vt0ype_int_type
  (a:vt@ype(*elt*), n:int(*size*)) = ptr
stadef arrayref = arrayref_vt0ype_int_type
//
abstype
arrszref_vt0ype_type (a: vt@ype) = ptr
stadef arrszref = arrszref_vt0ype_type
//
(* ****** ****** *)
//
datatype
// t@ype+: covariant
list_t0ype_int_type
  (a:t@ype+, int) =
  | list_nil(a, 0) of ()
  | {n:int | n >= 0}
    list_cons(a, n+1) of (a, list_t0ype_int_type (a, n))
// end of [datatype]
stadef list = list_t0ype_int_type
typedef
List (a:t0p) = [n:int] list (a, n)
typedef
List0 (a:t0p) = [n:int | n >= 0] list (a, n)
typedef
List1 (a:t0p) = [n:int | n >= 1] list (a, n)
typedef listLt
  (a:t0p, n:int) = [k:nat | k < n] list (a, k)
typedef listLte
  (a:t0p, n:int) = [k:nat | k <= n] list (a, k)
typedef listGt
  (a:t0p, n:int) = [k:int | k > n] list (a, k)
typedef listGte
  (a:t0p, n:int) = [k:int | k >= n] list (a, k)
typedef listBtw
  (a:t0p, m:int, n:int) = [k:int | m <= k; k < n] list (a, k)
typedef listBtwe
  (a:t0p, m:int, n:int) = [k:int | m <= k; k <= n] list (a, k)
//
(* ****** ****** *)
//
datavtype
// vt@ype+: covariant
list_vt0ype_int_vtype
  (a:vt@ype+, int) =
  | list_vt_nil (a, 0) of ()
  | {n:int | n >= 0}
    list_vt_cons (a, n+1) of (a, list_vt0ype_int_vtype (a, n))
// end of [list_vt0ype_int_vtype]
stadef list_vt = list_vt0ype_int_vtype
vtypedef
List_vt (a:vt0p) = [n:int] list_vt (a, n)
vtypedef
List0_vt (a:vt0p) = [n:int | n >= 0] list_vt (a, n)
vtypedef
List1_vt (a:vt0p) = [n:int | n >= 1] list_vt (a, n)
vtypedef listLt_vt
  (a:vt0p, n:int) = [k:nat | k < n] list_vt (a, k)
vtypedef listLte_vt
  (a:vt0p, n:int) = [k:nat | k <= n] list_vt (a, k)
vtypedef listGt_vt
  (a:vt0p, n:int) = [k:int | k > n] list_vt (a, k)
vtypedef listGte_vt
  (a:vt0p, n:int) = [k:int | k >= n] list_vt (a, k)
vtypedef listBtw_vt
  (a:vt0p, m:int, n:int) = [k:int | m <= k; k < n] list_vt (a, k)
vtypedef listBtwe_vt
  (a:vt0p, m:int, n:int) = [k:int | m <= k; k <= n] list_vt (a, k)
//
(* ****** ****** *)
//
datatype
// t@ype+: covariant
option_t0ype_bool_type
  (a:t@ype+, bool) = Some(a, true) of (a) | None(a, false)
// end of [datatype]
stadef option = option_t0ype_bool_type
typedef Option (a:t0p) = [b:bool] option (a, b)
//
datavtype
// vt@ype+: covariant
option_vt0ype_bool_vtype
  (a:vt@ype+, bool) = Some_vt(a, true) of (a) | None_vt(a, false)
// end of [option_vt0ype_bool_vtype]
stadef option_vt = option_vt0ype_bool_vtype
vtypedef Option_vt (a:vt0p) = [b:bool] option_vt (a, b)
//
(* ****** ****** *)
//
praxi
opt_some
  {a:vt0p}(x: !INV(a) >> opt(a, true)):<prf> void
praxi
opt_unsome
  {a:vt0p}(x: !opt(INV(a), true) >> a):<prf> void
//
fun{a:vt0p}
opt_unsome_get (x: &opt(INV(a), true) >> a?): (a)
//
praxi
opt_none
  {a:vt0p} (x: !(a?) >> opt(a, false)):<prf> void
praxi
opt_unnone
  {a:vt0p} (x: !opt(INV(a), false) >> a?):<prf> void
//
praxi
opt_clear
  {a:t0p}{b:bool}(x: !opt(INV(a), b) >> a?):<prf> void
//
(* ****** ****** *)
//
dataprop
or_prop_prop_int_prop
  (a0: prop+, a1: prop+, int) =
  PORleft(a0, a1, 0) of a0 | PORright(a0, a1, 1) of a1
stadef por = or_prop_prop_int_prop
//
dataview
or_view_view_int_view
  (a0: view+, a1: view+, int) =
  VORleft(a0, a1, 0) of a0 | VORright(a0, a1, 1) of a1
stadef vor = or_view_view_int_view
//
dataprop
option_prop_bool_prop
  (a:prop+, bool) = Some_p (a, true) of (a) | None_p (a, false)
// end of [option_prop_bool_prop]
stadef option_p = option_prop_bool_prop
//
dataview
option_view_bool_view
  (a:view+, bool) = Some_v (a, true) of (a) | None_v (a, false)
// end of [option_view_bool_view]
stadef option_v = option_view_bool_view
//
(* ****** ****** *)
//
absvt@ype
arrayopt (a:vt0p, n:int, b:bool) = array (a, n)
//
praxi
arrayopt_some
  {a:vt0p}{n:int} (A: &array(a, n) >> arrayopt(a, n, true)): void
praxi
arrayopt_none
  {a:vt0p}{n:int} (A: &array(a?, n) >> arrayopt(a, n, false)): void
praxi
arrayopt_unsome
  {a:vt0p}{n:int} (A: &arrayopt(a, n, true) >> array(a, n)): void
praxi
arrayopt_unnone
  {a:vt0p}{n:int} (A: &arrayopt(a, n, false) >> array(a?, n)): void
//
(* ****** ****** *)

absvtype
argv_int_vtype (n:int) = ptr
stadef argv = argv_int_vtype

(*
[argv_takeout_strarr] is declared in prelude/SATS/extern.sats
[argv_takeout_parrnull] is declared in prelude/SATS/extern.sats
*)

(* ****** ****** *)

praxi
lemma_argv_param {n:int} (argv: !argv(n)): [n >= 0] void
// end of [praxi]

(* ****** ****** *)
//
fun
argv_get_at{n:int}
  (argv: !argv (n), i: natLt n):<> string = "mac#%"
fun
argv_set_at{n:int}
  (argv: !argv (n), i: natLt n, x: string):<!wrt> void = "mac#%"
//
overload [] with argv_get_at
overload [] with argv_set_at
//
(* ****** ****** *)
//
symintr main0
//
fun main_void_0
  ((*void*)): void = "ext#mainats_void_0"
fun main_argc_argv_0
  {n:int | n >= 1}
  (argc: int n, argv: !argv(n)): void = "ext#mainats_argc_argv_0"
overload main0 with main_void_0
overload main0 with main_argc_argv_0
//
(* ****** ****** *)
//
symintr main
//
fun main_void_int
  ((*void*)): int = "ext#mainats_void_int"
fun main_argc_argv_int
  {n:int | n >= 1}
  (argc: int n, argv: !argv(n)): int = "ext#mainats_argc_argv_int"
fun main_argc_argv_envp_int
  {n:int | n >= 1}
  (argc: int n, argv: !argv n, envp: ptr): int = "ext#mainats_argc_argv_envp_int"
overload main with main_void_int
overload main with main_argc_argv_int
overload main with main_argc_argv_envp_int
//
(* ****** ****** *)

fun exit
  (ecode: int):<!exn> {a:t0p}(a) = "mac#%"
fun exit_errmsg
  (ecode: int, msg: string):<!exn> {a:t0p}(a) = "mac#%"
(*
fun exit_fprintf{ts:types}
(
  ecode: int, out: FILEref, fmt: printf_c ts, args: ts
) :<!exn> {a:vt0p}(a) = "mac#%" // end of [exit_fprintf]
*)

(* *****p* ****** *)
//
fun exit_void
  (ecode: int):<!exn> void = "mac#%"
fun exit_errmsg_void
  (ecode: int, msg: string):<!exn> void = "mac#%"
//
(* ****** ****** *)

fun assert_bool0
  (x: bool):<!exn> void = "mac#%"
fun assert_bool1
  {b:bool} (x: bool (b)):<!exn> [b] void = "mac#%"
//
overload assert with assert_bool0 of 0
overload assert with assert_bool1 of 10
//
(* ****** ****** *)

fun{}
assertexn_bool0 (x: bool):<!exn> void
fun{}
assertexn_bool1 {b:bool} (x: bool (b)):<!exn> [b] void
//
symintr assertexn
overload assertexn with assertexn_bool0 of 0
overload assertexn with assertexn_bool1 of 10
//
(* ****** ****** *)
//
symintr assert_errmsg
//
fun assert_errmsg_bool0
  (x: bool, msg: string):<!exn> void = "mac#%"
fun assert_errmsg_bool1
  {b:bool} (x: bool b, msg: string):<!exn> [b] void = "mac#%"
//
overload assert_errmsg with assert_errmsg_bool0 of 0
overload assert_errmsg with assert_errmsg_bool1 of 10
//
(* ****** ****** *)

fun assert_errmsg2_bool0
  (x: bool, msg1: string, msg2: string):<!exn> void = "mac#%"
fun assert_errmsg2_bool1{b:bool}
  (x: bool b, msg1: string, msg2: string):<!exn> [b] void = "mac#%"
//
symintr assert_errmsg2
overload assert_errmsg2 with assert_errmsg2_bool0 of 0
overload assert_errmsg2 with assert_errmsg2_bool1 of 10
//
(* ****** ****** *)

datasort
file_mode =
  | file_mode_r (* read *)
  | file_mode_w (* write *)
  | file_mode_rw (* read and write *)
// end of [file_mode]

(* ****** ****** *)

local
//
stadef r() = file_mode_r()
stadef w() = file_mode_w()
stadef rw() = file_mode_rw()
//
in (* in-of-local *)

(* ****** ****** *)

abstype
file_mode (file_mode) = string
typedef
file_mode = [fm:file_mode] file_mode (fm)

(* ****** ****** *)

sortdef fmode = file_mode
typedef fmode (fm:fmode) = file_mode (fm)
typedef fmode = file_mode

(* ****** ****** *)

dataprop
file_mode_lte
  (fmode, fmode) =
  | {m:fmode} file_mode_lte_refl (m, m)
  | {m1,m2,m3:fmode}
    file_mode_lte_tran (m1, m3) of
      (file_mode_lte (m1, m2), file_mode_lte (m2, m3))
  | {m:fmode} file_mode_lte_rw_r (rw(), r()) of ()
  | {m:fmode} file_mode_lte_rw_w (rw(), w()) of ()
// end of [file_mode_lte]

(* ****** ****** *)
//
prval
file_mode_lte_r_r
  : file_mode_lte (r(), r()) // impled in [filebas_prf.dats]
prval
file_mode_lte_w_w
  : file_mode_lte (w(), w()) // impled in [filebas_prf.dats]
prval
file_mode_lte_rw_rw
  : file_mode_lte (rw(), rw()) // impled in [filebas_prf.dats]
//
(* ****** ****** *)

end // end of [local]

(* ****** ****** *)

abstype FILEref_type = ptr
typedef FILEref = FILEref_type

(* ****** ****** *)
//
typedef
fprint_type(a: t0p) = (FILEref, a) -> void
typedef
fprint_vtype(a: vt0p) = (FILEref, !a) -> void
//
(* ****** ****** *)

fun print_newline (): void = "mac#%"
fun prerr_newline (): void = "mac#%"
fun fprint_newline (out: FILEref): void = "mac#%"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_dyn.sats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [basics_dyn.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/unsafe.atxt
** Time of generation: Sat Oct 17 15:19:54 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

staload "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{
} int2ptr (i) = cast{ptr}(cast{intptr}(i))
implement{
} ptr2int (p) = cast{int}(cast{intptr}(p))

(* ****** ****** *)

implement
{a}(*tmp*)
ptr0_get
  (p) = x where {
  val [l:addr]
    p = g1ofg0_ptr(p)
  prval (pf, fpf) = __assert () where {
    extern praxi __assert (): (a @ l, a? @ l -<lin,prf> void)
  } // end of [prval]
  val x = !p
  prval () = fpf (pf)
} // end of [ptr0_get]

implement{a} ptr1_get = ptr0_get<a>

(* ****** ****** *)

implement
{a}(*tmp*)
ptr0_set
  (p, x) = () where {
  val [l:addr]
    p = g1ofg0_ptr(p)
  prval (pf, fpf) = __assert () where {
    extern praxi __assert (): (a? @ l, a @ l -<lin,prf> void)
  } // end of [prval]
  val () = !p := x
  prval () = fpf (pf)
} // end of [ptr0_set]

implement{a} ptr1_set = ptr0_set<a>

(* ****** ****** *)

implement
{a}(*tmp*)
ptr0_exch
  (p, x) = () where {
  val p = g1ofg0_ptr(p)
  val (pf, fpf | p) = ptr_vtake{a}(p)
  val tmp = !p
  val ( ) = !p := x
  val ( ) = x := tmp
  prval () = fpf (pf)
} // end of [ptr0_exch]

implement{a} ptr1_exch = ptr0_exch<a>

(* ****** ****** *)

implement
{a}(*tmp*)
ptr0_intch
  (p1, p2) = () where {
  val p1 = g1ofg0_ptr(p1)
  val p2 = g1ofg0_ptr(p2)
  val (pf1, fpf1 | p1) = ptr_vtake{a}(p1)
  val (pf2, fpf2 | p2) = ptr_vtake{a}(p2)
  val tmp = !p1
  val ( ) = !p1 := !p2
  val ( ) = !p2 := tmp
  prval () = fpf1 (pf1)
  prval () = fpf2 (pf2)
} (* end of [ptr0_intch] *)

implement{a} ptr1_intch = ptr0_intch<a>

(* ****** ****** *)
//
implement
{a}(*tmp*)
ptr0_get_at_int (p, i) =
  ptr0_get<a> (ptr0_add_gint<a> (p, i))
implement
{a}(*tmp*)
ptr0_set_at_int (p, i, x) =
  ptr0_set<a> (ptr0_add_gint<a> (p, i), x)
//
implement
{a}(*tmp*)
ptr0_get_at_size (p, i) =
  ptr0_get<a> (ptr0_add_guint<a> (p, i))
implement
{a}(*tmp*)
ptr0_set_at_size (p, i, x) =
  ptr0_set<a> (ptr0_add_guint<a> (p, i), x)
//
(* ****** ****** *)

implement{a}
cptr_get (p) = ptr1_get<a> (cptr2ptr(p))

implement{a}
cptr_set (p, x) = ptr1_set<a> (cptr2ptr(p), x)

implement{a}
cptr_exch (p, x) = ptr1_exch<a> (cptr2ptr(p), x)

(* ****** ****** *)

implement{a}
ptr0_addby (p, x) = let
  val x0 = ptr0_get<a> (p) in ptr0_set<a> (p, gadd_val_val<a> (x0, x))
end // end of [ptr0_addby]
implement{a} ptr1_addby = ptr0_addby<a>

implement{a}
ptr0_subby (p, x) = let
  val x0 = ptr0_get<a> (p) in ptr0_set<a> (p, gsub_val_val<a> (x0, x))
end // end of [ptr0_subby]
implement{a} ptr1_subby = ptr0_subby<a>

implement{a}
ptr0_mulby (p, x) = let
  val x0 = ptr0_get<a> (p) in ptr0_set<a> (p, gmul_val_val<a> (x0, x))
end // end of [ptr0_mulby]
implement{a} ptr1_mulby = ptr0_mulby<a>

implement{a}
ptr0_divby (p, x) = let
  val x0 = ptr0_get<a> (p) in ptr0_set<a> (p, gdiv_val_val<a> (x0, x))
end // end of [ptr0_divby]
implement{a} ptr1_divby = ptr0_divby<a>

implement{a}
ptr0_modby (p, x) = let
  val x0 = ptr0_get<a> (p) in ptr0_set<a> (p, gmod_val_val<a> (x0, x))
end // end of [ptr0_modby]
implement{a} ptr1_modby = ptr0_modby<a>

(* ****** ****** *)

implement{a}
ptr1_list_next
  (p) = p_next where
{
  val xs =
  castvwtp1{list_vt(a,1)}(p)
  val+@list_vt_cons(_, xs_next) = xs
  val p_next = addr@(xs_next)
  prval ((*void*)) = fold@ (xs)
  prval ((*void*)) = cast2void (xs)
} (* end of [ptr1_list_next] *)

(* ****** ****** *)

(* end of [unsafe.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/option.atxt
** Time of generation: Sat Oct 17 15:19:56 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

implement{a} option_some (x) = Some (x)
implement{a} option_none ( ) = None ( )

(* ****** ****** *)

implement
{}(*tmp*)
option_is_some (opt) =
  case+ opt of Some _ => true | None _ => false
// end of [option_is_some]

implement
{}(*tmp*)
option_is_none (opt) =
  case+ opt of Some _ => false | None _ => true
// end of [option_is_none]

(* ****** ****** *)

implement
{a}(*tmp*)
option_unsome
  (opt) = x where { val+Some (x) = opt }
// end of [option_unsome]

implement
{a}(*tmp*)
option_unsome_exn
  (opt) = (
  case+ opt of
  | Some x => x | None _ => $raise NotSomeExn()
) // end of [option_unsome_exn]

(* ****** ****** *)

implement
{a}(*tmp*)
option_equal
  (opt1, opt2) =
(
//
case+ opt1 of
| None () =>
  (
    case+ opt1 of None () => true | Some _ => false
  )
| Some x1 =>
  (
    case+ opt2 of None () => false | Some x2 => option_equal$eqfn(x1, x2)
  )
//
) (* end of [option_equal] *)

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_option
  (out, opt) = let
in
//
case+ opt of
| Some (x) => {
    val (
    ) = fprint_string (out, "Some(")
    val () = fprint_val<a> (out, x)
    val () = fprint_string (out, ")")
  } (* end of [Some] *)
| None () => fprint_string (out, "None()")
//
end // end of [fprint_option]

(* ****** ****** *)

(* end of [option.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/matrixptr.atxt
** Time of generation: Sat Oct 17 15:19:57 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{}
arrayptr2matrixptr_int (A, m, n) = $UN.castvwtp0 (A)
implement{}
arrayptr2matrixptr_size (A, m, n) = $UN.castvwtp0 (A)

(* ****** ****** *)

implement{a}
matrixptr_make_elt
  {m, n} (m, n, x0) = let
  val mn = $UN.cast{Size}(m * n)
in
  $UN.castvwtp0{matrixptr(a,m,n)}(arrayptr_make_elt<a> (mn, x0))
end // end of [matrixptr_make_elt]

(* ****** ****** *)

implement{a}
matrixptr_get_at_int
  (A, i, n, j) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_get<a> (ptr_add<a> (ptrcast(A), ij))
end // end of [matrixptr_get_at_int]

implement{a}
matrixptr_get_at_size
  (A, i, n, j) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_get<a> (ptr_add<a> (ptrcast(A), ij))
end // end of [matrixptr_get_at_size]

(* ****** ****** *)

implement{a}
matrixptr_set_at_int
  (A, i, n, j, x) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_set<a> (ptr_add<a> (ptrcast(A), ij), x)
end // end of [matrixptr_set_at_int]

implement{a}
matrixptr_set_at_size
  (A, i, n, j, x) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_set<a> (ptr_add<a> (ptrcast(A), ij), x)
end // end of [matrixptr_set_at_size]

(* ****** ****** *)

implement{a}
matrixptr_exch_at_int
  (A, i, n, j, x) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_exch<a> (ptr_add<a> (ptrcast(A), ij), x)
end // end of [matrixptr_exch_at_int]

implement{a}
matrixptr_exch_at_size
  (A, i, n, j, x) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_exch<a> (ptr_add<a> (ptrcast(A), ij), x)
end // end of [matrixptr_exch_at_size]

(* ****** ****** *)

implement{a}
fprint_matrixptr
  {m,n} (out, M, m, n) = let
//
val p0 = ptrcast (M)
//
val (
  pf, fpf | p0
) = $UN.ptr_vtake {matrix(a,m,n)} (p0)
val () = fprint_matrix<a> (out, !p0, m, n)
prval () = fpf (pf)
//
in
  // nothing
end // end of [fprint_matrixptr]

(* ****** ****** *)

implement{a}
fprint_matrixptr_sep
(
  out, M, m, n, sep1, sep2
) = let
//
implement
fprint_matrix$sep1<> (out) = fprint_string (out, sep1)
implement
fprint_matrix$sep2<> (out) = fprint_string (out, sep2)
//
in
  fprint_matrixptr<a> (out, M, m, n)
end // end of [fprint_matrixptr_sep]

(* ****** ****** *)

(*
implement matrixptr_free = ATS_MFREE
*)

(* ****** ****** *)

implement{a}
matrixptr_foreach
  (A, m, n) = let
  var env: void = () in
  matrixptr_foreach_env<a><void> (A, m, n, env)
end // end of [matrixptr_foreach]

implement
{a}{env}
matrixptr_foreach_env
  (A, m, n, env) = res where {
  val p = ptrcast (A)
  prval pfarr = matrixptr_takeout (A)
  val res = matrix_foreach_env<a><env> (!p, m, n, env)
  prval () = matrixptr_addback (pfarr | A)
} // end of [matrixptr_foreach_env]

(* ****** ****** *)

implement{a}
matrixptr_tabulate
  (nrow, ncol) =
(
  matrixptr_encode2(matrix_ptr_tabulate<a> (nrow, ncol))
) (* end of [matrixptr_tabulate] *)

(* ****** ****** *)

implement{a}
matrixptr_tabulate_cloref
  {m,n} (nrow, ncol, f) = let
//
implement(a2)
matrix_tabulate$fopr<a2> (i, j) =
  $UN.castvwtp0{a2}(f($UN.cast{sizeLt(m)}(i), $UN.cast{sizeLt(n)}(j)))
//
in
  matrixptr_tabulate<a> (nrow, ncol)
end // end of [matrixptr_tabulate_cloref]

(* ****** ****** *)

(* end of [matrixptr.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: May, 2012
//
(* ****** ****** *)
//
// HX-2012-05: for array-based iterators
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/giterator.sats"

(* ****** ****** *)

sortdef t0p = t@ype
stadef itrknd = giter_array_kind
stadef itrkpm = giter_array_param

(* ****** ****** *)

dataviewtype
iterk (
  a:viewt@ype+, l:addr, int(*f*), int(*r*)
) = {f,r:int}
  ITR (a, l, f, r) of (
    array_v (a, l, f+r) | ptr l(*beg*), ptr(*end*), ptr(*cur*)
  ) // end of [ITR]

(* ****** ****** *)

extern
castfn iterk2giter
  {x:vt0p}{l:addr}{n:int}
  (xs: iterk (x, l, 0, n)):<> giter (itrknd, itrkpm(l), x, 0, n)
// end of [iterk2giter]

extern
castfn giter2iterk
  {x:vt0p}{l:addr}{f,r:int}
  (itr: giter (itrknd, itrkpm(l), x, f, r)):<> iterk (x, l, f, r)
// end of [giter2iterk]

(* ****** ****** *)

implement{x}
giter_make_array (pf | p, n) =
  iterk2giter (ITR (pf | p, ptr0_add_guint<x> (p, n), p))
// end of [giter_make_array]

implement
giter_free_array (itr) = let
  val+ ~ITR (pf | _, _, _) = giter2iterk (itr) in (pf | ())
end // end of [giter_free_array]

(* ****** ****** *)

extern
praxi encode
  {kpm:tk}{x:vt0p}{l:addr}{f,r:int}
  (xs: !iterk (x, l, f, r) >> giter (itrknd, kpm, x, f, r)): void
// end of [encode]

extern
praxi decode
  {kpm:tk}{x:vt0p}{l:addr}{f,r:int}
  (itr: !giter (itrknd, kpm, x, f, r) >> iterk (x, l, f, r)): void
// end of [decode]

(* ****** ****** *)

implement(x)
giter_is_atbeg<itrknd><x>
  {kpm}{f,r} (itr) = let
  prval () = decode (itr)
  val+ ITR (_ | p_beg, p_end, pi) = itr
  prval () = encode (itr)
  val res = g1ofg0_bool (p_beg = pi)
  extern praxi __assert {b:bool} (b: bool b): [b==(f==0)] void
  prval () = __assert (res)
in
  res
end // end of [giter_is_atbeg]

implement(x)
giter_isnot_atbeg<itrknd><x>
  {kpm}{f,r} (itr) = let
  prval () = decode (itr)
  val+ ITR (_ | p_beg, p_end, pi) = itr
  prval () = encode (itr)
  extern castfn __cast {b:bool} (b: bool b):<> [b==(f>0)] bool (b)
in
  if p_beg < pi then __cast(true) else __cast(false)
end // end of [giter_isnot_atbeg]

(* ****** ****** *)

implement(x)
giter_is_atend<itrknd><x>
  {kpm}{f,r} (itr) = let
  prval () = decode (itr)
  val+ ITR (_ | p_beg, p_end, pi) = itr
  prval () = encode (itr)
  val res = g1ofg0_bool (pi = p_end)
  extern praxi __assert {b:bool} (b: bool b): [b==(r==0)] void
  prval () = __assert (res)
in
  res
end // end of [giter_is_atend]

implement(x)
giter_isnot_atend<itrknd><x>
  {kpm}{f,r} (itr) = let
  prval () = decode (itr)
  val+ ITR (_ | p_beg, p_end, pi) = itr
  prval () = encode (itr)
  extern castfn __cast {b:bool} (b: bool b):<> [b==(r>0)] bool (b)
in
  if pi < p_end then __cast(true) else __cast(false)
end // end of [giter_isnot_atend]

(* ****** ****** *)

implement(x)
giter_getref<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ ITR (_ | _, _, pi) = itr
  prval () = encode (itr)
in
  $UN.cast2Ptr1 (pi)
end // end of [giter_getref]

(* ****** ****** *)

implement(x)
giter_inc<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val () = rpi := ptr0_succ<x> (rpi)
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_inc]

implement(x)
giter_dec<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val () = rpi := ptr0_pred<x> (rpi)
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_dec]

(* ****** ****** *)

implement(x)
giter_getref_inc<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val pi = rpi
  val () = rpi := ptr0_succ<x> (pi)
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  $UN.cast2Ptr1 (pi)
end // end of [giter_getref_inc]

implement(x)
giter_dec_getref<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val pi = ptr0_pred<x> (rpi)
  val () = rpi := pi
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  $UN.cast2Ptr1 (pi)
end // end of [giter_getref_dec]

(* ****** ****** *)

implement(x)
giter_fjmp<itrknd><x>
  (itr, i) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val () = rpi := ptr0_add_guint<x> (rpi, i)
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_fjmp]

(* ****** ****** *)

implement(x)
giter_fgetref_at<itrknd><x>
  (itr, i) = let
  prval () = decode (itr)
  val+ ITR (_ | _, _, pi) = itr
  prval () = encode (itr)
in
  $UN.cast2Ptr1 (ptr0_add_guint<x> (pi, i))
end // end of [giter_fgetref_at]

(* ****** ****** *)

implement(x)
giter_fbjmp<itrknd><x> (itr, i) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val () = rpi := ptr0_add_gint<x> (rpi, i)
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_fbjmp]

implement(x)
giter_fbgetref_at<itrknd><x>
  (itr, i) = let
  prval () = decode (itr)
  val+ ITR (_ | _, _, pi) = itr
  prval () = encode (itr)
in
  $UN.cast2Ptr1 (ptr0_add_gint<x> (pi, i))
end // end of [giter_fbget_at]

(* ****** ****** *)

(* end of [giter_array.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/string.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

#define CNUL '\000'

(* ****** ****** *)

overload + with add_ptr_bsz

(* ****** ****** *)

macdef castvwtp_trans = $UN.castvwtp0 // former name

(* ****** ****** *)

extern
fun memcpy
  (d:ptr, s:ptr, n:size_t):<!wrt> ptr = "mac#atspre_string_memcpy"
// end of [memcpy]

(* ****** ****** *)

implement
{}(*tmp*)
string_sing (c) = let
  val (pfat, pfgc | p) = malloc_gc(i2sz(2))
  val ((*void*)) = $UN.ptr0_set<char> (p, c)
  val ((*void*)) = $UN.ptr0_set_at<char> (p, 1, '\000')
in
  $UN.castvwtp0{strnptr(1)}((pfat, pfgc | p))
end // end of [string_sing]

(* ****** ****** *)

implement{}
string_is_empty
  {n} (str) = let
  val p = string2ptr(str)
in
  $UN.cast{bool(n==0)}($UN.ptr1_get<char>(p) = CNUL)
end // end of [string_is_empty]
implement{}
string_isnot_empty
  {n} (str) = let
  val p = string2ptr(str)
in
  $UN.cast{bool(n > 0)}($UN.ptr1_get<char>(p) != CNUL)
end // end of [string_isnot_empty]

(* ****** ****** *)

implement{}
string_is_atend_size{n}{i}
  (str, i) = let
  val p_i = add_ptr_bsz (string2ptr(str), i)
in
  $UN.cast{bool(n==i)}($UN.ptr1_get<char>(p_i) = CNUL)
end // end of [string_is_atend_size]

implement{tk}
string_is_atend_gint (str, i) =
  string_is_atend_size (str, g1int2uint(i))
// end of [string_is_atend_gint]
implement{tk}
string_is_atend_guint (str, i) =
  string_is_atend_size (str, g1uint2uint(i))
// end of [string_is_atend_guint]

(* ****** ****** *)

implement{}
string_get_at_size (str, i) =
  $UN.ptr1_get<charNZ>(string2ptr(str) + i)
// end of [string_get_at_size]

implement{tk}
string_get_at_gint (str, i) =
  string_get_at_size (str, g1int2uint (i))
// end of [string_get_at_gint]
implement{tk}
string_get_at_guint (str, i) =
  string_get_at_size (str, g1uint2uint (i))
// end of [string_get_at_guint]

(* ****** ****** *)

implement{}
string_test_at_size
  {n}{i} (str, i) = let
//
extern
castfn
__cast (c: char):<>
  [c:int] (string_index_p (n, i, c) | char (c))
//
in
  __cast ($UN.ptr1_get<char>(string2ptr(str) + i))
end // end of [string_test_at_size]

implement{tk}
string_test_at_gint (str, i) =
  string_test_at_size (str, g1int2uint (i))
// end of [string_test_at_gint]
implement{tk}
string_test_at_guint (str, i) =
  string_test_at_size (str, g1uint2uint (i))
// end of [string_test_at_guint]

(* ****** ****** *)

implement{
} strintcmp
  {n1,n2} (x1, n2) = let
//
prval () = lemma_string_param (x1)
//
fun loop
  {n2:nat} .<n2>.
  (p1: ptr, n2: int n2):<> int = let
  val c = $UN.ptr0_get<char>(p1)
in
  if c != CNUL then (
    if n2 > 0 then loop (ptr_succ<char>(p1), n2-1) else 1(*gt*)
  ) else (
    if n2 > 0 then ~1(*lt*) else 0(*eq*)
  ) // end of [if]
end // end of [loop]
//
in
  $UN.cast{int(sgn(n1-n2))}(loop (string2ptr(x1), n2))
end // end of [strintcmp]

(* ****** ****** *)

implement{
} strlencmp
  {n1,n2} (x1, x2) = let
//
prval () = lemma_string_param (x1)
prval () = lemma_string_param (x2)
//
//
fun loop
  {n1:nat} .<n1>. (
  p1: ptr, p2: ptr
) :<> int = let
  val c1 = $UN.ptr0_get<char>(p1)
  val c2 = $UN.ptr0_get<char>(p2)
in
//
if c1 != CNUL then let
  prval () =
    __assert () where {
      extern praxi __assert (): [n1 > 0] void
  } // end of [prval]
in
  if c2 != CNUL then
    loop {n1-1} (ptr_succ<char>(p1), ptr_succ<char>(p2))
  else 1(*gt*) // end of [if]
end else (
  if c2 != CNUL then ~1(*lt*) else 0(*eq*)
) (* end of [if] *)
//
end // end of [loop]
//
in
  $UN.cast{int(sgn(n1-n2))}(loop{n1}(string2ptr(x1), string2ptr(x2)))
end // end of [strlencmp]

(* ****** ****** *)

implement{
} string_make_list (cs) =
  string_make_listlen (cs, list_length (cs))
// end of [string_make_list]

implement{
} string_make_listlen
  {n} (cs, n) = let
//
prval () = lemma_list_param (cs)
//
fun loop
  {n:nat} .<n>.
(
  cs: list (char, n), n: int n, p: ptr
) :<!wrt> ptr = let
in
  if n > 0 then let
    val+list_cons (c, cs) = cs
    val () = $UN.ptr0_set<char>(p, c)
  in
    loop (cs, n-1, ptr_succ<char>(p))
  end else p // end of [if]
end // end of [loop]
//
val n1 = n + 1
val (pf, pfgc | p0) =
  $effmask_wrt (malloc_gc(i2sz(n1)))
val p1 = $effmask_wrt (loop (cs, n, p0))
val () =
  $effmask_wrt ($UN.ptr0_set<char>(p1, CNUL))
//
in
  castvwtp_trans{strnptr(n)}((pf, pfgc | p0))
end // end of [string_make_listlen]

(* ****** ****** *)

implement{
} string_make_rlist (cs) =
  string_make_rlistlen (cs, list_length (cs))
// end of [string_make_rlist]

implement{
} string_make_rlistlen
  {n} (cs, n) = let
//
prval () = lemma_list_param (cs)
//
fun loop
  {n:nat} .<n>.
(
  cs: list (char, n), n: int n, p: ptr
) :<!wrt> ptr = let
in
  if n > 0 then let
    val p1 = ptr_pred<char>(p)
    val+list_cons (c, cs) = cs
    val () = $UN.ptr0_set<char>(p1, c)
  in
    loop (cs, n-1, p1)
  end else p // end of [if]
end // end of [loop]
//
val n1 = n + 1
val (pf, pfgc | p0) =
  $effmask_wrt (malloc_gc(i2sz(n1)))
val p1 = ptr_add<char>(p0, n)
val () =
  $effmask_wrt ($UN.ptr0_set<char>(p1, CNUL))
val p0 = $effmask_wrt (loop (cs, n, p1))
//
in
  castvwtp_trans{strnptr(n)}((pf, pfgc | p0))
end // end of [string_make_rlistlen]

(* ****** ****** *)

implement{
} string_make_substring
  {n}{st,ln}
  (str, st, ln) = $effmask_wrt let
//
val ln1 = succ(ln)
val (pf, pfgc | p_dst) = malloc_gc (ln1)
val p_src = string2ptr(str)
val p_dst = memcpy (p_dst, p_src + st, ln)
//
val () = $UN.ptr0_set<char>(p_dst + ln, CNUL)
//
in
  castvwtp_trans{strnptr(ln)}((pf, pfgc | p_dst))
end // end of [string_make_substring]

(* ****** ****** *)
//
implement{}
string_head
  (str) = $UN.ptr0_get<charNZ> (string2ptr(str))
implement{}
string_tail{n}
  (str) = $UN.cast{string(n-1)}(ptr_succ<char> (string2ptr(str)))
//
(* ****** ****** *)

implement{}
string0_length
  (str) = string1_length<> (g1ofg0(str))
// end of [string0_length]

implement{}
string1_length
  {n} (str) =
  __strlen (str) where {
  extern fun __strlen (str: string n):<> size_t (n) = "mac#atspre_strlen"
} // end of [where] // end of [string1_length]

(* ****** ****** *)
//
implement{}
string0_nlength
  (str1, n2) =
  string1_nlength<> (g1ofg0(str1), g1ofg0(n2))
// end of [string0_nlength]
//
implement{}
string1_nlength
  (str1, n2) = let
//
fun
loop{n1,n2,r:nat} .<n1>.
(
  str1: string(n1), n2: size_t(n2), r: size_t(r)
) :<> size_t(min(n1,n2)+r) =
(
if
(n2 > 0)
then let
in
//
if
isneqz(str1)
  then loop (str1.tail(), pred(n2), succ(r)) else (r)
//
end // end of [then]
else (r) // end of [else]
)
//
prval () = lemma_string_param(str1) and () = lemma_g1uint_param(n2)
//
in
  loop (str1, n2, i2sz(0))
end // end of [string1_nlength]
//
(* ****** ****** *)

implement{}
string0_copy
  (str) = let
//
val str = g1ofg0(str)
val str2 = string1_copy (str)
prval () = lemma_strnptr_param (str2)
//
in
  strnptr2strptr (str2)
end // end of [string0_copy]

implement{}
string1_copy
  {n} (str) = let
//
val n = string1_length (str)
val n1 = succ(n)
val (pf, pfgc | p) = malloc_gc (n1)
val _(*p*) = $effmask_wrt (memcpy (p, string2ptr(str), n1))
//
in
  castvwtp_trans{strnptr(n)}((pf, pfgc | p))
end // end of [string1_copy]

(* ****** ****** *)

implement{
} strchr {n} (str, c0) = let
//
prval () = lemma_string_param (str)
extern fun __strchr (string, int):<> ptr = "mac#atspre_strchr"
extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac#atspre_sub_ptr_ptr"
val p0 = string2ptr(str)
val p1 = __strchr (str, (char2int0)c0)
//
in
  if p1 > the_null_ptr then __sub (p1, p0) else i2ssz(~1)
end // end of [strchr]

implement{
} strrchr {n} (str, c0) = let
//
prval () = lemma_string_param (str)
extern fun __strrchr (string, int):<> ptr = "mac#atspre_strrchr"
extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac#atspre_sub_ptr_ptr"
val p0 = string2ptr(str)
val p1 = __strrchr (str, (char2int0)c0)
//
in
  if p1 > the_null_ptr then __sub (p1, p0) else i2ssz(~1)
end // end of [strrchr]

(* ****** ****** *)

implement{
} strstr {n}
  (haystack, needle) = let
//
prval () = lemma_string_param (haystack)
extern fun __strstr (string, string):<> ptr = "mac#atspre_strstr"
extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac#atspre_sub_ptr_ptr"
val p0 = string2ptr(haystack)
val p1 = __strstr (haystack, needle)
//
in
  if p1 > the_null_ptr then __sub (p1, p0) else i2ssz(~1)
end // end of [strstr]

(* ****** ****** *)

implement{
} strspn {n}
  (str, accept) = let
//
prval () = lemma_string_param (str)
extern fun __strspn (string, string):<> sizeLte (n) = "mac#atspre_strspn"
//
in
  __strspn (str, accept)
end // end of [strspn]

implement{
} strcspn {n}
  (str, reject) = let
//
prval () = lemma_string_param (str)
extern fun __strcspn (string, string):<> sizeLte (n) = "mac#atspre_strcspn"
//
in
  __strcspn (str, reject)
end // end of [strcspn]

(* ****** ****** *)

implement{}
string_index {n}
  (str, c) = $UN.cast{ssizeBtw(~1,n)}(strchr (str, c))
// end of [string_index]

implement{}
string_rindex {n}
  (str, c) = $UN.cast{ssizeBtw(~1,n)}(strrchr (str, c))
// end of [string_rindex]

(* ****** ****** *)

implement{}
string0_append
  (x1, x2) = let
//
val x1 = g1ofg0(x1)
val x2 = g1ofg0(x2)
val x12 = string1_append (x1, x2)
prval () = lemma_strnptr_param (x12)
//
in
  strnptr2strptr (x12)
end // end of [string0_append]

implement{}
string1_append
  {n1,n2} (x1, x2) = let
//
val n1 = strlen (x1) and n2 = strlen (x2)
//
val n12 = n1 + n2
val (pf, fpf | p) = malloc_gc (succ(n12))
//
val p1 = memcpy (p, string2ptr(x1), n1)
val p2 = memcpy (p + n1, string2ptr(x2), succ(n2))
//
in
  castvwtp_trans{strnptr(n1+n2)}((pf, fpf | p))
end // end of [string1_append]

(* ****** ****** *)

implement{}
string0_append3
  (x1, x2, x3) = let
//
var xs = @[string](x1, x2, x3)
//
in
//
stringarr_concat<>
  ($UN.cast{arrayref(string,3)}(addr@xs), i2sz(3))
//
end // end of [string0_append3]

implement{}
string0_append4
  (x1, x2, x3, x4) = let
//
var xs = @[string](x1, x2, x3, x4)
//
in
//
stringarr_concat<>
  ($UN.cast{arrayref(string,4)}(addr@xs), i2sz(4))
//
end // end of [string0_append4]

implement{}
string0_append5
  (x1, x2, x3, x4, x5) = let
//
var xs = @[string](x1, x2, x3, x4, x5)
//
in
//
stringarr_concat<>
  ($UN.cast{arrayref(string,5)}(addr@xs), i2sz(5))
//
end // end of [string0_append5]

implement{}
string0_append6
  (x1, x2, x3, x4, x5, x6) = let
//
var xs = @[string](x1, x2, x3, x4, x5, x6)
//
in
//
stringarr_concat<>
  ($UN.cast{arrayref(string,6)}(addr@xs), i2sz(6))
//
end // end of [string0_append6]

(* ****** ****** *)

implement{}
stringarr_concat (xs, asz) = let
//
fun loop
(
  p1: ptr, p2: ptr, i: size_t, ntot: size_t
) : size_t = let
in
//
if i > 0 then let
  val x = $UN.ptr0_get<string> (p1)
  val nx: size_t = string_length (x)
  val () = $UN.ptr0_set<size_t> (p2, nx)
in
  loop (ptr_succ<string> (p1), ptr_succ<size_t> (p2), pred(i), ntot+nx)
end else ntot // end of [if]
//
end // end of [loop]
//
fun loop2
(
  p1: ptr, p2: ptr, i: size_t, pres: ptr
) : void = let
in
//
if i > 0 then let
  val x = $UN.ptr0_get<string> (p1)
  val nx = $UN.ptr0_get<size_t> (p2)
  val _(*ptr*) = memcpy (pres, $UN.cast{ptr}(x), nx)
in
  loop2 (ptr_succ<string> (p1), ptr_succ<size_t> (p2), pred(i), pres+nx)
end else $UN.ptr0_set<char> (pres, CNUL)
//
end // end of [loop2]
//
val p1 = $UN.cast{ptr}(xs)
val nxs = arrayptr_make_uninitized<size_t> (asz)
val p2 = arrayptr2ptr (nxs)
//
val ntot = $effmask_all (loop (p1, p2, asz, i2sz(0)))
val (pf, pfgc | pres) = malloc_gc (g1ofg0(succ(ntot)))
val ((*void*)) = $effmask_all (loop2 (p1, p2, asz, pres))
//
val () = arrayptr_free (nxs)
//
in
  castvwtp_trans{Strptr1}((pf, pfgc | pres))
end // end of [stringarr_concat]

(* ****** ****** *)

implement{}
stringlst_concat (xs) = let
//
val n = list_length (xs)
prval () = lemma_list_param (xs)
prval [n:int] EQINT() = eqint_make_gint (n)
val xs2 = arrayptr_make_list (n, xs)
val res = stringarr_concat ($UN.castvwtp1{arrayref(string,n)}(xs2), i2sz(n))
val () = arrayptr_free (xs2)
//
in
  res
end // end of [stringlst_concat]

(* ****** ****** *)

implement{}
string_explode
  {n} (x) = let
//
prval () = lemma_string_param (x)
//
viewtypedef res(n) = list_vt (charNZ, n)
//
fun loop
  {n:nat} .<n>.
(
  x: string n, res: &ptr? >> res(n)
) :<!wrt> void = let
  val p = string2ptr (x)
  val c = $UN.ptr1_get<Char> (p)
in
//
if c != CNUL then let
  prval () = __assert () where {
    extern praxi __assert (): [n > 0] void
  }
  val () = res :=
    list_vt_cons {charNZ}{0} (c, _)
  val+list_vt_cons (_, res1) = res
  val x = $UN.cast{string(n-1)}(ptr1_succ<char>(p))
  val () = loop (x, res1)
in
  fold@ (res)
end else let
  prval () = __assert () where {
    extern praxi __assert (): [n == 0] void
  } // end of [prval]
in
  res := list_vt_nil ()
end // end of [if]
//
end // end of [loop]
//
var res: ptr
val () = $effmask_wrt (loop (x, res))
//
in
  res
end // end of [string_explode]

(* ****** ****** *)

implement{}
string_tabulate {n} (n) = let
//
prval () = lemma_g1uint_param (n)
//
fun loop (
  p: ptr, n: size_t, i: size_t
) : void = let
in
//
if i < n then let
  val c = string_tabulate$fopr (i)
  val () = $UN.ptr0_set<char> (p, c)
in
  loop (ptr_succ<char> (p), n, succ (i))
end else
  $UN.ptr0_set<char> (p, CNUL)
// end of [if]
//
end // end of [loop]
//
val n1 = succ(n)
val (pf, fpf | p0) = malloc_gc (n1)
val () = loop (p0, n, g1int2uint (0))
//
in
  castvwtp_trans{strnptr(n)}((pf, fpf | p0))
end // end of [string_tabulate]

(* ****** ****** *)

implement
{}(*tmp*)
string_forall
  (str) = let
//
fun
loop
(
  p: ptr
) : bool = let
  val c0 = $UN.ptr0_get<char>(p)
in
//
if c0 = CNUL then true else
  (if string_forall$pred(c0) then loop(ptr0_succ<char>(p)) else false)
//
end // end of [loop]
//
in
  loop(string2ptr(str))
end // end of [string_forall]

(* ****** ****** *)

implement
{}(*tmp*)
string_iforall
  (str) = let
//
fun
loop
(
  i: int, p: ptr
) : bool = let
  val c0 = $UN.ptr0_get<char>(p)
in
//
if c0 = CNUL then true else
  (if string_iforall$pred(i, c0) then loop(i+1, ptr0_succ<char>(p)) else false)
//
end // end of [loop]
//
in
  loop(0, string2ptr(str))
end // end of [string_iforall]

(* ****** ****** *)

implement{env}
string_foreach$cont (c, env) = true
implement{env}
string_foreach$fwork (c, env) = ((*void*))

implement{}
string_foreach (str) = let
  var env: void = () in string_foreach_env (str, env)
end // end of [string_foreach]

implement{env}
string_foreach_env
  {n} (str, env) = let
//
fun loop (
  p: ptr, env: &env
) : ptr = let
  val c = $UN.ptr0_get<char> (p)
  val cont = (
    if c != CNUL then string_foreach$cont<env> (c, env) else false
  ) : bool // end of [val]
in
  if cont then let
    val () =
      string_foreach$fwork<env> (c, env) in loop (ptr_succ<char> (p), env)
    // end of [val]
  end else (p) // end of [if]
end // end of [fun]
//
val p0 =
  string2ptr (str)
val p1 = loop (p0, env)
//
in
  $UN.cast{sizeLte(n)}(p1 - p0)
end // end of [string_foreach_env]

(* ****** ****** *)

implement{env}
string_rforeach$cont (c, env) = true
implement{env}
string_rforeach$fwork (c, env) = ((*void*))

implement{}
string_rforeach (str) = let
  var env: void = () in string_rforeach_env (str, env)
end // end of [string_rforeach]

implement
{env}(*tmp*)
string_rforeach_env
  {n} (str, env) = let
//
fun loop
(
  p0: ptr, p1: ptr, env: &env >> _
) : ptr = let
in
//
if
(p1 > p0)
then let
  val p2 = ptr_pred<char> (p1)
  val c2 = $UN.ptr0_get<charNZ> (p2)
  val cont =
    string_rforeach$cont<env> (c2, env)
  // end of [val]
in
  if cont
    then let
      val () =
      string_rforeach$fwork<env> (c2, env)
    in
      loop (p0, p2, env)
    end // end of [then]
    else (p1) // end of [else]    
end // end of [then]
else (p1) // end of [else]
//
end // end of [loop]
//
val p0 = ptrcast(str)
val p1 = ptr_add<char> (p0, length(str))
//
in
  $UN.cast{sizeLte(n)}(p1 - loop (p0, p1, env))
end // end of [string_rforeach_env]

(* ****** ****** *)

(*
//
// HX-2013-03: it is now defined as a macro
//
implement
stropt_none () = $UN.cast{stropt(~1)} (the_null_ptr)
*)

(* ****** ****** *)

implement{
} stropt_is_none {n} (x) = (
  $UN.cast{bool(n < 0)} (ptr0_is_null ($UN.cast2ptr (x)))
) // end of [stropt_is_none]

implement{
} stropt_is_some {n} (x) =
(
  $UN.cast{bool(n>=0)} (ptr0_isnot_null ($UN.cast2ptr (x)))
) // end of [stropt_is_some]

(* ****** ****** *)

implement{
} stropt_length (x) = let
  prval () = lemma_stropt_param (x)
in
  if stropt_is_some (x) then
    g1uint2int (string1_length (stropt_unsome(x)))
  else i2ssz(~1) // end of [if]
end // end of [stropt_length]

(* ****** ****** *)

implement fprint_val<string> = fprint_string
implement fprint_val<stropt> = fprint_stropt

(* ****** ****** *)

%{$
//
atstype_string
atspre_string_make_snprintf
(
  atstype_string fmt, ...
) {
  char *res ;
  va_list ap0 ;
//
  va_start(ap0, fmt) ;
//
// HX: [8] is kind of random
//
  res =
  atspre_string_make_vsnprintf(8, fmt, ap0) ;
//
  va_end(ap0) ;
//
  return (res) ;
//
} // end of [atspre_string_make_snprintf]
//
atstype_string
atspre_string_make_vsnprintf
(
  atstype_size bsz
, atstype_string fmt, va_list ap0
) {
//
  int ntot ;
  char *res ;
  va_list ap1 ;
//
  res = atspre_malloc_gc(bsz) ;
//
  va_copy(ap1, ap0) ;
  ntot = vsnprintf(res, bsz, (char*)fmt, ap1) ;
  va_end(ap1) ;
//
  if (ntot >= bsz)
  {
    bsz = ntot + 1 ;
    res = atspre_realloc_gc(res, bsz) ;
    ntot = vsnprintf(res, bsz, (char*)fmt, ap0) ;
  }
//
  if (ntot < 0) {
    atspre_mfree_gc(res) ; return (char*)0 ;
  }
//
  return (res) ;
//
} // end of [atspre_string_make_vsnprintf]
//
%}

(* ****** ****** *)

(* end of [string.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: May, 2012
//
(* ****** ****** *)
//
// HX-2012-05-22:
// this code itself is not particularly useful; however, it sets a concrete
// example demonstrating how iterators can be created.
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/giterator.sats"

(* ****** ****** *)

sortdef t0p = t@ype
stadef itrknd = giter_list_kind
stadef itrkpm = giter_list_param

(* ****** ****** *)

dataviewtype
iterk (
  a:t@ype+, int(*f*), int(*r*)
) = {f,r:int} ITR (a, f, r) of list (a, r) // HX: [f] is spurious!

(* ****** ****** *)

extern
castfn iterk2giter
  {x:t0p}{n:int}
  (xs: iterk (x, 0, n)):<> giter (itrknd, itrkpm(), x, 0, n)
// end of [iterk2giter]

extern
castfn giter2iterk
  {x:t0p}{f,r:int}
  (itr: giter (itrknd, itrkpm(), x, f, r)):<> iterk (x, f, r)
// end of [giter2iterk]

(* ****** ****** *)

implement{x}
giter_make_list
  (xs) = iterk2giter (ITR (xs))
implement
giter_free_list (itr) = let
  val+ ~ITR (xs) = giter2iterk (itr) in xs
end // end of [giter_free_list]

(* ****** ****** *)

extern
praxi encode
  {kpm:tk}{x:t0p}{f,r:int}
  (xs: !iterk (x, f, r) >> giter (itrknd, kpm, x, f, r)): void
// end of [encode]

extern
praxi decode
  {kpm:tk}{x:t0p}{f,r:int}
  (itr: !giter (itrknd, kpm, x, f, r) >> iterk (x, f, r)): void
// end of [decode]

(* ****** ****** *)

implement(x:t0p)
giter_is_atend<itrknd><x>
  (itr) = let
  prval () = decode (itr)
  val+ ITR (xs) = itr
  prval () = encode (itr)
in
  list_is_nil (xs)
end // end of [giter_is_atend]

(* ****** ****** *)

implement(x:t0p)
giter_vttake<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ ITR (xs) = itr; val+ list_cons (x, _) = xs
  prval () = encode (itr)
  var x = x
in
  $UN.vttakeout_void (x)
end // end of [giter_vttake]

(* ****** ****** *)

implement(x:t0p)
giter_inc<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (xs) = itr; val+ list_cons (_, xs1) = xs; val () = xs := xs1
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_inc]

(* ****** ****** *)

implement(x:t0p)
giter_vttake_inc<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (xs) = itr; val+ list_cons (x, xs1) = xs; val () = xs := xs1
  prval () = fold@ (itr)
  prval () = encode (itr)
  var x = x
in
  $UN.vttakeout_void (x)
end // end of [giter_vttake_inc]

(* ****** ****** *)

(* end of [giter_list.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gprint.atxt
** Time of generation: Sat Oct 17 15:19:58 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2012 *)

(* ****** ****** *)

implement
{}(*tmp*)
gprint$out () = stdout_ref

(* ****** ****** *)

implement
{}(*tmp*)
gprint_newline () = let
  val out = gprint$out () in fprint_newline (out)
end // end of [gprint_newline]

(* ****** ****** *)

implement
{a}(*tmp*)
gprint_val (x) = let
  val out = gprint$out () in fprint_val<a> (out, x)
end // end of [gprint_val]

(* ****** ****** *)

implement
{a}(*tmp*)
gprint_ref (x) = let
  val out = gprint$out () in fprint_ref<a> (out, x)
end // end of [gprint_ref]

(* ****** ****** *)
//
implement
{}(*tmp*)
gprint_int (x) =
  fprint_val<int> (gprint$out (), x)
implement
{}(*tmp*)
gprint_char (x) =
  fprint_val<char> (gprint$out (), x)
implement
{}(*tmp*)
gprint_float (x) =
  fprint_val<float> (gprint$out (), x)
implement
{}(*tmp*)
gprint_double (x) =
  fprint_val<double> (gprint$out (), x)
implement
{}(*tmp*)
gprint_string (x) =
  fprint_val<string> (gprint$out (), x)
//
implement gprint_val<int> (x) = gprint_int (x)
implement gprint_val<char> (x) = gprint_char (x)
implement gprint_val<float> (x) = gprint_float (x)
implement gprint_val<double> (x) = gprint_double (x)
implement gprint_val<string> (x) = gprint_string (x)
//
(* ****** ****** *)
//
implement{}
gprint_list$beg () = gprint_string "("
implement{}
gprint_list$end () = gprint_string ")"
implement{}
gprint_list$sep () = gprint_string ", "
//
(* ****** ****** *)

implement
{a}(*tmp*)
gprint_list (xs) = let
//
typedef tenv = int
//
implement
list_foreach$fwork<a><tenv>
  (x, env) = let
  val () =
    if env > 0 then gprint_list$sep ()
  val () = env := succ (env)
in
  gprint_val (x)
end // end of [list_foreach$fwork]
//
var env: tenv = 0
val () = gprint_list$beg ()
val () = list_foreach_env<a><tenv> (xs, env)
val () = gprint_list$end ()
//
in
  // nothing
end // end of [gprint_list]

implement
(a)(*tmp*)
gprint_val<List(a)> (xs) = gprint_list<a> (xs)

(* ****** ****** *)
//
implement{}
gprint_listlist$beg1 () = gprint_string "("
implement{}
gprint_listlist$end1 () = gprint_string ")"
implement{}
gprint_listlist$sep1 () = gprint_string ", "
//
implement{}
gprint_listlist$beg2 () = gprint_string "("
implement{}
gprint_listlist$end2 () = gprint_string ")"
implement{}
gprint_listlist$sep2 () = gprint_string ", "
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
gprint_listlist
  (xss) = let
//
typedef xs = List (a)
//
implement
gprint_val<xs> (xs) = let
//
implement gprint_list$beg<> () = gprint_listlist$beg2 ()
implement gprint_list$end<> () = gprint_listlist$end2 ()
implement gprint_list$sep<> () = gprint_listlist$sep2 ()
//
in
  gprint_list<a> (xs)
end // end of [gprint_val]
//
implement gprint_list$beg<> () = gprint_listlist$beg1 ()
implement gprint_list$end<> () = gprint_listlist$end1 ()
implement gprint_list$sep<> () = gprint_listlist$sep1 ()
//
in
  gprint_list<xs> (xss)
end // end of [gprint_listlist]
//
(* ****** ****** *)
//
implement{}
gprint_array$beg () = gprint_string "("
implement{}
gprint_array$end () = gprint_string ")"
implement{}
gprint_array$sep () = gprint_string ", "
//
(* ****** ****** *)

implement
{a}(*tmp*)
gprint_array (A, n) = let
//
typedef tenv = size_t
//
implement
(env)(*tmp*)
array_iforeach$fwork<a><env>
  (i, x, env) = let
  val () = if i > 0 then gprint_array$sep ()
in
  gprint_ref<a> (x)
end // end of [array_iforeach$fwork]
//
var env: void = ()
val () = gprint_array$beg ()
val _(*n*) = array_iforeach<a> (A, n)
val () = gprint_array$end ()
//
in
  // nothing
end // end of [gprint_array]

(* ****** ****** *)

implement
{a}(*tmp*)
gprint_arrayptr
  (A, n) =
{
  val p = ptrcast (A)
  prval pf = arrayptr_takeout (A)
  val () = gprint_array<a> (!p, n)
  prval () = arrayptr_addback (pf | A)
} (* end of [gprint_arrayptr] *)

(* ****** ****** *)

implement
{a}(*tmp*)
gprint_arrayref
  (A, n) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A)
//
in
  $effmask_ref (gprint_array<a> (!p, n))
end // end of [gprint_arrayref]

(* ****** ****** *)

implement
{a}(*tmp*)
gprint_arrszref
  (ASZ) = () where {
//
var n: size_t
val A =
  arrszref_get_refsize<> (ASZ, n)
//
val () = gprint_arrayref<a> (A, n)
//
} (* end of [gprint_arrszref] *)

(* ****** ****** *)

(* end of [gprint.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/reference.atxt
** Time of generation: Sat Oct 17 15:19:53 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

implement
{a}(*tmp*)
ref = ref_make_elt<a>

implement
{a}(*tmp*)
ref_make_elt (x0) = let
  val (pfat, pfgc | p) = ptr_alloc<a> ()
  prval () = mfree_gc_v_elim (pfgc)
  val () = !p := x0 // initialization
in
  ref_make_viewptr (pfat | p)
end // end of [ref_make_elt]

(* ****** ****** *)

implement
{a}(*tmp*)
ref_get_elt
  (r) = !p where {
  val (vbox _ | p) = ref_get_viewptr (r)
} // end of [ref_get_elt]

implement
{a}(*tmp*)
ref_set_elt
  (r, x) = let
  val (vbox _ | p) = ref_get_viewptr (r)
in
  !p := x // assignment
end // end of [ref_set_elt]

implement
{a}(*tmp*)
ref_exch_elt
  (r, x) = let
  val (vbox _ | p) = ref_get_viewptr (r)
in
  !p :=: x // exchanging
end // end of [ref_exch_elt]

(* ****** ****** *)

implement
{}(*tmp*)
ref_app_fun{a} (r, f) = let
  val (vbox _ | p) = ref_get_viewptr (r) in f (!p)
end // end of [ref_app_fun]

implement
{}(*tmp*)
ref_app_funenv{a}
  (pfv | r, f, env) = let
  val (vbox _ | p) = ref_get_viewptr (r) in f (pfv | !p, env)
end // end of [ref_app_funenv]

(* ****** ****** *)

implement
{}(*tmp*)
ref_vtakeout{a} (r) = let
//
val (
  vbox pf | p
) = ref_get_viewptr (r)
//
prval (pf, fpf) = __copy (pf) where
{
  extern praxi __copy {l:addr} (pf: !a @ l): (a @ l, a @ l -<lin,prf> void)
} (* end of [prval] *)
//
in
  (pf, fpf | p)
end // end of [ref_vtakeout]

(* ****** ****** *)

(* end of [reference.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/bool.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

(*
//
// HX: see CATS/bool.cats
//
implement
bool2string
  (b) = if b then "true" else "false"
// end of [bool2string]
*)

(* ****** ****** *)

(*
//
// HX: see CATS/bool.cats
//
implement
fprint_bool (out, x) =
  fprint_string (out, bool2string (x))
// end of [fprint_bool]
*)

implement fprint_val<bool> = fprint_bool

(* ****** ****** *)

(* end of [bool.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list_vt.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)
//
implement
{a}(*tmp*)
list_vt_make_sing (x) =
  list_vt_cons{a}(x, list_vt_nil)
implement
{a}(*tmp*)
list_vt_make_pair (x1, x2) =
  list_vt_cons{a}(x1, list_vt_cons{a}(x2, list_vt_nil))
//
(* ****** ****** *)

implement
{a}(*tmp*)
print_list_vt (xs) = fprint_list_vt<a> (stdout_ref, xs)
implement
{a}(*tmp*)
prerr_list_vt (xs) = fprint_list_vt<a> (stderr_ref, xs)

(* ****** ****** *)

implement
{}(*tmp*)
fprint_list_vt$sep (out) = fprint_list$sep<> (out)

implement
{a}(*tmp*)
fprint_list_vt
  (out, xs) = let
//
implement(env)
list_vt_iforeach$fwork<a><env>
  (i, x, env) = let
  val () =
    if i > 0 then fprint_list_vt$sep<(*none*)> (out)
  // end of [val]
in
  fprint_ref<a> (out, x)
end // end of [list_iforeach$fwork]
//
val _(*n*) = list_vt_iforeach<a> (xs)
//
in
  // nothing
end // end of [fprint_list_vt]

implement
{a}(*tmp*)
fprint_list_vt_sep
  (out, xs, sep) = let
//
implement
fprint_list_vt$sep<(*none*)> (out) = fprint_string (out, sep)
//
in
  fprint_list_vt<a> (out, xs)
end // end of [fprint_list_vt_sep]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_is_nil (xs) =
  case+ xs of list_vt_nil () => true | _ =>> false
// end of [list_vt_is_nil]

implement
{x}(*tmp*)
list_vt_is_cons (xs) =
  case+ xs of list_vt_cons _ => true | _ =>> false
// end of [list_vt_is_cons]

implement
{x}(*tmp*)
list_vt_is_sing (xs) =
  case+ xs of list_vt_sing (x) => true | _ =>> false
// end of [list_vt_is_sing]

implement
{x}(*tmp*)
list_vt_is_pair (xs) =
  case+ xs of list_vt_pair (x1, x2) => true | _ =>> false
// end of [list_vt_is_pair]

(* ****** ****** *)

implement
{}(*tmp*)
list_vt_unnil (xs) = let
  val+~list_vt_nil () = xs in (*nothing*)
end // end of [list_vt_unnil]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_uncons (xs) = let
  val+~list_vt_cons (x, xs1) = xs in xs := xs1; x
end // end of [list_vt_uncons]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_length (xs) = let
//
fun loop
  {i,j:nat} .<i>.
(
  xs: !list_vt (a, i), j: int j
) :<> int (i+j) = let
in
//
case+ xs of
| list_vt_cons
    (_, xs) => loop (xs, j + 1)
| list_vt_nil () => j
//
end // end of [loop]
//
prval () = lemma_list_vt_param (xs)
//
in
  loop (xs, 0)
end // end of [list_vt_length]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_copy (xs) = let
//
implement
{x2}(*tmp*)
list_vt_copylin$copy
  (x) = $UN.ptr0_get<x2>(addr@x)
//
in
  $effmask_all (list_vt_copylin<x> (xs))
end // end of [list_vt_copy]

implement
{x}(*tmp*)
list_vt_copylin
  (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: !list_vt (x, n), res: &ptr? >> list_vt (x, n)
) : void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val x =
      list_vt_copylin$copy<x> (x)
    val () =
      res := list_vt_cons{x}{0}(x, _)
    val+list_vt_cons (_, res1) = res
    val () = loop (xs1, res1)
    prval () = fold@ (xs)
    prval () = fold@ (res)
  in
    // nothing
  end // end of [list_vt_cons]
| list_vt_nil () => res := list_vt_nil ()
//
end // end of [loop]
//
var res: ptr
val () =
  $effmask_all(loop (xs, res))
//
in
  res
end // end of [list_vt_copylin]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_copylin_fun
  (xs, f) = let
//
implement
{x2}(*tmp*)
list_vt_copylin$copy
  (x) = x2 where
{
//
val f2 =
  $UN.cast{(&RD(x2))->x2}(f)
//
val x2 = $effmask_all(f2(x))
//
} (* end of [copy] *)
//
in
  list_vt_copylin<x> (xs)
end // end of [list_vt_copylin_fun]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_getref_at
  {n}{i} (xs, i) = let
//
fun loop {
  n,i:nat | i <= n
} .<i>. (
  xs: &list_vt (a, n), i: int i
) :<> Ptr1 = let
in
  if i > 0 then let
    val+@list_vt_cons (_, xs1) = xs
    val res = loop{n-1,i-1}(xs1, pred(i))
  in
    fold@ (xs); res
  end else
    $UN.cast2Ptr1(addr@(xs))
  // end of [if]
end // end of [loop]
//
in
  $UN.ptr2cptr{list_vt(a,n-i)}(loop (xs, i))
end // end of [list_vt_getref_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_get_at
  {n} (xs, i) = x where
{
//
var xs = __ref (xs) where
{
  extern
  castfn __ref
    (xs: !list_vt (a, n)):<> list_vt (a, n)
} // end of [val]
//
val pi = list_vt_getref_at (xs, i)
val+list_cons (x, _) =
  $UN.ptr1_get<List1(a)> (cptr2ptr(pi))
//
prval () = __unref (xs) where
{
  extern praxi __unref (xs: list_vt (a, n)): void
} // end of [prval]
//
} // end of [list_vt_get_at]

implement
{a}(*tmp*)
list_vt_set_at
  {n} (xs, i, x0) = let
//
var xs = let
  extern
  castfn __ref
    (xs: !list_vt (a, n)):<> list_vt (a, n)
  // end of [__ref]
in
  __ref (xs)
end // end of [val]
//
val pi = list_vt_getref_at (xs, i)
val (pf, fpf | pi) = $UN.cptr_vtake (pi)
val+@list_vt_cons (x1, xs1) = !pi
val () = x1 := x0
prval () = fold@ (!pi)
prval () = fpf (pf)
//
prval () = let
  extern praxi __unref (xs: list_vt (a, n)): void
in
  __unref (xs)
end // end of [prval]
//
in
  // nothing
end // end of [list_vt_set_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_exch_at
  {n} (xs, i, x0) = let
//
var xs = __ref (xs) where
{
  extern
  castfn __ref
    (xs: !list_vt (a, n)):<> list_vt (a, n)
} // end of [val]
//
val pi = list_vt_getref_at (xs, i)
val (pf, fpf | pi) = $UN.cptr_vtake (pi)
val+@list_vt_cons (x1, xs1) = !pi
//
val t = x1
val () = x1 := x0
val () = x0 := t
//
prval () = fold@ (!pi)
prval () = fpf (pf)
//
prval () = __unref (xs) where
{
  extern praxi __unref (xs: list_vt (a, n)): void
} // end of [prval]
//
in
  // nothing
end // end of [list_vt_exch_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_insert_at
  {n} (xs, i, x) = let
//
val pi = list_vt_getref_at (xs, i)
val xs_i = $UN.cptr_get (pi)
val xs1_i = list_vt_cons (x, xs_i)
val () =
  $UN.ptr1_set<List1_vt(a)> (cptr2ptr(pi), xs1_i)
//
prval () = __assert (xs) where
{
  extern
  praxi __assert (xs: &list_vt (a, n) >> list_vt (a, n+1)): void
} // end of [prval]
in
  // nothing
end // end of [list_vt_insert_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_takeout_at
{n} (xs, i) = x1 where
{
//
val pi = list_vt_getref_at (xs, i)
val xs_i = $UN.cptr_get (pi)
val+~list_vt_cons (x1, xs1_i) = xs_i
val () =
  $UN.ptr1_set<List0_vt(a)> (cptr2ptr(pi), xs1_i)
//
prval () =
__assert (xs) where
{
  extern
  praxi __assert (xs: &list_vt (a, n) >> list_vt (a, n-1)): void
} (* end of [prval] *)
//
} // end of [list_vt_takeout_at]

(* ****** ****** *)
//
implement
{a}(*tmp*)
list_vt_copy (xs) =
  list_copy<a> ($UN.list_vt2t(xs))
//
(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_free (xs) = let
//
implement
(a2:t0p)
list_vt_freelin$clear<a2>
  (x) = let
  prval () = topize (x) in (*void*)
end // end of [list_vt_freelin$clear]
//
in
  list_vt_freelin<a> (xs)
end // end of [list_vt_free]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_freelin$clear (x) = gclear_ref (x)
implement
{a}(*tmp*)
list_vt_freelin (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list_vt (a, n)
) :<!wrt> void =
(
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () =
        list_vt_freelin$clear<a> (x)
      val xs1 = xs1
      val () = free@{a}{0}(xs)
    in
      loop (xs1)
    end // end of [list_vt_cons]
  | ~list_vt_nil () => ()
) (* end of [loop] *)
//
in
  loop (xs)
end // end of [list_vt_freelin]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_freelin_fun
  (xs, f) = let
//
implement
{a2}(*tmp*)
list_vt_freelin$clear
  (x) = () where
{
//
val f2 =
  $UN.cast{(&a2 >> _?) -> void}(f)
//
val ((*void*)) = $effmask_all(f2(x))
//
} (* end of [clear] *)
//
in
  list_vt_freelin<a> (xs)
end // end of [list_vt_freelin_fun]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_uninitize$clear (x) = gclear_ref (x)

implement
{a}(*tmp*)
list_vt_uninitize
  {n} (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: !list_vt (a, n) >> list_vt (a?, n)
) :<!wrt> void =
(
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () =
        list_vt_uninitize$clear (x)
      val () = loop (xs1)
      prval () = fold@ {a?} (xs)
    in
      // nothing
    end // end of [list_vt_cons]
  | @list_vt_nil () => fold@ {a?} (xs)
) (* end of [loop] *)
//
in
  loop (xs)
end // end of [list_vt_uninitize]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_append
  {m,n} (xs, ys) = let
//
prval () = lemma_list_vt_param (xs)
prval () = lemma_list_vt_param (ys)
//
fun loop
  {m:nat} .<m>.
(
  xs: &list_vt (a, m) >> list_vt (a, m+n), ys: list_vt (a, n)
) :<!wrt> void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val () = loop (xs1, ys); prval () = fold@ (xs) in (*none*)
  end // end of [list_vt_cons]
| ~list_vt_nil () => (xs := ys)
//
end (* end of [loop] *)
//
var res = xs
val () = loop (res, ys)
//
in
  res
end // end of [list_vt_append]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_extend
  (xs, y) = list_vt_append<a> (xs, cons_vt{a}(y, nil_vt()))
// end of [list_vt_extend]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_unextend
  (xs) = let
//
fun loop
  {n:pos} .<n>.
(
  xs: &list_vt (a, n) >> list_vt (a, n-1)
) :<!wrt> (a) = let
//
val+@list_vt_cons (x, xs1) = xs
//
in
//
case+ xs1 of
| list_vt_cons _ => let
    val x = loop (xs1)
    prval () = fold@ (xs)
  in
    x
  end // end of [list_vt_cons]
| list_vt_nil () => let
    val x = x
    val xs1 = xs1
    val () = free@{a}{0}(xs)
  in
    xs := xs1; x
  end // end of [list_vt_nil]
//
end // end of [loop]
//
in
  loop (xs)
end // end of [list_vt_unextend]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_reverse (xs) = list_vt_reverse_append<a> (xs, list_vt_nil)

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_reverse_append
  (xs, ys) = let
//
prval () = lemma_list_vt_param (xs)
prval () = lemma_list_vt_param (ys)
//
fun loop
  {m,n:nat} .<m>.
(
  xs: list_vt (a, m), ys: list_vt (a, n)
) :<!wrt> list_vt (a, m+n) =
  case+ xs of
  | @list_vt_cons
      (_, xs1) => let
      val xs1_ = xs1
      val () = xs1 := ys; prval () = fold@ (xs)
    in
      loop (xs1_, xs)
    end // end of [cons]
  | ~list_vt_nil () => ys
(* end of [loop] *)
//
in
  loop (xs, ys)
end // end of [list_vt_reverse_append]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_split_at
  (xs, i) = let
//
fun loop
  {n:int}
  {i:nat | i <= n} .<n>.
(
  xs: &list_vt (x, n) >> list_vt (x, i), i: int i
) :<!wrt> list_vt (x, n-i) =
(
if i > 0 then let
//
val+@cons_vt (x, xs1) = xs
val res = loop (xs1, i-1)
prval ((*void*)) = fold@ (xs)
//
in
  res
end else let
  val res = xs
  val () = xs := list_vt_nil((*void*))
in
  res
end // end of [if]
) // end of [loop]
//
var xs = xs
val res = loop (xs, i)
//
in
  (xs, res)
end // end of [list_split_vt_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_concat
  (xss) = let
//
viewtypedef VT = List_vt (a)
viewtypedef VT0 = List0_vt (a)
//
fun loop
  {n:nat} .<n>.
(
  res: VT, xss: list_vt (VT, n)
) :<!wrt> VT0 = let
in
  case+ xss of
  | ~list_vt_cons
      (xs, xss) => let
      val res = list_vt_append<a> (xs, res)
    in
      loop (res, xss)
    end // end of [list_vt_cons]
  | ~list_vt_nil () => let
      prval () = lemma_list_vt_param (res) in res
    end // end of [list_vt_nil]
end (* end of [loop] *)
//
val xss = list_vt_reverse (xss)
//
prval () = lemma_list_vt_param (xss)
//
in
//
case+ xss of
| ~list_vt_cons
    (xs, xss) => loop (xs, xss)
| ~list_vt_nil () => list_vt_nil ()
//
end // end of [list_vt_concat]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_separate (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list_vt (a, n)
, res1: &ptr? >> list_vt (a, n1)
, res2: &ptr? >> list_vt (a, n2)
) : #[n1,n2:nat | n1+n2==n] void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs_tl) => let
    val xs_tl_v = xs_tl
    val test = list_vt_separate$pred (x)
  in
    if test then let
      val () = res1 := xs
      val () = loop (xs_tl_v, xs_tl, res2)
    in
      fold@ (res1)
    end else let
      val () = res2 := xs
      val () = loop (xs_tl_v, res1, xs_tl)
    in
      fold@ (res2)
    end // end of [if]
  end // end of [list_vt_cons]
| ~list_vt_nil () => (
    res1 := list_vt_nil; res2 := list_vt_nil
  )
//
end // end of [loop]
//
var res1: ptr
var res2: ptr
val () = loop (xs, res1, res2)
val () = xs := res1
//
in
  res2
end // end of [list_vt_separate]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_filter (xs) = let
//
implement
list_vt_filterlin$pred<a>
  (x) = list_vt_filter$pred<a> (x)
implement
list_vt_filterlin$clear<a>
  (x) = let
  prval () = topize (x) in (*void*)
end // end of [list_vt_filterlin$clear]
//
in
  list_vt_filterlin<a> (xs)
end // end of [list_vt_filter]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_filterlin (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>.
(
  xs: &list_vt (a, n) >> listLte_vt (a, n)
) :<!wrt> void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val test =
      list_vt_filterlin$pred<a> (x)
  in
    if test then let
      val () = loop (xs1)
    in
      fold@ (xs)
    end else let
      val xs1 = xs1
      val () =
        list_vt_filterlin$clear<a> (x)
      val () = free@{a}{0}(xs)
      val () = xs := xs1
    in
      loop (xs)
    end // end of [if]
  end // end of [list_vt_cons]
| @list_vt_nil () => fold@ (xs)
//
end // end of [loop]
//
var xs = xs
//
in
  loop (xs); xs
end // end of [list_vt_filterlin]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_filterlin$clear (x) = gclear_ref (x)

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_app
  (xs) = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val () =
      list_vt_app$fwork<a> (x)
    val () = list_vt_app<a> (xs1)
    prval () = fold@ (xs)
  in
    // nothing
  end // end of [cons]
| list_vt_nil ((*void*)) => ()
//
end // end of [list_vt_app]

implement
{a}(*tmp*)
list_vt_appfree
  (xs) = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val xs1 = xs1
    val () = list_vt_appfree$fwork<a> (x)
    val () = free@ {a}{0} (xs)
  in
    list_vt_appfree<a> (xs1)
  end // end of [cons]
| ~list_vt_nil ((*void*)) => ()
//
end // end of [list_vt_appfree]

(* ****** ****** *)

implement
{a}{b}
list_vt_map
  (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: !list_vt (a, n)
, res: &ptr? >> list_vt (b, n)
) : void = let
in
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val y =
        list_vt_map$fopr<a><b> (x)
      // end of [val]
      val () = res := list_vt_cons{b}{0}(y, _)
      val+list_vt_cons (_, res1) = res
      val () = loop (xs1, res1)
      val () = fold@ (xs)
      prval () = fold@ (res)
    in
      // nothing
    end // end of [list_vt_cons]
  | list_vt_nil () => (res := list_vt_nil ())
end // end of [loop]
//
var res: ptr
val () = loop (xs, res)
//
in
  res
end // end of [list_vt_map]

(* ****** ****** *)

implement
{x}{y}(*tmp*)
list_vt_map_fun
  (xs, f) = let
//
implement
{x2}{y2}
list_vt_map$fopr (x2) = let
  val f = $UN.cast{(&x2)->y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_map$fopr]
//
in
  list_vt_map<x><y> (xs)
end // end of [list_vt_map_fun]

implement
{x}{y}(*tmp*)
list_vt_map_clo
  (xs, f) = let
//
val f = $UN.cast{(&x) -<cloref1> y}(addr@f)
//
implement
{x2}{y2}
list_vt_map$fopr (x2) = let
  val f = $UN.cast{(&x2)-<cloref1>y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_map$fopr]
//
in
  list_vt_map<x><y> (xs)
end // end of [list_vt_map_clo]

implement
{x}{y}(*tmp*)
list_vt_map_cloref
  (xs, f) = let
//
implement
{x2}{y2}
list_vt_map$fopr (x2) = let
  val f = $UN.cast{(&x2)-<cloref1>y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_map$fopr]
//
in
  list_vt_map<x><y> (xs)
end // end of [list_vt_map_cloref]

(* ****** ****** *)

implement
{a}{b}
list_vt_mapfree
  (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list_vt (a, n)
, res: &ptr? >> list_vt (b, n)
) : void = let
in
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val y =
      list_vt_mapfree$fopr<a><b> (x)
      val xs1_val = xs1
      val ((*freed*)) = free@{a}{0}(xs)
      val () = res := list_vt_cons{b}{0}(y, _)
      val+list_vt_cons (_, res1) = res
      val () = loop (xs1_val, res1)
      prval ((*folded*)) = fold@(res)
    in
      // nothing
    end // end of [list_vt_cons]
  | ~list_vt_nil () => (res := list_vt_nil ())
end // end of [loop]
//
var res: ptr
val () = loop (xs, res)
//
in
  res
end // end of [list_vt_mapfree]

(* ****** ****** *)

implement
{x}{y}(*tmp*)
list_vt_mapfree_fun
  (xs, f) = let
//
implement
{x2}{y2}
list_vt_mapfree$fopr (x2) = let
  val f = $UN.cast{(&x2>>_?)->y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_mapfree$fopr]
//
in
  list_vt_mapfree<x><y> (xs)
end // end of [list_vt_mapfree_fun]

implement
{x}{y}(*tmp*)
list_vt_mapfree_clo
  (xs, f) = let
//
val f =
$UN.cast{(&x>>_?) -<cloref1> y}(addr@f)
//
implement
{x2}{y2}
list_vt_mapfree$fopr (x2) = let
  val f = $UN.cast{(&x2>>_?)-<cloref1>y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_mapfree$fopr]
//
in
  list_vt_mapfree<x><y> (xs)
end // end of [list_vt_mapfree_clo]

implement
{x}{y}(*tmp*)
list_vt_mapfree_cloref
  (xs, f) = let
//
implement
{x2}{y2}
list_vt_mapfree$fopr (x2) = let
  val f = $UN.cast{(&x2>>_?)-<cloref1>y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_mapfree$fopr]
//
in
  list_vt_mapfree<x><y> (xs)
end // end of [list_vt_mapfree_cloref]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_foreach
  (xs) = let
  var env: void = ()
in
  list_vt_foreach_env<x><void> (xs, env)
end // end of [list_vt_foreach]

implement
{x}{env}
list_vt_foreach_env
  (xs, env) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>.
(
  xs: !list_vt (x, n), env: &env
) : void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val test =
      list_vt_foreach$cont (x, env)
    // end of [val]
  in
    if test then let
      val () =
        list_vt_foreach$fwork<x><env> (x, env)
      val () = loop (xs1, env)
      prval ((*void*)) = fold@ (xs)
    in
      // nothing
    end else let
      prval ((*void*)) = fold@ (xs) in (*nothing*)
    end // end of [if]
  end // end of [cons]
| list_vt_nil ((*void*)) => ()
//
end // end of [loop]
//
in
  loop (xs, env)
end // end of [list_vt_foreach_env]

(* ****** ****** *)

implement
{x}{env}
list_vt_foreach$cont (x, env) = true

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_foreach_fun
  {fe} (xs, f) = let
//
prval () = lemma_list_vt_param (xs)
//
fun
loop
{n:nat} .<n>.
(
  xs: !list_vt (a, n), f: (&a) -<fe> void
) :<fe> void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = f (x)
      val () = loop (xs1, f)
    in
      fold@ (xs)
    end // end of [cons]
  | list_vt_nil ((*void*)) => ()
// end of [loop]
in
  loop (xs, f)
end // end of [list_vt_foreach_fun]

implement
{a}(*tmp*)
list_vt_foreach_funenv
  {v}{vt}{fe}
  (pf | xs, f, env) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  pf: !v
| xs: !list_vt (a, n)
, f: (!v | &a, !vt) -<fe> void
, env: !vt
) :<fe> void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = f (pf | x, env)
      val () = loop (pf | xs1, f, env)
    in
      fold@ (xs)
    end // end of [cons]
  | list_vt_nil ((*void*)) => ()
// end of [loop]
//
in
  loop (pf | xs, f, env)
end // end of [list_vt_foreach_funenv]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_iforeach
  (xs) = let
  var env: void = ()
in
  list_vt_iforeach_env<x><void> (xs, env)
end // end of [list_vt_iforeach]

implement
{x}{env}
list_vt_iforeach_env
  (xs, env) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat}{i:nat} .<n>. (
  i: int i, xs: !list_vt (x, n), env: &env
) : intBtwe(i, n+i) = let
in
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val test =
        list_vt_iforeach$cont<x><env> (i, x, env)
      // end of [val]
    in
      if test then let
        val () =
          list_vt_iforeach$fwork<x><env> (i, x, env)
        // end of [val]
        val i = loop (succ(i), xs1, env)
        prval () = fold@ (xs)
      in
        i // the number of processed elements
      end else let
        prval () = fold@ (xs)
      in
        i // the number of processed elements
      end // end of [if]
    end // end of [cons]
  | list_vt_nil ((*void*)) => (i) // |processed-elements|
end // end of [loop]
//
in
  loop (0, xs, env)
end // end of [list_vt_iforeach_env]

(* ****** ****** *)

implement
{x}{env}
list_vt_iforeach$cont (i, x, env) = true

(* ****** ****** *)

#include "./SHARE/list_vt_mergesort.dats"
#include "./SHARE/list_vt_quicksort.dats"

(* ****** ****** *)

(* end of [list_vt.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/float.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)
//
(* ****** ****** *)
//
staload UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)


(* ****** ****** *)

implement
g0int2float<intknd,fltknd> = g0int2float_int_float
implement
g0int2float<intknd,dblknd> = g0int2float_int_double
implement
g0int2float<lintknd,dblknd> = g0int2float_lint_double

(* ****** ****** *)

implement
g0float2int<fltknd, intknd> = g0float2int_float_int
implement
g0float2int<fltknd, lintknd> = g0float2int_float_lint
implement
g0float2int<dblknd, intknd> = g0float2int_double_int
implement
g0float2int<dblknd, lintknd> = g0float2int_double_lint
implement
g0float2int<dblknd, llintknd> = g0float2int_double_llint

(* ****** ****** *)

implement
g0float2float<fltknd,fltknd> = g0float2float_float_float
implement
g0float2float<fltknd,dblknd> = g0float2float_float_double
implement
g0float2float<dblknd,fltknd> = g0float2float_double_float
implement
g0float2float<dblknd,dblknd> = g0float2float_double_double

(* ****** ****** *)

implement g0string2float<dblknd> = g0string2float_double

(* ****** ****** *)

implement g0float_neg<fltknd> = g0float_neg_float
implement g0float_abs<fltknd> = g0float_abs_float
implement g0float_succ<fltknd> = g0float_succ_float
implement g0float_pred<fltknd> = g0float_pred_float

implement g0float_add<fltknd> = g0float_add_float
implement g0float_sub<fltknd> = g0float_sub_float
implement g0float_mul<fltknd> = g0float_mul_float
implement g0float_div<fltknd> = g0float_div_float
implement g0float_mod<fltknd> = g0float_mod_float

implement g0float_lt<fltknd> = g0float_lt_float
implement g0float_lte<fltknd> = g0float_lte_float
implement g0float_gt<fltknd> = g0float_gt_float
implement g0float_gte<fltknd> = g0float_gte_float
implement g0float_eq<fltknd> = g0float_eq_float
implement g0float_neq<fltknd> = g0float_neq_float
implement g0float_compare<fltknd> = g0float_compare_float

implement g0float_max<fltknd> = g0float_max_float
implement g0float_min<fltknd> = g0float_min_float

(* ****** ****** *)

implement g0float_neg<dblknd> = g0float_neg_double
implement g0float_abs<dblknd> = g0float_abs_double
implement g0float_succ<dblknd> = g0float_succ_double
implement g0float_pred<dblknd> = g0float_pred_double

implement g0float_add<dblknd> = g0float_add_double
implement g0float_sub<dblknd> = g0float_sub_double
implement g0float_mul<dblknd> = g0float_mul_double
implement g0float_div<dblknd> = g0float_div_double
implement g0float_mod<dblknd> = g0float_mod_double

implement g0float_lt<dblknd> = g0float_lt_double
implement g0float_lte<dblknd> = g0float_lte_double
implement g0float_gt<dblknd> = g0float_gt_double
implement g0float_gte<dblknd> = g0float_gte_double
implement g0float_eq<dblknd> = g0float_eq_double
implement g0float_neq<dblknd> = g0float_neq_double
implement g0float_compare<dblknd> = g0float_compare_double

implement g0float_max<dblknd> = g0float_max_double
implement g0float_min<dblknd> = g0float_min_double

(* ****** ****** *)

implement g0float_neg<ldblknd> = g0float_neg_ldouble
implement g0float_abs<ldblknd> = g0float_abs_ldouble
implement g0float_succ<ldblknd> = g0float_succ_ldouble
implement g0float_pred<ldblknd> = g0float_pred_ldouble

implement g0float_add<ldblknd> = g0float_add_ldouble
implement g0float_sub<ldblknd> = g0float_sub_ldouble
implement g0float_mul<ldblknd> = g0float_mul_ldouble
implement g0float_div<ldblknd> = g0float_div_ldouble
implement g0float_mod<ldblknd> = g0float_mod_ldouble

implement g0float_lt<ldblknd> = g0float_lt_ldouble
implement g0float_lte<ldblknd> = g0float_lte_ldouble
implement g0float_gt<ldblknd> = g0float_gt_ldouble
implement g0float_gte<ldblknd> = g0float_gte_ldouble
implement g0float_eq<ldblknd> = g0float_eq_ldouble
implement g0float_neq<ldblknd> = g0float_neq_ldouble
implement g0float_compare<ldblknd> = g0float_compare_ldouble

implement g0float_max<ldblknd> = g0float_max_ldouble
implement g0float_min<ldblknd> = g0float_min_ldouble

(* ****** ****** *)
//
implement fprint_val<float> = fprint_float
implement fprint_val<double> = fprint_double
implement fprint_val<ldouble> = fprint_ldouble
//
(* ****** ****** *)

implement
{tk}(*tk*)
g0float_npow
  (x, n) = let
//
typedef gfloat = g0float(tk)
//
fun
loop
(
  x: gfloat, res: gfloat, n: int
) : gfloat = (
//
if
(n > 1)
then let
  val n2 = n >> 1
  val b0 = n - (n2 << 1)
  val xx = x * x
in
  if b0 = 0
    then loop(xx, res, n2) else loop(xx, x * res, n2)
  // end of [if]
end // end of [then]
else (
  if n > 0 then x * res else res
) (* end of [else] *)
//
) (* end of [loop] *)
//
val res = $UN.cast{gfloat}(1.0)
//
in
  $effmask_all(loop(x, res, n))
end // end of [g0float_npow]

(* ****** ****** *)

(* end of [float.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/pointer.atxt
** Time of generation: Sat Oct 17 15:19:51 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

primplmnt
lemma_ptr_param
  {l} (p) = lemma_addr_param {l} ()
// end of [lemma_ptr_param]

(* ****** ****** *)

primplmnt
ptr_get_index {l} (p) = eqaddr_make {l, l} ()

(* ****** ****** *)

implement{a}
ptr0_succ (p) = add_ptr_bsz (p, sizeof<a>)
implement{a}
ptr0_pred (p) = sub_ptr_bsz (p, sizeof<a>)

(* ****** ****** *)
//
implement{a}{tk}
ptr0_add_gint (p, i) =
  add_ptr_bsz (p, g0int2uint(i) * sizeof<a>)
implement{a}{tk}
ptr0_sub_gint (p, i) =
  sub_ptr_bsz (p, g0int2uint(i) * sizeof<a>)
//
implement{a}{tk}
ptr0_add_guint (p, i) =
  add_ptr_bsz (p, g0uint2uint(i) * sizeof<a>)
implement{a}{tk}
ptr0_sub_guint (p, i) =
  sub_ptr_bsz (p, g0uint2uint(i) * sizeof<a>)
//
(* ****** ****** *)
//
implement{a}
ptr1_succ {l} (p) =
  $UN.cast{ptr(l+sizeof(a))}(ptr0_succ<a> (p))
implement{a}
ptr1_pred {l} (p) =
  $UN.cast{ptr(l-sizeof(a))}(ptr0_pred<a> (p))
//
(* ****** ****** *)
//
implement{a}{tk}
ptr1_add_gint {l}{i} (p, i) =
  $UN.cast{ptr(l+i*sizeof(a))}(ptr0_add_gint<a><tk> (p, i))
implement{a}{tk}
ptr1_sub_gint {l}{i} (p, i) =
  $UN.cast{ptr(l-i*sizeof(a))}(ptr0_sub_gint<a><tk> (p, i))
//
implement{a}{tk}
ptr1_add_guint {l}{i} (p, i) =
  $UN.cast{ptr(l+i*sizeof(a))}(ptr0_add_guint<a><tk> (p, i))
implement{a}{tk}
ptr1_sub_guint {l}{i} (p, i) =
  $UN.cast{ptr(l-i*sizeof(a))}(ptr0_sub_guint<a><tk> (p, i))
//
(* ****** ****** *)

implement{a} ptr_get (pf | p) = !p

implement{a} ptr_set (pf | p, x) = !p := x

implement{a}
ptr_exch (pf | p, x) =
{
  val tmp = x; val () = x := !p; val () = !p := tmp
} // end of [ptr_exch]

(* ****** ****** *)

implement
{a}(*tmp*)
ptr_nullize
  (pf | x) =
(
  ptr_nullize_tsz{a}(pf | x, sizeof<a>)
) (* ptr_nullize *)

(* ****** ****** *)

implement
{a}(*tmp*)
ptr_alloc () = ptr_alloc_tsz{a}(sizeof<a>)

(* ****** ****** *)

implement
{a}(*tmp*)
aptr_make_elt(x) = let
//
val (pf, fpf | p) = ptr_alloc()
//
in
  !p := x; $UN.castvwtp0{aPtr1(a)}((pf, fpf, p))
end // end of [aptr_make_elt]

(* ****** ****** *)
//
implement
{a}(*tmp*)
aptr_getfree_elt
  {l}(ap) = x where
{
  val p = aptr2ptr(ap)
  val x = $UN.ptr1_get<a>(p)
  prval
  pfat_ = $UN.castview0{(a?)@l}(0)
  prval
  pfgc_ = $UN.castview0{mfree_gc_v(l)}(0)
  val () = ptr_free{a?}{l}(pfgc_, pfat_ | p)
  prval () = $UN.cast2void(ap)
} (* end of [aptr_getfree_elt] *)
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
aptr_get_elt(ap) = $UN.ptr1_get<a>(aptr2ptr(ap))
implement
{a}(*tmp*)
aptr_set_elt(ap, x) = $UN.ptr1_set<a>(aptr2ptr(ap), x)
//
(* ****** ****** *)

implement
fprint_val<ptr> (out, p) = fprint_ptr (out, p)

(* ****** ****** *)

(* end of [pointer.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/checkast.atxt
** Time of generation: Sat Oct 17 15:19:54 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: December, 2013 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

(*
staload "prelude/SATS/checkast.sats"
*)

(* ****** ****** *)

implement{tk}
checkast_gintLt
  (x, i, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x < i
  then (x)
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintLt]

(* ****** ****** *)

implement{tk}
checkast_gintLte
  (x, i, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x <= i
  then (x)
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintLte]

(* ****** ****** *)

implement{tk}
checkast_gintGt
  (x, i, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x > i
  then (x)
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintGt]

(* ****** ****** *)

implement{tk}
checkast_gintGte
  (x, i, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x >= i
  then (x)
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintGte]

(* ****** ****** *)

implement{tk}
checkast_gintBtw
  (x, i, j, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x >= i
  then
    if x < j then (x)
    else let
      val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
      // end of [val]
    end // end of [else]
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintBtw]

(* ****** ****** *)

implement{tk}
checkast_gintBtwe
  (x, i, j, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x >= i
  then
    if x <= j then (x)
    else let
      val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
      // end of [val]
    end // end of [else]
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintBtwe]

(* ****** ****** *)

implement{}
checkast_Ptr1
  (x, errmsg) = let
  val x = g1ofg0_ptr(x)
in
//
if x > 0
  then (x)
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
// end of [if]
//
end // end of [checkast_Ptr1]

(* ****** ****** *)

implement{}
checkast_Strptr1
  (x, errmsg) = let
  val p = strptr2ptr(x)
in
//
if p > 0
  then (x)
  else let
    prval () =
      strptr_free_null (x)
    val ((*void*)) =
      fprint! (stderr_ref, "exit(ATS): ", errmsg)
    val ((*void*)) = exit_void(1)
  in
    $UN.castvwtp0{Strptr1}(0)
  end // end of [else]
// end of [if]
//
end // end of [checkast_Strptr1]

(* ****** ****** *)

(* end of [checkast.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array_prf.atxt
** Time of generation: Sat Oct 17 15:19:56 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

primplmnt
array_v_unnil_nil
  {a1,a2}(pf) = let
//
prval () =
  array_v_unnil{a1}(pf)
//
in
  array_v_nil{a2}((*void*))
//
end // end of [array_v_unnil]

(* ****** ****** *)

primplmnt
array_v_sing
  (pfat) =
(
//
array_v_cons(pfat, array_v_nil())
//
) (* end of [array_v_sing] *)

primplmnt
array_v_unsing
  (pfarr) = let
//
prval
(
  pf1at, pf2arr
) = array_v_uncons (pfarr)
//
prval () = array_v_unnil (pf2arr)
//
in
  pf1at
end // end of [array_v_unsing]

(* ****** ****** *)

primplmnt
array_v_split
  {a}(pf_arr) =
  split (pf_arr) where
{
//
prfun
split
  {l:addr} 
  {n,i:nat | i <= n} .<i>.
(
  pf_arr: array_v (a, l, n)
) : (
  array_v (a, l, i), array_v (a, l+i*sizeof(a), n-i)
) = (
//
sif
i > 0
then let
  prval (pf1elt, pf2arr) = array_v_uncons(pf_arr)
  prval (pf1arr_res, pf2arr_res) = split{..}{n-1,i-1}(pf2arr)
in
  (array_v_cons (pf1elt, pf1arr_res), pf2arr_res)
end // end of [then]
else let
  prval EQINT () =
    eqint_make{i,0}() in (array_v_nil{a}{l}((*void*)), pf_arr)
  // end of [prval]
end // end of [else]
//
) (* end of [split] *)
//
} (* end of [array_v_split] *)

(* ****** ****** *)

primplmnt
array_v_split_at
  {a}{l}{n}{i}(pf | i) = array_v_split{a}{l}{n}{i}(pf)
// end of [array_v_split_at]

(* ****** ****** *)

primplmnt
array_v_unsplit
  {a}(pf1arr, pf2arr) =
  unsplit (pf1arr, pf2arr) where
{
//
prval () = lemma_array_v_param (pf1arr)
prval () = lemma_array_v_param (pf2arr) 
//
prfun
unsplit
  {l:addr}
  {n1,n2:nat} .<n1>.
(
  pf1arr: array_v (a, l, n1)
, pf2arr: array_v (a, l+n1*sizeof(a), n2)
) : array_v (a, l, n1+n2) =
(
//
sif
n1 > 0
then let
  prval @(
    pf11elt, pf12arr
  ) = array_v_uncons (pf1arr)
  prval pf_arr_res = unsplit (pf12arr, pf2arr)
in
  array_v_cons (pf11elt, pf_arr_res)
end // end of [then]
else let
  prval
  EQINT () = eqint_make {n1,0} ()
  prval () = array_v_unnil (pf1arr) in pf2arr
end // end of [sif]
//
) (* end of [unsplit] *)
//
} (* end of [array_v_unsplit] *)

(* ****** ****** *)

primplmnt
array_v_extend
  {a}(pf1arr, pf2at) =
(
//
array_v_unsplit
(
  pf1arr, array_v_sing{a}(pf2at)
) // end of [array_v_unsplit]
//
) (* end of [array_v_extend] *)

primplmnt
array_v_unextend
  {a}{l}{n} (pfarr) = let
//
prval (pf1arr, pf2arr) =
  array_v_split{a}{l}{n}{n-1}(pfarr)
//
in
  (pf1arr, array_v_unsing{a}(pf2arr))
end // end of [array_v_unextend]

(* ****** ****** *)

primplmnt
array_v_takeout
  {a}{l}{n}{i} (pfarr) =
  takeout{..}{n}{i}(pfarr) where
{
//
prfun
takeout
  {l:addr}{n:int}
  {i:nat | i < n} .<i>.
(
  pfarr: array_v (a, l, n)
) : vtakeout (
  array_v (a, l, n), a@l+i*sizeof(a)
) = let
  prval @(pf1at, pf2arr) = array_v_uncons(pfarr)
in
  sif i > 0 then let
    prval (pfat, fpf) = takeout{..}{n-1}{i-1}(pf2arr)
  in
    (pfat, llam pfat =<prf> array_v_cons{a}(pf1at, fpf(pfat)))
  end else let
    prval EQINT () = eqint_make{i,0}((*void*))
  in
    (pf1at, llam pf1at =<prf> array_v_cons{a}(pf1at, pf2arr))
  end // end of [sif]
end // end of takeout]
//
} // end of [array_v_takeout]

(* ****** ****** *)

(* end of [array_prf.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/integer.atxt
** Time of generation: Sat Oct 17 15:19:51 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)
//
//
(* ****** ****** *)
//
staload UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)

implement
g0int2int<intknd,intknd> = g0int2int_int_int
implement
g0int2int<intknd,lintknd> = g0int2int_int_lint
implement
g0int2int<intknd,llintknd> = g0int2int_int_llint
implement
g0int2int<intknd,ssizeknd> = g0int2int_int_ssize

(* ****** ****** *)

implement g0int_neg<intknd> = g0int_neg_int
implement g0int_abs<intknd> = g0int_abs_int
implement g0int_succ<intknd> = g0int_succ_int
implement g0int_pred<intknd> = g0int_pred_int
implement g0int_half<intknd> = g0int_half_int
implement g0int_add<intknd> = g0int_add_int
implement g0int_sub<intknd> = g0int_sub_int
implement g0int_mul<intknd> = g0int_mul_int
implement g0int_div<intknd> = g0int_div_int
implement g0int_mod<intknd> = g0int_mod_int
implement g0int_asl<intknd> = g0int_asl_int
implement g0int_asr<intknd> = g0int_asr_int
implement g0int_isltz<intknd> = g0int_isltz_int
implement g0int_isltez<intknd> = g0int_isltez_int
implement g0int_isgtz<intknd> = g0int_isgtz_int
implement g0int_isgtez<intknd> = g0int_isgtez_int
implement g0int_iseqz<intknd> = g0int_iseqz_int
implement g0int_isneqz<intknd> = g0int_isneqz_int
implement g0int_lt<intknd> = g0int_lt_int
implement g0int_lte<intknd> = g0int_lte_int
implement g0int_gt<intknd> = g0int_gt_int
implement g0int_gte<intknd> = g0int_gte_int
implement g0int_eq<intknd> = g0int_eq_int
implement g0int_neq<intknd> = g0int_neq_int
implement g0int_compare<intknd> = g0int_compare_int
implement g0int_max<intknd> = g0int_max_int
implement g0int_min<intknd> = g0int_min_int
//
implement fprint_val<int> (out, x) = fprint_int (out, x)
//
implement g0int_neg<lintknd> = g0int_neg_lint
implement g0int_abs<lintknd> = g0int_abs_lint
implement g0int_succ<lintknd> = g0int_succ_lint
implement g0int_pred<lintknd> = g0int_pred_lint
implement g0int_half<lintknd> = g0int_half_lint
implement g0int_add<lintknd> = g0int_add_lint
implement g0int_sub<lintknd> = g0int_sub_lint
implement g0int_mul<lintknd> = g0int_mul_lint
implement g0int_div<lintknd> = g0int_div_lint
implement g0int_mod<lintknd> = g0int_mod_lint
implement g0int_asl<lintknd> = g0int_asl_lint
implement g0int_asr<lintknd> = g0int_asr_lint
implement g0int_isltz<lintknd> = g0int_isltz_lint
implement g0int_isltez<lintknd> = g0int_isltez_lint
implement g0int_isgtz<lintknd> = g0int_isgtz_lint
implement g0int_isgtez<lintknd> = g0int_isgtez_lint
implement g0int_iseqz<lintknd> = g0int_iseqz_lint
implement g0int_isneqz<lintknd> = g0int_isneqz_lint
implement g0int_lt<lintknd> = g0int_lt_lint
implement g0int_lte<lintknd> = g0int_lte_lint
implement g0int_gt<lintknd> = g0int_gt_lint
implement g0int_gte<lintknd> = g0int_gte_lint
implement g0int_eq<lintknd> = g0int_eq_lint
implement g0int_neq<lintknd> = g0int_neq_lint
implement g0int_compare<lintknd> = g0int_compare_lint
implement g0int_max<lintknd> = g0int_max_lint
implement g0int_min<lintknd> = g0int_min_lint
//
implement fprint_val<lint> (out, x) = fprint_lint (out, x)
//
implement g0int_neg<llintknd> = g0int_neg_llint
implement g0int_abs<llintknd> = g0int_abs_llint
implement g0int_succ<llintknd> = g0int_succ_llint
implement g0int_pred<llintknd> = g0int_pred_llint
implement g0int_half<llintknd> = g0int_half_llint
implement g0int_add<llintknd> = g0int_add_llint
implement g0int_sub<llintknd> = g0int_sub_llint
implement g0int_mul<llintknd> = g0int_mul_llint
implement g0int_div<llintknd> = g0int_div_llint
implement g0int_mod<llintknd> = g0int_mod_llint
implement g0int_asl<llintknd> = g0int_asl_llint
implement g0int_asr<llintknd> = g0int_asr_llint
implement g0int_isltz<llintknd> = g0int_isltz_llint
implement g0int_isltez<llintknd> = g0int_isltez_llint
implement g0int_isgtz<llintknd> = g0int_isgtz_llint
implement g0int_isgtez<llintknd> = g0int_isgtez_llint
implement g0int_iseqz<llintknd> = g0int_iseqz_llint
implement g0int_isneqz<llintknd> = g0int_isneqz_llint
implement g0int_lt<llintknd> = g0int_lt_llint
implement g0int_lte<llintknd> = g0int_lte_llint
implement g0int_gt<llintknd> = g0int_gt_llint
implement g0int_gte<llintknd> = g0int_gte_llint
implement g0int_eq<llintknd> = g0int_eq_llint
implement g0int_neq<llintknd> = g0int_neq_llint
implement g0int_compare<llintknd> = g0int_compare_llint
implement g0int_max<llintknd> = g0int_max_llint
implement g0int_min<llintknd> = g0int_min_llint
//
implement fprint_val<llint> (out, x) = fprint_llint (out, x)
//
implement g0int_neg<ssizeknd> = g0int_neg_ssize
implement g0int_abs<ssizeknd> = g0int_abs_ssize
implement g0int_succ<ssizeknd> = g0int_succ_ssize
implement g0int_pred<ssizeknd> = g0int_pred_ssize
implement g0int_half<ssizeknd> = g0int_half_ssize
implement g0int_add<ssizeknd> = g0int_add_ssize
implement g0int_sub<ssizeknd> = g0int_sub_ssize
implement g0int_mul<ssizeknd> = g0int_mul_ssize
implement g0int_div<ssizeknd> = g0int_div_ssize
implement g0int_mod<ssizeknd> = g0int_mod_ssize
implement g0int_asl<ssizeknd> = g0int_asl_ssize
implement g0int_asr<ssizeknd> = g0int_asr_ssize
implement g0int_isltz<ssizeknd> = g0int_isltz_ssize
implement g0int_isltez<ssizeknd> = g0int_isltez_ssize
implement g0int_isgtz<ssizeknd> = g0int_isgtz_ssize
implement g0int_isgtez<ssizeknd> = g0int_isgtez_ssize
implement g0int_iseqz<ssizeknd> = g0int_iseqz_ssize
implement g0int_isneqz<ssizeknd> = g0int_isneqz_ssize
implement g0int_lt<ssizeknd> = g0int_lt_ssize
implement g0int_lte<ssizeknd> = g0int_lte_ssize
implement g0int_gt<ssizeknd> = g0int_gt_ssize
implement g0int_gte<ssizeknd> = g0int_gte_ssize
implement g0int_eq<ssizeknd> = g0int_eq_ssize
implement g0int_neq<ssizeknd> = g0int_neq_ssize
implement g0int_compare<ssizeknd> = g0int_compare_ssize
implement g0int_max<ssizeknd> = g0int_max_ssize
implement g0int_min<ssizeknd> = g0int_min_ssize
//
implement fprint_val<ssize_t> (out, x) = fprint_ssize (out, x)
//
(* ****** ****** *)

implement{} mul_int1_size0 (i, j) = i2sz(i) * j
implement{} mul_size0_int1 (i, j) = i * i2sz(j)

(* ****** ****** *)

implement
{tk}(*tk*)
g0int_npow
  (x, n) = let
//
typedef gint = g0int(tk)
//
fun
loop
(
  x: gint, res: gint, n: int
) : gint = (
//
if
(n > 1)
then let
  val n2 = n >> 1
  val b0 = n - (n2 << 1)
  val xx = x * x
in
  if b0 = 0
    then loop(xx, res, n2) else loop(xx, x * res, n2)
  // end of [if]
end // end of [then]
else (
  if n > 0 then x * res else res
) (* end of [else] *)
//
) (* end of [loop] *)
//
val res = $UN.cast{gint}(1)
//
in
  $effmask_all(loop(x, res, n))
end // end of [g0int_npow]

(* ****** ****** *)

implement
g1int2int<intknd,intknd> = g1int2int_int_int
implement
g1int2int<intknd,lintknd> = g1int2int_int_lint
implement
g1int2int<intknd,llintknd> = g1int2int_int_llint
implement
g1int2int<intknd,ssizeknd> = g1int2int_int_ssize

(* ****** ****** *)

implement g1int_neg<intknd> = g1int_neg_int
implement g1int_abs<intknd> = g1int_abs_int
implement g1int_succ<intknd> = g1int_succ_int
implement g1int_pred<intknd> = g1int_pred_int
implement g1int_half<intknd> = g1int_half_int
implement g1int_add<intknd> = g1int_add_int
implement g1int_sub<intknd> = g1int_sub_int
implement g1int_mul<intknd> = g1int_mul_int
implement g1int_div<intknd> = g1int_div_int
implement g1int_nmod<intknd> = g1int_nmod_int
implement g1int_isltz<intknd> = g1int_isltz_int
implement g1int_isltez<intknd> = g1int_isltez_int
implement g1int_isgtz<intknd> = g1int_isgtz_int
implement g1int_isgtez<intknd> = g1int_isgtez_int
implement g1int_iseqz<intknd> = g1int_iseqz_int
implement g1int_isneqz<intknd> = g1int_isneqz_int
implement g1int_lt<intknd> = g1int_lt_int
implement g1int_lte<intknd> = g1int_lte_int
implement g1int_gt<intknd> = g1int_gt_int
implement g1int_gte<intknd> = g1int_gte_int
implement g1int_eq<intknd> = g1int_eq_int
implement g1int_neq<intknd> = g1int_neq_int
implement g1int_compare<intknd> = g1int_compare_int
implement g1int_max<intknd> = g1int_max_int
implement g1int_min<intknd> = g1int_min_int
//
implement g1int_neg<lintknd> = g1int_neg_lint
implement g1int_abs<lintknd> = g1int_abs_lint
implement g1int_succ<lintknd> = g1int_succ_lint
implement g1int_pred<lintknd> = g1int_pred_lint
implement g1int_half<lintknd> = g1int_half_lint
implement g1int_add<lintknd> = g1int_add_lint
implement g1int_sub<lintknd> = g1int_sub_lint
implement g1int_mul<lintknd> = g1int_mul_lint
implement g1int_div<lintknd> = g1int_div_lint
implement g1int_nmod<lintknd> = g1int_nmod_lint
implement g1int_isltz<lintknd> = g1int_isltz_lint
implement g1int_isltez<lintknd> = g1int_isltez_lint
implement g1int_isgtz<lintknd> = g1int_isgtz_lint
implement g1int_isgtez<lintknd> = g1int_isgtez_lint
implement g1int_iseqz<lintknd> = g1int_iseqz_lint
implement g1int_isneqz<lintknd> = g1int_isneqz_lint
implement g1int_lt<lintknd> = g1int_lt_lint
implement g1int_lte<lintknd> = g1int_lte_lint
implement g1int_gt<lintknd> = g1int_gt_lint
implement g1int_gte<lintknd> = g1int_gte_lint
implement g1int_eq<lintknd> = g1int_eq_lint
implement g1int_neq<lintknd> = g1int_neq_lint
implement g1int_compare<lintknd> = g1int_compare_lint
implement g1int_max<lintknd> = g1int_max_lint
implement g1int_min<lintknd> = g1int_min_lint
//
implement g1int_neg<llintknd> = g1int_neg_llint
implement g1int_abs<llintknd> = g1int_abs_llint
implement g1int_succ<llintknd> = g1int_succ_llint
implement g1int_pred<llintknd> = g1int_pred_llint
implement g1int_half<llintknd> = g1int_half_llint
implement g1int_add<llintknd> = g1int_add_llint
implement g1int_sub<llintknd> = g1int_sub_llint
implement g1int_mul<llintknd> = g1int_mul_llint
implement g1int_div<llintknd> = g1int_div_llint
implement g1int_nmod<llintknd> = g1int_nmod_llint
implement g1int_isltz<llintknd> = g1int_isltz_llint
implement g1int_isltez<llintknd> = g1int_isltez_llint
implement g1int_isgtz<llintknd> = g1int_isgtz_llint
implement g1int_isgtez<llintknd> = g1int_isgtez_llint
implement g1int_iseqz<llintknd> = g1int_iseqz_llint
implement g1int_isneqz<llintknd> = g1int_isneqz_llint
implement g1int_lt<llintknd> = g1int_lt_llint
implement g1int_lte<llintknd> = g1int_lte_llint
implement g1int_gt<llintknd> = g1int_gt_llint
implement g1int_gte<llintknd> = g1int_gte_llint
implement g1int_eq<llintknd> = g1int_eq_llint
implement g1int_neq<llintknd> = g1int_neq_llint
implement g1int_compare<llintknd> = g1int_compare_llint
implement g1int_max<llintknd> = g1int_max_llint
implement g1int_min<llintknd> = g1int_min_llint
//
implement g1int_neg<ssizeknd> = g1int_neg_ssize
implement g1int_abs<ssizeknd> = g1int_abs_ssize
implement g1int_succ<ssizeknd> = g1int_succ_ssize
implement g1int_pred<ssizeknd> = g1int_pred_ssize
implement g1int_half<ssizeknd> = g1int_half_ssize
implement g1int_add<ssizeknd> = g1int_add_ssize
implement g1int_sub<ssizeknd> = g1int_sub_ssize
implement g1int_mul<ssizeknd> = g1int_mul_ssize
implement g1int_div<ssizeknd> = g1int_div_ssize
implement g1int_nmod<ssizeknd> = g1int_nmod_ssize
implement g1int_isltz<ssizeknd> = g1int_isltz_ssize
implement g1int_isltez<ssizeknd> = g1int_isltez_ssize
implement g1int_isgtz<ssizeknd> = g1int_isgtz_ssize
implement g1int_isgtez<ssizeknd> = g1int_isgtez_ssize
implement g1int_iseqz<ssizeknd> = g1int_iseqz_ssize
implement g1int_isneqz<ssizeknd> = g1int_isneqz_ssize
implement g1int_lt<ssizeknd> = g1int_lt_ssize
implement g1int_lte<ssizeknd> = g1int_lte_ssize
implement g1int_gt<ssizeknd> = g1int_gt_ssize
implement g1int_gte<ssizeknd> = g1int_gte_ssize
implement g1int_eq<ssizeknd> = g1int_eq_ssize
implement g1int_neq<ssizeknd> = g1int_neq_ssize
implement g1int_compare<ssizeknd> = g1int_compare_ssize
implement g1int_max<ssizeknd> = g1int_max_ssize
implement g1int_min<ssizeknd> = g1int_min_ssize
//
(* ****** ****** *)

implement{tk}
g1int_sgn (x) = compare_g1int_int<tk> (x, 0)

(* ****** ****** *)
//
implement{
} add_size1_int1
  {i,j}(i, j) = $UN.cast{size_t(i+j)}(i+g0i2u(j))
implement{
} add_int1_size1
  {i,j}(i, j) = $UN.cast{size_t(i+j)}(g0i2u(i)+j)
//
implement{
} sub_size1_int1
  {i,j}(i, j) = $UN.cast{size_t(i-j)}(i-g0i2u(j))
//
(* ****** ****** *)

implement{tk}
g1int_mul2 {i,j} (x, y) = let
  prval pf = mul_make {i,j} () in (pf | g1int_mul<tk> (x, y))
end // end of [let] // end of [g1int_mul2]

(* ****** ****** *)
//
implement{
} mul_int1_size1
  {i,j}(i, j) = $UN.cast{size_t(i*j)}(g0i2u(i)*j)
implement{
} mul_size1_int1
  {i,j}(i, j) = $UN.cast{size_t(i*j)}(i*g0i2u(j))
//
(* ****** ****** *)

implement{tk}
g1int_ndiv {i,j} (x, y) = let
  val q = g1int_div (x, y) in $UN.cast{g1int(tk,ndiv(i,j))}(q)
end // end of [let] // end of [g1int_ndiv]

(* ****** ****** *)

implement{tk}
g1int_ndiv2 {i,j} (x, y) = let
  val [q:int] q = g1int_div (x, y)
  prval [q2:int,r:int] pf = divmod_istot{i,j}()
  prval EQINT() = $UN.castview0{EQINT(q,q2)}(0)
in
  (pf | q)
end // end of [let] // end of [g1int_ndiv2]

(* ****** ****** *)

implement{tk}
g1int_nmod2 {i,j} (x, y) = let
  val r = g1int_nmod (x, y)
  prval [q:int,r2:int] pf = divmod_istot{i,j}()
  prval EQINT() = $UN.castview0{EQINT(i%j,r2)}(0)
in
  (pf | r)
end // end of [let] // end of [g1int_nmod2]

(* ****** ****** *)

implement
nmod_g1int_int1<intknd> (x, y) = g1i2i(g1int_nmod (x, g1i2i(y)))
implement
nmod_g1int_int1<lintknd> (x, y) = g1i2i(g1int_nmod (x, g1i2i(y)))
implement
nmod_g1int_int1<llintknd> (x, y) = g1i2i(g1int_nmod (x, g1i2i(y)))

(* ****** ****** *)

implement{tk}
nmod2_g1int_int1{i,j}(x, y) = let
  val r = nmod_g1int_int1 (x, y)
  prval [q:int,r2:int] pf = divmod_istot{i,j}()
  prval EQINT() = $UN.castview0{EQINT(i%j,r2)}(0)
in
  (pf | r)
end // end of [let] // end of [nmod2_g1int_int1]

(* ****** ****** *)

implement{tk}
g1int_ngcd (x, y) = let
//
fun loop{i,j:nat} .<j>.
(
  x: g1int (tk, i), y: g1int (tk, j)
) :<> [r:nat] g1int (tk, r) = let
in
//
if y > 0 then loop (y, g1int_nmod (x, y)) else x
//
end // end of [loop]
//
in
  loop (x, y)
end // end of [g1int_ngcd]

(* ****** ****** *)
//
// HX: int -> uint
//
implement
g0int2uint<intknd,uintknd> = g0int2uint_int_uint
implement
g0int2uint<intknd,ulintknd> = g0int2uint_int_ulint
implement
g0int2uint<intknd,ullintknd> = g0int2uint_int_ullint
implement
g0int2uint<intknd,sizeknd> = g0int2uint_int_size
//
implement
g0int2uint<lintknd,ulintknd> = g0int2uint_lint_ulint
implement
g0int2uint<lintknd,ullintknd> = g0int2uint_lint_ullint
implement
g0int2uint<lintknd,sizeknd> = g0int2uint_lint_size
//
implement
g0int2uint<llintknd,ullintknd> = g0int2uint_llint_ullint
//
implement
g0int2uint<ssizeknd,sizeknd> = g0int2uint_ssize_size

(* ****** ****** *)
//
// HX: uint -> int
//
implement
g0uint2int<uintknd,intknd> = g0uint2int_uint_int
implement
g0uint2int<uintknd,lintknd> = g0uint2int_uint_lint
implement
g0uint2int<uintknd,llintknd> = g0uint2int_uint_llint
implement
g0uint2int<uintknd,ssizeknd> = g0uint2int_uint_ssize
//
implement
g0uint2int<sizeknd,intknd> = g0uint2int_size_int
implement
g0uint2int<sizeknd,lintknd> = g0uint2int_size_lint
implement
g0uint2int<sizeknd,llintknd> = g0uint2int_size_llint
implement
g0uint2int<sizeknd,ssizeknd> = g0uint2int_size_ssize
//
(* ****** ****** *)
//
// HX: uint -> uint
//
implement
g0uint2uint<uintknd,uintknd> = g0uint2uint_uint_uint
implement
g0uint2uint<uintknd,ulintknd> = g0uint2uint_uint_ulint
implement
g0uint2uint<uintknd,ullintknd> = g0uint2uint_uint_ullint
implement
g0uint2uint<uintknd,sizeknd> = g0uint2uint_uint_size

(* ****** ****** *)

implement
g0uint2uint<sizeknd,ulintknd> = g0uint2uint_size_ulint
implement
g0uint2uint<sizeknd,ullintknd> = g0uint2uint_size_ullint
implement
g0uint2uint<sizeknd,sizeknd> = g0uint2uint_size_size

(* ****** ****** *)

implement g0uint_succ<uintknd> = g0uint_succ_uint
implement g0uint_pred<uintknd> = g0uint_pred_uint
implement g0uint_half<uintknd> = g0uint_half_uint
implement g0uint_add<uintknd> = g0uint_add_uint
implement g0uint_sub<uintknd> = g0uint_sub_uint
implement g0uint_mul<uintknd> = g0uint_mul_uint
implement g0uint_div<uintknd> = g0uint_div_uint
implement g0uint_mod<uintknd> = g0uint_mod_uint
implement g0uint_lsl<uintknd> = g0uint_lsl_uint
implement g0uint_lsr<uintknd> = g0uint_lsr_uint
implement g0uint_lnot<uintknd> = g0uint_lnot_uint
implement g0uint_lor<uintknd> = g0uint_lor_uint
implement g0uint_lxor<uintknd> = g0uint_lxor_uint
implement g0uint_land<uintknd> = g0uint_land_uint
implement g0uint_isgtz<uintknd> = g0uint_isgtz_uint
implement g0uint_iseqz<uintknd> = g0uint_iseqz_uint
implement g0uint_isneqz<uintknd> = g0uint_isneqz_uint
implement g0uint_lt<uintknd> = g0uint_lt_uint
implement g0uint_lte<uintknd> = g0uint_lte_uint
implement g0uint_gt<uintknd> = g0uint_gt_uint
implement g0uint_gte<uintknd> = g0uint_gte_uint
implement g0uint_eq<uintknd> = g0uint_eq_uint
implement g0uint_neq<uintknd> = g0uint_neq_uint
implement g0uint_compare<uintknd> = g0uint_compare_uint
implement g0uint_max<uintknd> = g0uint_max_uint
implement g0uint_min<uintknd> = g0uint_min_uint
//
implement fprint_val<uint> (out, x) = fprint_uint (out, x)
//
implement g0uint_succ<ulintknd> = g0uint_succ_ulint
implement g0uint_pred<ulintknd> = g0uint_pred_ulint
implement g0uint_half<ulintknd> = g0uint_half_ulint
implement g0uint_add<ulintknd> = g0uint_add_ulint
implement g0uint_sub<ulintknd> = g0uint_sub_ulint
implement g0uint_mul<ulintknd> = g0uint_mul_ulint
implement g0uint_div<ulintknd> = g0uint_div_ulint
implement g0uint_mod<ulintknd> = g0uint_mod_ulint
implement g0uint_lsl<ulintknd> = g0uint_lsl_ulint
implement g0uint_lsr<ulintknd> = g0uint_lsr_ulint
implement g0uint_lnot<ulintknd> = g0uint_lnot_ulint
implement g0uint_lor<ulintknd> = g0uint_lor_ulint
implement g0uint_lxor<ulintknd> = g0uint_lxor_ulint
implement g0uint_land<ulintknd> = g0uint_land_ulint
implement g0uint_isgtz<ulintknd> = g0uint_isgtz_ulint
implement g0uint_iseqz<ulintknd> = g0uint_iseqz_ulint
implement g0uint_isneqz<ulintknd> = g0uint_isneqz_ulint
implement g0uint_lt<ulintknd> = g0uint_lt_ulint
implement g0uint_lte<ulintknd> = g0uint_lte_ulint
implement g0uint_gt<ulintknd> = g0uint_gt_ulint
implement g0uint_gte<ulintknd> = g0uint_gte_ulint
implement g0uint_eq<ulintknd> = g0uint_eq_ulint
implement g0uint_neq<ulintknd> = g0uint_neq_ulint
implement g0uint_compare<ulintknd> = g0uint_compare_ulint
implement g0uint_max<ulintknd> = g0uint_max_ulint
implement g0uint_min<ulintknd> = g0uint_min_ulint
//
implement fprint_val<ulint> (out, x) = fprint_ulint (out, x)
//
implement g0uint_succ<ullintknd> = g0uint_succ_ullint
implement g0uint_pred<ullintknd> = g0uint_pred_ullint
implement g0uint_half<ullintknd> = g0uint_half_ullint
implement g0uint_add<ullintknd> = g0uint_add_ullint
implement g0uint_sub<ullintknd> = g0uint_sub_ullint
implement g0uint_mul<ullintknd> = g0uint_mul_ullint
implement g0uint_div<ullintknd> = g0uint_div_ullint
implement g0uint_mod<ullintknd> = g0uint_mod_ullint
implement g0uint_lsl<ullintknd> = g0uint_lsl_ullint
implement g0uint_lsr<ullintknd> = g0uint_lsr_ullint
implement g0uint_lnot<ullintknd> = g0uint_lnot_ullint
implement g0uint_lor<ullintknd> = g0uint_lor_ullint
implement g0uint_lxor<ullintknd> = g0uint_lxor_ullint
implement g0uint_land<ullintknd> = g0uint_land_ullint
implement g0uint_isgtz<ullintknd> = g0uint_isgtz_ullint
implement g0uint_iseqz<ullintknd> = g0uint_iseqz_ullint
implement g0uint_isneqz<ullintknd> = g0uint_isneqz_ullint
implement g0uint_lt<ullintknd> = g0uint_lt_ullint
implement g0uint_lte<ullintknd> = g0uint_lte_ullint
implement g0uint_gt<ullintknd> = g0uint_gt_ullint
implement g0uint_gte<ullintknd> = g0uint_gte_ullint
implement g0uint_eq<ullintknd> = g0uint_eq_ullint
implement g0uint_neq<ullintknd> = g0uint_neq_ullint
implement g0uint_compare<ullintknd> = g0uint_compare_ullint
implement g0uint_max<ullintknd> = g0uint_max_ullint
implement g0uint_min<ullintknd> = g0uint_min_ullint
//
implement fprint_val<ullint> (out, x) = fprint_ullint (out, x)
//
implement g0uint_succ<sizeknd> = g0uint_succ_size
implement g0uint_pred<sizeknd> = g0uint_pred_size
implement g0uint_half<sizeknd> = g0uint_half_size
implement g0uint_add<sizeknd> = g0uint_add_size
implement g0uint_sub<sizeknd> = g0uint_sub_size
implement g0uint_mul<sizeknd> = g0uint_mul_size
implement g0uint_div<sizeknd> = g0uint_div_size
implement g0uint_mod<sizeknd> = g0uint_mod_size
implement g0uint_lsl<sizeknd> = g0uint_lsl_size
implement g0uint_lsr<sizeknd> = g0uint_lsr_size
implement g0uint_lnot<sizeknd> = g0uint_lnot_size
implement g0uint_lor<sizeknd> = g0uint_lor_size
implement g0uint_lxor<sizeknd> = g0uint_lxor_size
implement g0uint_land<sizeknd> = g0uint_land_size
implement g0uint_isgtz<sizeknd> = g0uint_isgtz_size
implement g0uint_iseqz<sizeknd> = g0uint_iseqz_size
implement g0uint_isneqz<sizeknd> = g0uint_isneqz_size
implement g0uint_lt<sizeknd> = g0uint_lt_size
implement g0uint_lte<sizeknd> = g0uint_lte_size
implement g0uint_gt<sizeknd> = g0uint_gt_size
implement g0uint_gte<sizeknd> = g0uint_gte_size
implement g0uint_eq<sizeknd> = g0uint_eq_size
implement g0uint_neq<sizeknd> = g0uint_neq_size
implement g0uint_compare<sizeknd> = g0uint_compare_size
implement g0uint_max<sizeknd> = g0uint_max_size
implement g0uint_min<sizeknd> = g0uint_min_size
//
implement fprint_val<size_t> (out, x) = fprint_size (out, x)
//
(* ****** ****** *)
//
// HX: int -> uint
//
implement
g1int2uint<intknd,uintknd> = g1int2uint_int_uint
implement
g1int2uint<intknd,ulintknd> = g1int2uint_int_ulint
implement
g1int2uint<intknd,ullintknd> = g1int2uint_int_ullint
implement
g1int2uint<intknd,sizeknd> = g1int2uint_int_size
//
implement
g1int2uint<ssizeknd,sizeknd> = g1int2uint_ssize_size

(* ****** ****** *)
//
// HX: uint -> int
//
implement
g1uint2int<uintknd,intknd> = g1uint2int_uint_int
implement
g1uint2int<uintknd,lintknd> = g1uint2int_uint_lint
implement
g1uint2int<uintknd,llintknd> = g1uint2int_uint_llint
implement
g1uint2int<uintknd,ssizeknd> = g1uint2int_uint_ssize
//
implement
g1uint2int<sizeknd,intknd> = g1uint2int_size_int
implement
g1uint2int<sizeknd,lintknd> = g1uint2int_size_lint
implement
g1uint2int<sizeknd,llintknd> = g1uint2int_size_llint
implement
g1uint2int<sizeknd,ssizeknd> = g1uint2int_size_ssize

(* ****** ****** *)
//
// HX: uint -> uint
//
implement
g1uint2uint<uintknd,uintknd> = g1uint2uint_uint_uint
implement
g1uint2uint<uintknd,ulintknd> = g1uint2uint_uint_ulint
implement
g1uint2uint<uintknd,ullintknd> = g1uint2uint_uint_ullint
implement
g1uint2uint<uintknd,sizeknd> = g1uint2uint_uint_size
//
implement
g1uint2uint<sizeknd,uintknd> = g1uint2uint_size_uint
implement
g1uint2uint<sizeknd,ulintknd> = g1uint2uint_size_ulint
implement
g1uint2uint<sizeknd,ullintknd> = g1uint2uint_size_ullint
implement
g1uint2uint<sizeknd,sizeknd> = g1uint2uint_size_size

(* ****** ****** *)

implement g1uint_succ<uintknd> = g1uint_succ_uint
implement g1uint_pred<uintknd> = g1uint_pred_uint
implement g1uint_half<uintknd> = g1uint_half_uint
implement g1uint_add<uintknd> = g1uint_add_uint
implement g1uint_sub<uintknd> = g1uint_sub_uint
implement g1uint_mul<uintknd> = g1uint_mul_uint
implement g1uint_div<uintknd> = g1uint_div_uint
implement g1uint_mod<uintknd> = g1uint_mod_uint
implement g1uint_isgtz<uintknd> = g1uint_isgtz_uint
implement g1uint_iseqz<uintknd> = g1uint_iseqz_uint
implement g1uint_isneqz<uintknd> = g1uint_isneqz_uint
implement g1uint_lt<uintknd> = g1uint_lt_uint
implement g1uint_lte<uintknd> = g1uint_lte_uint
implement g1uint_gt<uintknd> = g1uint_gt_uint
implement g1uint_gte<uintknd> = g1uint_gte_uint
implement g1uint_eq<uintknd> = g1uint_eq_uint
implement g1uint_neq<uintknd> = g1uint_neq_uint
implement g1uint_compare<uintknd> = g1uint_compare_uint
implement g1uint_max<uintknd> = g1uint_max_uint
implement g1uint_min<uintknd> = g1uint_min_uint
//
implement g1uint_succ<ulintknd> = g1uint_succ_ulint
implement g1uint_pred<ulintknd> = g1uint_pred_ulint
implement g1uint_half<ulintknd> = g1uint_half_ulint
implement g1uint_add<ulintknd> = g1uint_add_ulint
implement g1uint_sub<ulintknd> = g1uint_sub_ulint
implement g1uint_mul<ulintknd> = g1uint_mul_ulint
implement g1uint_div<ulintknd> = g1uint_div_ulint
implement g1uint_mod<ulintknd> = g1uint_mod_ulint
implement g1uint_isgtz<ulintknd> = g1uint_isgtz_ulint
implement g1uint_iseqz<ulintknd> = g1uint_iseqz_ulint
implement g1uint_isneqz<ulintknd> = g1uint_isneqz_ulint
implement g1uint_lt<ulintknd> = g1uint_lt_ulint
implement g1uint_lte<ulintknd> = g1uint_lte_ulint
implement g1uint_gt<ulintknd> = g1uint_gt_ulint
implement g1uint_gte<ulintknd> = g1uint_gte_ulint
implement g1uint_eq<ulintknd> = g1uint_eq_ulint
implement g1uint_neq<ulintknd> = g1uint_neq_ulint
implement g1uint_compare<ulintknd> = g1uint_compare_ulint
implement g1uint_max<ulintknd> = g1uint_max_ulint
implement g1uint_min<ulintknd> = g1uint_min_ulint
//
implement g1uint_succ<ullintknd> = g1uint_succ_ullint
implement g1uint_pred<ullintknd> = g1uint_pred_ullint
implement g1uint_half<ullintknd> = g1uint_half_ullint
implement g1uint_add<ullintknd> = g1uint_add_ullint
implement g1uint_sub<ullintknd> = g1uint_sub_ullint
implement g1uint_mul<ullintknd> = g1uint_mul_ullint
implement g1uint_div<ullintknd> = g1uint_div_ullint
implement g1uint_mod<ullintknd> = g1uint_mod_ullint
implement g1uint_isgtz<ullintknd> = g1uint_isgtz_ullint
implement g1uint_iseqz<ullintknd> = g1uint_iseqz_ullint
implement g1uint_isneqz<ullintknd> = g1uint_isneqz_ullint
implement g1uint_lt<ullintknd> = g1uint_lt_ullint
implement g1uint_lte<ullintknd> = g1uint_lte_ullint
implement g1uint_gt<ullintknd> = g1uint_gt_ullint
implement g1uint_gte<ullintknd> = g1uint_gte_ullint
implement g1uint_eq<ullintknd> = g1uint_eq_ullint
implement g1uint_neq<ullintknd> = g1uint_neq_ullint
implement g1uint_compare<ullintknd> = g1uint_compare_ullint
implement g1uint_max<ullintknd> = g1uint_max_ullint
implement g1uint_min<ullintknd> = g1uint_min_ullint
//
implement g1uint_succ<sizeknd> = g1uint_succ_size
implement g1uint_pred<sizeknd> = g1uint_pred_size
implement g1uint_half<sizeknd> = g1uint_half_size
implement g1uint_add<sizeknd> = g1uint_add_size
implement g1uint_sub<sizeknd> = g1uint_sub_size
implement g1uint_mul<sizeknd> = g1uint_mul_size
implement g1uint_div<sizeknd> = g1uint_div_size
implement g1uint_mod<sizeknd> = g1uint_mod_size
implement g1uint_isgtz<sizeknd> = g1uint_isgtz_size
implement g1uint_iseqz<sizeknd> = g1uint_iseqz_size
implement g1uint_isneqz<sizeknd> = g1uint_isneqz_size
implement g1uint_lt<sizeknd> = g1uint_lt_size
implement g1uint_lte<sizeknd> = g1uint_lte_size
implement g1uint_gt<sizeknd> = g1uint_gt_size
implement g1uint_gte<sizeknd> = g1uint_gte_size
implement g1uint_eq<sizeknd> = g1uint_eq_size
implement g1uint_neq<sizeknd> = g1uint_neq_size
implement g1uint_compare<sizeknd> = g1uint_compare_size
implement g1uint_max<sizeknd> = g1uint_max_size
implement g1uint_min<sizeknd> = g1uint_min_size
//
(* ****** ****** *)

implement
{tk}(*tmp*)
g1uint_div2 {i,j} (x, y) = let
//
  prval () = lemma_g1uint_param (x)
//
  val [q:int] q = g1uint_div (x, y)
  prval [q2:int,r:int] pf = divmod_istot{i,j}()
  prval EQINT() = $UN.castview0{EQINT(q,q2)}(0)
in
  (pf | q)
end // end of [let] // end of [g1uint_div2]

(* ****** ****** *)

implement
{tk}(*tmp*)
g1uint_mod2 {i,j} (x, y) = let
//
  prval () = lemma_g1uint_param (x)
//
  val [r:int] r = g1uint_mod (x, y)
  prval [q:int,r2:int] pf = divmod_istot{i,j}()
  prval EQINT() = $UN.castview0{EQINT(r,r2)}(0)
in
  (pf | r)
end // end of [let] // end of [g1uint_mod2]

(* ****** ****** *)
//
implement g0int2string<intknd> = g0int2string_int
implement g0int2string<lintknd> = g0int2string_lint
implement g0int2string<llintknd> = g0int2string_llint
(*
implement g0int2string<ssizeknd> = g0int2string_ssize
*)
//
(* ****** ****** *)
//
implement g0string2int<intknd> = g0string2int_int
implement g0string2int<lintknd> = g0string2int_lint
implement g0string2int<llintknd> = g0string2int_llint
implement g0string2int<ssizeknd> = g0string2int_ssize
//
implement g0string2uint<uintknd> = g0string2uint_uint
implement g0string2uint<ulintknd> = g0string2uint_ulint
implement g0string2uint<ullintknd> = g0string2uint_ullint
implement g0string2uint<sizeknd> = g0string2uint_size
//
(* ****** ****** *)

implement{tk}
g1string2int (str) = g1ofg0_int (g0string2int<tk> (str))
implement{tk}
g1string2uint (str) = g1ofg0_uint (g0string2uint<tk> (str))

(* ****** ****** *)

implement{tk}
lt_g0int_int (x, y) = g0int_lt<tk> (x, g0int2int (y))
implement{tk}
lte_g0int_int (x, y) = g0int_lte<tk> (x, g0int2int (y))
implement{tk}
gt_g0int_int (x, y) = g0int_gt<tk> (x, g0int2int (y))
implement{tk}
gte_g0int_int (x, y) = g0int_gte<tk> (x, g0int2int (y))
implement{tk}
eq_g0int_int (x, y) = g0int_eq<tk> (x, g0int2int (y))
implement{tk}
neq_g0int_int (x, y) = g0int_neq<tk> (x, g0int2int (y))

implement{tk}
compare_g0int_int (x, y) = g0int_compare<tk> (x, g0int2int (y))

(* ****** ****** *)

implement{tk}
lt_g1int_int (x, y) = g1int_lt<tk> (x, g1int2int (y))
implement{tk}
lte_g1int_int (x, y) = g1int_lte<tk> (x, g1int2int (y))
implement{tk}
gt_g1int_int (x, y) = g1int_gt<tk> (x, g1int2int (y))
implement{tk}
gte_g1int_int (x, y) = g1int_gte<tk> (x, g1int2int (y))
implement{tk}
eq_g1int_int (x, y) = g1int_eq<tk> (x, g1int2int (y))
implement{tk}
neq_g1int_int (x, y) = g1int_neq<tk> (x, g1int2int (y))

implement{tk}
compare_g1int_int (x, y) = g1int_compare<tk> (x, g1int2int (y))

(* ****** ****** *)

implement{tk}
lt_g0uint_int (x, y) = g0uint_lt<tk> (x, g0int2uint (y))
implement{tk}
lte_g0uint_int (x, y) = g0uint_lte<tk> (x, g0int2uint (y))
implement{tk}
gt_g0uint_int (x, y) = g0uint_gt<tk> (x, g0int2uint (y))
implement{tk}
gte_g0uint_int (x, y) = g0uint_gte<tk> (x, g0int2uint (y))
implement{tk}
eq_g0uint_int (x, y) = g0uint_eq<tk> (x, g0int2uint (y))
implement{tk}
neq_g0uint_int (x, y) = g0uint_neq<tk> (x, g0int2uint (y))

(* ****** ****** *)

implement{tk}
lt_g1uint_int (x, y) = g1uint_lt<tk> (x, g1int2uint (y))
implement{tk}
lte_g1uint_int (x, y) = g1uint_lte<tk> (x, g1int2uint (y))
implement{tk}
gt_g1uint_int (x, y) = g1uint_gt<tk> (x, g1int2uint (y))
implement{tk}
gte_g1uint_int (x, y) = g1uint_gte<tk> (x, g1int2uint (y))
implement{tk}
eq_g1uint_int (x, y) = g1uint_eq<tk> (x, g1int2uint (y))
implement{tk}
neq_g1uint_int (x, y) = g1uint_neq<tk> (x, g1int2uint (y))

(* ****** ****** *)

(* end of [integer.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/filebas_prf.atxt
** Time of generation: Sat Oct 17 15:19:54 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)
//
stadef r() = file_mode_r()
stadef w() = file_mode_w()
stadef rw() = file_mode_rw()
//
primplmnt file_mode_lte_r_r = file_mode_lte_refl{r()}()
primplmnt file_mode_lte_w_w = file_mode_lte_refl{w()}()
primplmnt file_mode_lte_rw_rw = file_mode_lte_refl{rw()}()
//
(* ****** ****** *)

(* end of [filebas_prf.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/option_vt.atxt
** Time of generation: Sat Oct 17 15:19:56 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

implement{a} option_vt_some (x) = Some_vt (x)
implement{a} option_vt_none ( ) = None_vt ( )

(* ****** ****** *)

implement
{a}(*tmp*)
option_vt_make_opt
  (b, x) = (
  if b then let
    prval () = opt_unsome{a}(x) in Some_vt{a}(x)
  end else let
    prval () = opt_unnone{a}(x) in None_vt{a}( )
  end // end of [if]
) (* end of [option_vt_make_opt] *)

(* ****** ****** *)

implement
{}(*tmp*)
option_vt_is_some
  (opt) = case+ opt of
  | Some_vt _ => true | None_vt _ => false
// end of [option_is_some]

implement{}
option_vt_is_none
  (opt) = case+ opt of
  | Some_vt _ => false | None_vt _ => true
// end of [option_is_none]

(* ****** ****** *)

implement
{a}(*tmp*)
option_vt_unsome
  (opt) = x where { val+ ~Some_vt (x) = opt }
// end of [option_unsome]

implement
{a}(*tmp*)
option_vt_unnone
  (opt) = () where { val+ ~None_vt () = opt }
// end of [option_unnone]

(* ****** ****** *)

implement
{a}(*tmp*)
option_vt_free (opt) =
(
case+ opt of ~Some_vt _ => () | ~None_vt () => ()
) // end of [option_vt_free]

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_option_vt
  (out, opt) = let
in
//
case+ opt of
| @Some_vt (x) => {
    val (
    ) = fprint_string (out, "Some_vt(")
    val () = fprint_ref<a> (out, x)
    val () = fprint_string (out, ")")
    prval () = fold@ (opt)
  } (* end of [Some_vt] *)
| None_vt () => {
    val () = fprint_string (out, "None_vt()")
  } (* end of [None_vt] *)
//
end // end of [fprint_option_vt]

(* ****** ****** *)

(* end of [option_vt.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/tuple.atxt
** Time of generation: Sat Oct 17 15:19:53 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

implement
fprint_tup$beg<> (out) = fprint_string (out, "(")
implement
fprint_tup$end<> (out) = fprint_string (out, ")")
implement
fprint_tup$sep<> (out) = fprint_string (out, ", ")

(* ****** ****** *)

implement
{a0,a1}
fprint_tupval2
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_val<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a1> (out, x.1)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupval2]

implement
(a0,a1)
fprint_val<tup(a0,a1)> (out, x) = fprint_tupval2<a0,a1> (out, x)

(* ****** ****** *)

implement
{a0,a1,a2}
fprint_tupval3
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_val<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a1> (out, x.1)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a2> (out, x.2)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupval3]

implement
(a0,a1,a2)
fprint_val<tup(a0,a1,a2)> (out, x) = fprint_tupval3<a0,a1,a2> (out, x)

(* ****** ****** *)

implement
{a0,a1,a2,a3}
fprint_tupval4
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_val<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a1> (out, x.1)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a2> (out, x.2)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a3> (out, x.3)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupval4]

implement
(a0,a1,a2,a3)
fprint_val<tup(a0,a1,a2,a3)> (out, x) = fprint_tupval4<a0,a1,a2,a3> (out, x)

(* ****** ****** *)

implement
{a0,a1}
fprint_tupref2
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_ref<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a1> (out, x.1)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupref2]

implement
(a0,a1)
fprint_ref<tup(a0,a1)> (out, x) = fprint_tupref2<a0,a1> (out, x)

(* ****** ****** *)

implement
{a0,a1,a2}
fprint_tupref3
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_ref<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a1> (out, x.1)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a2> (out, x.2)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupref3]

implement
(a0,a1,a2)
fprint_ref<tup(a0,a1,a2)> (out, x) = fprint_tupref3<a0,a1,a2> (out, x)

(* ****** ****** *)

implement
{a0,a1,a2,a3}
fprint_tupref4
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_ref<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a1> (out, x.1)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a2> (out, x.2)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a3> (out, x.3)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupref4]

implement
(a0,a1,a2,a3)
fprint_ref<tup(a0,a1,a2,a3)> (out, x) = fprint_tupref4<a0,a1,a2,a3> (out, x)

(* ****** ****** *)

implement
{a0,a1}
tupval2_compare (x, y) = let
  val sgn0 = gcompare_val_val<a0> (x.0, y.0)
in
  if sgn0 != 0 then sgn0 else gcompare_val_val<a1> (x.1, y.1)
end // end of [tupval2_compare]  

implement
(a0,a1)
gcompare_val_val<tup(a0,a1)> (x, y) = tupval2_compare<a0,a1> (x, y)

(* ****** ****** *)

implement
{a0,a1,a2}
tupval3_compare (x, y) = let
//
val sgn0 = gcompare_val_val<a0> (x.0, y.0)
//
in
//
if
sgn0 != 0
then sgn0
else let
  val sgn1 = gcompare_val_val<a1> (x.1, y.1)
in
  if sgn1 != 0 then sgn1 else gcompare_val_val<a2> (x.2, y.2)
end // end of [if]
//
end // end of [tupval3_compare]

implement
(a0,a1,a2)
gcompare_val_val<tup(a0,a1,a2)> (x, y) = tupval3_compare<a0,a1,a2> (x, y)

(* ****** ****** *)

implement
{a0,a1,a2,a3}
tupval4_compare (x, y) = let
//
val sgn0 = gcompare_val_val<a0> (x.0, y.0)
//
in
//
if
sgn0 != 0
then sgn0
else let
  val sgn1 = gcompare_val_val<a1> (x.1, y.1)
in
//
if sgn1 != 0 then sgn1
else let
  val sgn2 = gcompare_val_val<a2> (x.2, y.2)
in
  if sgn2 != 0 then sgn2 else gcompare_val_val<a3> (x.3, y.3)
end // end of [if]
//
end // end of [if]
//
end // end of [tupval4_compare]  

implement
(a0,a1,a2,a3)
gcompare_val_val<tup(a0,a1,a2,a3)> (x, y) = tupval4_compare<a0,a1,a2,a3> (x, y)

(* ****** ****** *)

(* end of [tuple.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/filebas.atxt
** Time of generation: Sat Oct 17 15:19:54 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload _(*anon*) = "prelude/DATS/integer.dats"

(* ****** ****** *)

staload STDIO = "libc/SATS/stdio.sats"
vtypedef FILEptr1 = $STDIO.FILEptr1 (*linear/nonnull*)

(* ****** ****** *)

staload STAT = "libc/sys/SATS/stat.sats"

(* ****** ****** *)

#define c2i char2int0
#define i2c int2char0

(* ****** ****** *)
//
// HX-2013-06:
// this is just Unix convention
//
implement{} dirsep_get () = '/'
implement{} dirname_self () = "."
implement{} dirname_parent () = ".."
//
(* ****** ****** *)

implement
{}(*tmp*)
filename_get_ext (name) = let
//
#define NUL '\000'
overload + with add_ptr_bsz
//
fun loop
(
  p1: ptr, p2: ptr, c0: char
) : ptr = let
  val c = $UN.ptr0_get<char> (p1)
in
  if c != NUL then let
    val p1 = p1 + i2sz(1)
  in
    if c != c0 then loop (p1, p2, c0) else loop (p1, p1, c0)
  end else p2 // end of [if]
end // end of [loop]
//
val p1 = string2ptr(name)
val p2 = $effmask_all (loop (p1, the_null_ptr, '.'))
//
in
  $UN.castvwtp0{vStrptr0}(p2)
end // end of [filename_get_ext]

(* ****** ****** *)

implement
{}(*tmp*)
filename_test_ext
  (name, ext0) = let
//
val (fpf | ext) = filename_get_ext (name)
//
val ans =
(
  if strptr2ptr(ext) > 0
    then eq_string_string (ext0, $UN.strptr2string(ext))
    else false
  // end of [if]
) : bool // end of [val]
//
prval () = fpf (ext)
//
in
  ans
end // end of [filename_test_ext]

(* ****** ****** *)

implement
{}(*tmp*)
filename_get_base (name) = let
//
#define NUL '\000'
overload + with add_ptr_bsz
//
fun loop
(
  p1: ptr, p2: ptr, c0: char
) : ptr = let
  val c = $UN.ptr0_get<char> (p1)
in
  if c != NUL then let
    val p1 = p1 + i2sz(1)
  in
    if c != c0 then loop (p1, p2, c0) else loop (p1, p1, c0)
  end else p2 // end of [if]
end // end of [loop]
//
val c0 = dirsep_get<> ()
val p1 = string2ptr(name)
val p2 = $effmask_all (loop (p1, p1, c0))
//
in
  $UN.castvwtp0{vStrptr1}(p2)
end // end of [filename_get_base]

(* ****** ****** *)

implement
{}(*tmp*)
filename_test_base
  (name, base0) = let
//
val (fpf | base) = filename_get_base (name)
//
val ans = eq_string_string (base0, $UN.strptr2string(base))
//
prval () = fpf (base)
//
in
  ans
end // end of [filename_test_base]

(* ****** ****** *)

(*
//
// HX-2013-04:
// this is now implemented in [filebas.cats].
//
local

extern
castfn file_mode
  {fm:file_mode} (x: string):<> file_mode (fm)
// end of [extern]

in (* in of [local] *)

implement file_mode_r = file_mode ("r")
implement file_mode_rr = file_mode ("r+")
implement file_mode_w = file_mode ("w")
implement file_mode_ww = file_mode ("w+")
implement file_mode_a = file_mode ("a")
implement file_mode_aa = file_mode ("a+")

end // end of [local]
*)

(* ****** ****** *)

extern
castfn
__cast_filp (r: FILEref): FILEptr1

(* ****** ****** *)

implement
{}(*tmp*)
test_file_mode
  (path) = let
//
typedef stat = $STAT.stat
//
var st: stat?
val err = $STAT.stat (path, st)
//
in
//
if err >= 0
then let
  prval () = opt_unsome{stat}(st)
  val test =
  test_file_mode$pred<> ($UN.cast{uint}(st.st_mode))
in
  if test then 1(*true*) else 0(*false*)
end // end of [then]
else let
  prval () = opt_unnone{stat}(st) in ~1(*failure*)
end // end of [else]
//
end // end of [test_file_mode]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_open_opt
  (path, fm) = let
//
val
filp = $STDIO.fopen (path, fm)
val
isnot = $STDIO.FILEptr2ptr(filp) > 0
//
in
//
if
isnot
then let
//
val filr =
  $STDIO.FILEptr_refize(filp)
//
in
  Some_vt{FILEref}(filr) // success
end // end of [then]
else let
//
prval () =
  $STDIO.FILEptr_free_null(filp)
//
in
  None_vt{FILEref}((*void*)) // failure
end // end of [else]
//
end // end of [fileref_open_opt]

(* ****** ****** *)

(*
//
// HX: atspre_fileref_close
//
implement
fileref_close (fil) = $STDIO.fclose0_exn (fil)
*)

(* ****** ****** *)

(*
//
// HX: atspre_fileref_flush
//
implement
fileref_flush (fil) = $STDIO.fflush0_exn (fil)
*)

(* ****** ****** *)

(*
//
// HX: atspre_fileref_getc
//
implement fileref_getc (inp) = $STDIO.fgetc0 (inp)
*)

(* ****** ****** *)

(*
//
// HX: atspre_fileref_putc_int
// HX: atspre_fileref_putc_char
//
implement
fileref_putc_int (out, c) = let
  val _(*ignored*) = $STDIO.fputc0 (c, out) in (*nothing*)
end // end of [fileref_putc_int]
implement
fileref_putc_char (out, c) = fileref_putc_int (out, (c2i)c)
*)

(* ****** ****** *)

(*
//
// HX: atspre_fileref_puts
//
implement
fileref_puts (out, s) = let
  val _(*ignored*) = $STDIO.fputs0 (s, out) in (*nothing*)
end // end of [fileref_puts]
*)

(* ****** ****** *)

(*
//
// HX: atspre_fileref_is_eof
//
implement
fileref_is_eof (fil) =
  if $STDIO.feof0 (fil) != 0 true else false
// end of [fileref_is_eof]
*)

(* ****** ****** *)
//
implement fileref_load<int> = fileref_load_int
implement fileref_load<lint> = fileref_load_lint
implement fileref_load<uint> = fileref_load_uint
implement fileref_load<ulint> = fileref_load_ulint
//
implement fileref_load<float> = fileref_load_float
implement fileref_load<double> = fileref_load_double
//
(* ****** ****** *)

implement{a}
fileref_get_optval (r) = let
  var x: a?
  val yn = fileref_load<a> (r, x)
in
  option_vt_make_opt<a> (yn, x)
end // end of [fileref_get_optval]

(* ****** ****** *)

implement{a}
fileref_get_exnmsg
  (r, msg) = let
  var x: a?
  val yn = fileref_load<a> (r, x)
in
  if yn then let
    prval () = opt_unsome (x) in x
  end else let
    prval () = opt_unnone (x) in exit_errmsg (1, msg)
  end (* end of [if] *)
end // end of [fileref_get_exnmsg]

(* ****** ****** *)

implement
fileref_get_line_charlst
  (inp) = let
//
val EOL = '\n'
//
fun loop
(
  inp: FILEref, res: &ptr? >> charlst_vt
) : void = let
  val i = fileref_getc (inp)
in
//
if i >= 0 then let
  val c = int2char0(i)
in
//
if (c != EOL) then let
  val () =
  (
    res :=
    list_vt_cons{char}{0}(c, _)
  )
  val+list_vt_cons (_, res1) = res
  val () = loop (inp, res1)
  prval () = fold@ (res)
in
  // nothing
end else (res := list_vt_nil)
//
end else (res := list_vt_nil)
//
end // end of [loop]
//
var res: ptr
val () = loop (inp, res)
//
in
  res
end // end of [fileref_get_line_charlst]

(* ****** ****** *)

implement
fileref_get_lines_charlstlst
  (inp) = let
//
vtypedef line = charlst_vt
vtypedef lines = List0_vt (line)
//
fun loop
(
  inp: FILEref
, res: &lines? >> lines
) : void = let
  val iseof = fileref_is_eof (inp)
in
//
if iseof then let
  val () = (res := list_vt_nil ())
in
  // nothing
end else let
  val line =
    fileref_get_line_charlst (inp)
  val () =
  (
    res := list_vt_cons{line}{0}(line, _)
  )
  val+list_vt_cons (_, res1) = res
  val () = loop (inp, res1)
  prval () = fold@ (res)
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
var res: lines
val () = loop (inp, res)
//
in
  res
end // end of [fileref_get_lines_charlstlst]

(* ****** ****** *)
//
implement
fileref_get_file_charlst
  (inp) = fileref_get2_file_charlst (inp, ~1)
//
(* ****** ****** *)

local

fun loop
(
  inp: FILEref
, n: int, res: &ptr? >> charlst_vt
) : int = let
in
//
if n != 0 then let
  val i = fileref_getc (inp)
in
  if i >= 0 then let
    val () =
    (
      res :=
      list_vt_cons{char}{0}(i2c(i), _)
    )
    val+list_vt_cons (_, res1) = res
    val n = loop (inp, pred(n), res1)
    prval () = fold@ (res)
  in
    n
  end else let
    val () = res := list_vt_nil () in (n)
  end // end of [if]
end else let
  val () = res := list_vt_nil () in n(*=0*)
end // end of [if]
//
end // end of [loop]

in (* in of [local] *)

implement
fileref_get2_file_charlst
  (inp, n) = res where
{
  var res: ptr; val _(*nleft*) = loop (inp, n, res)
} // end of [fileref_nget_file_charlst]

end // end of [local]

(* ****** ****** *)

implement
fileref_put_charlst
  (out, cs) = let
//
fun loop
(
  out: FILEref, cs: List(char)
) : void = let
in
//
case+ cs of
| list_cons (c, cs) => let
    val () = fileref_putc (out, c) in loop (out, cs)
  end // end of [list_cons]
| list_nil ((*void*)) => ()
//
end // end of [loop]
//
in
  loop (out, cs)
end // end of [fileref_put_charlst]

(* ****** ****** *)
//
implement
{}(*tmp*)
fileref_get_line_string$bufsize () = 64
implement
{}(*tmp*)
fileref_get_file_string$bufsize () = 1024
//
(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_line_string
  (inp) = let
//
var nlen: int // uninitialized
val line = fileref_get_line_string_main (inp, nlen)
prval () = lemma_strnptr_param (line)
//
in
  strnptr2strptr (line)
end // end of [fileref_get_line_string]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_line_string_main
  (inp, nlen) = let
//
val bsz =
fileref_get_line_string$bufsize ()
//
val [l:addr,n:int] str = $extfcall
(
Strnptr0, "atspre_fileref_get_line_string_main2", bsz, inp, addr@(nlen)
)
//
prval () = lemma_strnptr_param (str)
//
extern
praxi
__assert {l:addr} (pf: !int? @ l >> int (n) @ l): void
prval () = __assert (view@(nlen)) 
//
val isnot = strnptr_isnot_null (str)
//
in
//
if isnot then str else let
  val (
  ) = exit_errmsg_void (1, "[fileref_get_line_string] failed.")
  val () = assert (nlen >= 0) // HX: for TC // deadcode at run-time
in
  str // HX: [str]=null is not returned
end (* end of [if] *)
//
end // end of [fileref_get_line_string_main]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_lines_stringlst
  (inp) = let
//
vtypedef line = Strptr1
vtypedef lines = List0_vt (line)
//
fun loop
(
  inp: FILEref
, res: &lines? >> lines
) : void = let
  val iseof = fileref_is_eof (inp)
in
//
if iseof then let
  val () = (res := list_vt_nil ())
in
  // nothing
end else let
  val line =
    fileref_get_line_string (inp)
  val () =
  (
    res := list_vt_cons{line}{0}(line, _)
  )
  val+list_vt_cons (_, res1) = res
  val () = loop (inp, res1)
  prval () = fold@ (res)
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
var res: lines
val () = loop (inp, res)
//
in
  res
end // end of [fileref_get_lines_stringlst]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_file_string (inp) = let
//
#define CNUL '\000'
//
fun loop
(
  inp: FILEref
, p0: ptr, n0: size_t, p1: ptr, n1: size_t
) : Strptr1 = let
//
val nw = $extfcall (size_t, "atslib_fread", p1, 1, n1, inp)
//
in
//
if nw > 0
then let
  val n1 = n1 - nw
  val p1 = add_ptr_bsz (p1, nw)
in
  if n1 > 0 then
    loop (inp, p0, n0, p1, n1) else loop2 (inp, p0, n0)
  // end of [if]
end else let
  val () = $UN.ptr0_set<char> (p1, CNUL) in $UN.castvwtp0{Strptr1}(p0)
end // end of [if]
//
end // end of [loop]
//
and loop2
(
  inp: FILEref, p0: ptr, n0: size_t
) : Strptr1 = let
  val bsz = succ(n0)
  val bsz2 = g1ofg0(bsz + bsz)
  val (pf, pfgc | p0_) = malloc_gc (bsz2)
  val p0_ = $UN.castvwtp0{ptr}((pf, pfgc | p0_))
  val _(*ptr*) = $extfcall (ptr, "atslib_memcpy", p0_, p0, n0)
  val () = strptr_free ($UN.castvwtp0{Strptr1}(p0))
  val n0_ = pred(g0ofg1(bsz2))
  val p1_ = add_ptr_bsz (p0_, n0)
in
  loop (inp, p0_, n0_, p1_, bsz)
end // end of [loop2]
//
val bsz =
  fileref_get_file_string$bufsize ()
val bsz = i2sz(bsz)
val (pf, pfgc | p0_) = malloc_gc (bsz)
val p0_ = $UN.castvwtp0{ptr}((pf, pfgc | p0_))
val n0_ = pred(bsz)
//
in
  loop (inp, p0_, n0_, p0_, n0_)
end // end of [fileref_get_file_string]

(* ****** ****** *)

%{
extern
atstype_ptr
atspre_fileref_get_line_string_main2
(
  atstype_int bsz0
, atstype_ptr filp0
, atstype_ref nlen // int *nlen
)
{
//
  int bsz = bsz0 ;
  FILE *filp = (FILE*)filp0 ;
  int ofs = 0, ofs2 ;
  char *buf, *buf2, *pres ;
  buf = atspre_malloc_gc(bsz) ;
//
  while (1) {
    buf2 = buf+ofs ;
    pres = fgets(buf2, bsz-ofs, filp) ;
    if (!pres)
    {
      if (feof(filp))
      {
        *buf2 = '\000' ;
        *(int*)nlen = ofs ; return buf ;
      } else {
        atspre_mfree_gc(buf) ;
        *(int*)nlen = -1 ; return (char*)0 ;
      } // end of [if]
    }
    ofs2 = strlen(buf2) ;
    if (ofs2==0) return buf ;
    ofs += ofs2 ; // HX: ofs > 0
//
// HX: the newline symbol needs to be trimmed:
//
    if (buf[ofs-1]=='\n')
    {
      buf[ofs-1] = '\0'; *(int*)nlen = ofs-1 ; return buf ;
    }
//
// HX: there is room // so there are no more chars:
//
    if (ofs+1 < bsz) { *(int*)nlen = ofs ; return buf ; }
//
// HX: there is no room // so another call to [fgets] is needed:
//
    bsz *= 2 ;
    buf2 = buf ; buf = atspre_malloc_gc(bsz) ; memcpy(buf, buf2, ofs) ;
    atspre_mfree_gc(buf2) ;
  } // end of [while]
//
  return buf ; // HX: deadcode
//
} // end of [atspre_fileref_get_line_string_main2]
%}

(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_word (inp) = let
//
vtypedef
res = List0_vt(charNZ)
//
fun
loop1 (): res = let
//
val c = $STDIO.fgetc0 (inp)
//
in
//
if
(c > 0)
then let
  val c = $UN.cast{charNZ}(c)
  val test = fileref_get_word$isalpha<> (c)
in
  if test then loop2 (c, list_vt_nil()) else loop1 ()
end // end of [then]
else list_vt_nil ((*void*))
//
end // end of [loop1]

and loop2
(
  c: charNZ, cs: res
) : res = let
//
val c2 = $STDIO.fgetc0 (inp)
//
in
//
if
(c2 > 0)
then let
  val c2 = $UN.cast{charNZ}(c2)
  val test = fileref_get_word$isalpha<> (c2)
in
  if test then loop2 (c2, list_vt_cons(c, cs)) else list_vt_cons(c, cs)
end // end of [then]
else list_vt_cons(c, cs)
//
end // end of [loop2]
//
val cs = loop1 ()
//
in
  case+ cs of
  | list_vt_cons _ => let
      val str =
        string_make_rlist ($UN.list_vt2t(cs))
      val () = list_vt_free (cs)
    in
      strnptr2strptr (str)
    end // end of [list_vt_cons]
  | ~list_vt_nil () => strptr_null ()
end // end of [fileref_get_word]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_word$isalpha (charNZ) = isalpha (charNZ)

(* ****** ****** *)

implement
{}(*tmp*)
fileref_foreach
  (inp) = let
  var env: void = ()
in
  fileref_foreach_env (inp, env)
end // end of [fileref_foreach]

(* ****** ****** *)

local
//
staload "libc/SATS/stdio.sats"
//
extern
fun fread
  (ptr, size_t, size_t, FILEref): Size = "mac#atslib_fread"
//
in (* in of [local] *)

implement
{env}(*tmp*)
fileref_foreach_env
   (inp, env) = let
//
fun loop
  {l:addr}{n:int}
(
  pf: !b0ytes(n) @ l
| inp: FILEref, bufp: ptr(l), bsz: size_t(n), env: &env
) : void = let
//
val bsz2 = fread (bufp, i2sz(1), bsz, inp)
prval [n2:int] EQINT() = g1uint_get_index (bsz2)
//
in
//
if bsz2 > 0 then
{
  val A = $UN.cast{arrayref(char,n2)}(bufp)
  val () = fileref_foreach$fworkv<env> (A, bsz2, env)
  val ((*void*)) = loop (pf | inp, bufp, bsz, env)
} (* end of [if] *)
//
end // end of [loop]
//
val bsz = fileref_foreach$bufsize<> ()
val (pf1, pf2 | bufp) = memory$alloc<> (bsz)
val ((*void*)) = loop (pf1 | inp, bufp, bsz, env)
val ((*void*)) = memory$free<> (pf1, pf2 | bufp)
//
in
  // nothing
end // end of [fileref_foreach_env]

end // end of [local]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_foreach$bufsize () = i2sz(4 * 1024)

(* ****** ****** *)

implement
{env}(*tmp*)
fileref_foreach$fworkv
  (A, n, env) = let
//
implement
{a}{env}
array_foreach$cont (x, env) = true
implement
array_foreach$fwork<char><env>
  (x, env) = fileref_foreach$fwork<env> (x, env)
//
in
  ignoret (arrayref_foreach_env<char><env> (A, n, env))
end // end of [fileref_foreach$fworkv]

(* ****** ****** *)

(* end of [filebas.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"
staload _(*anon*) = "prelude/DATS/unsafe.dats"

(* ****** ****** *)

abstype List0_(a:t@ype+) = List0(a)

(* ****** ****** *)

implement
{x}(*tmp*)
list_make_sing (x) = list_vt_cons{x}(x, list_vt_nil)
implement
{x}(*tmp*)
list_make_pair (x1, x2) = list_vt_cons{x}(x1, list_vt_cons{x}(x2, list_vt_nil))

(* ****** ****** *)

implement
{x}(*tmp*)
list_make_elt
  {n} (n, x) = let
  fun loop
    {i:nat | i <= n} .<i>.
  (
    i: int i, x: x, res: list_vt (x, n-i)
  ) :<> list_vt (x, n) = (
    if i > 0 then
      loop (pred(i), x, list_vt_cons (x, res)) else res
    // end of [if]
  ) // end of [loop]
in
  loop (n, x, list_vt_nil ())
end // end of [list_make_elt]

(* ****** ****** *)

implement
{}(*tmp*)
list_make_intrange
  {l0,r} (l0, r) = let
//
typedef elt = intBtw (l0, r)
vtypedef res (l:int) = list_vt (elt, r-l)
fun loop {
  l:int | l0 <= l; l <= r
} .<r-l>. (
  l: int l, r: int r, res: &ptr? >> res (l)
) :<!wrt> void =
  if l < r then let
    val () = res :=
      list_vt_cons{elt}{0}(l, _)
    val+list_vt_cons (_, res1) = res
    val () = loop (l+1, r, res1)
  in
    fold@ (res)
  end else (res := list_vt_nil)
// end of [loop]
//
var res: ptr
val () = $effmask_wrt (loop (l0, r, res))
//
in
  res
end // end of [list_make_intrange]

(* ****** ****** *)

implement
{a}(*tmp*)
list_make_array
  {n} (A, n) = let
//
prval () = lemma_array_param (A)
vtypedef res (n:int) = list_vt (a, n)
fun loop
  {l:addr}
  {n:nat} .<n>. (
  pf: !array_v (a, l, n) >> array_v (a?!, l, n)
| p: ptr l
, n: size_t n
, res: &ptr? >> res(n)
) :<!wrt> void =
  if n > 0 then let
    prval (
      pf1, pf2
    ) = array_v_uncons (pf)
    val () = res :=
      list_vt_cons{a}{0}(_, _)
    val+list_vt_cons (x, res1) = res
    val () = x := !p
    val () = loop (pf2 | ptr1_succ<a> (p), pred(n), res1)
    prval () = pf := array_v_cons (pf1, pf2)
    prval () = fold@ (res)
  in
    // nothing
  end else let
    prval () = array_v_unnil (pf)
    prval () = pf := array_v_nil ()
  in
    res := list_vt_nil ()
  end // end of [if]
// end of [loop]
var res: ptr // uninitialized
val () = loop (view@(A) | addr@(A), n, res)
//
in
  res
end // end of [list_make_array]

(* ****** ****** *)

implement
{a}(*tmp*)
list_make_arrpsz
  {n} (A0) = let
//
var asz: size_t
val A = arrpsz_get_ptrsize (A0, asz)
val p = arrayptr2ptr (A)
prval pfarr = arrayptr_takeout (A)
val res = list_make_array (!p, asz)
prval () = arrayptr_addback (pfarr | A)
val () = arrayptr_free (A)
//
in
  res
end // end of [list_make_arrpsz]

(* ****** ****** *)

implement
{a}(*tmp*)
print_list (xs) = fprint_list<a> (stdout_ref, xs)
implement
{a}(*tmp*)
prerr_list (xs) = fprint_list<a> (stderr_ref, xs)

(* ****** ****** *)

implement
{}(*tmp*)
fprint_list$sep
  (out) = fprint_string (out, ", ")
// end of [fprint_list$sep]

implement
{a}(*tmp*)
fprint_list (out, xs) = let
//
implement(env)
list_iforeach$fwork<a><env>
  (i, x, env) = let
  val () =
    if i > 0 then fprint_list$sep<(*none*)> (out)
  // end of [val]
in
  fprint_val<a> (out, x)
end // end of [list_iforeach$fwork]
//
val _(*len*) = list_iforeach<a> (xs)
//
in
  // nothing
end // end of [fprint_list]

implement
{a}(*tmp*)
fprint_list_sep
  (out, xs, sep) = let
//
implement
fprint_list$sep<(*none*)> (out) = fprint_string (out, sep)
//
in
  fprint_list<a> (out, xs)
end // end of [fprint_list_sep]

(* ****** ****** *)
(*
//
// HX-2012-05:
// Compiling this can be a great challenge!
//
*)
implement
{a}(*tmp*)
fprint_listlist_sep
  (out, xss, sep1, sep2) = let
//
implement
fprint_val<List0_(a)>
  (out, xs) = let
  val xs = $UN.cast{List0(a)}(xs)
in
  fprint_list_sep<a> (out, xs, sep2)
end // end of [fprint_val]
//
in
  fprint_list_sep<List0_(a)> (out, $UN.cast{List(List0_(a))}(xss), sep1)
end // end of [fprint_listlist_sep]

(* ****** ****** *)

implement
{}(*tmp*)
list_is_nil (xs) =
  case+ xs of list_nil () => true | _ =>> false
// end of [list_is_nil]

implement
{}(*tmp*)
list_is_cons (xs) =
  case+ xs of list_cons _ => true | _ =>> false
// end of [list_is_cons]

implement
{x}(*tmp*)
list_is_sing (xs) =
  case+ xs of list_sing (x) => true | _ =>> false
// end of [list_is_sing]

implement
{x}(*tmp*)
list_is_pair (xs) =
  case+ xs of list_pair (x1, x2) => true | _ =>> false
// end of [list_is_pair]

(* ****** ****** *)

implement
{x}(*tmp*)
list_head (xs) =
  let val+list_cons (x, _) = xs in x end
// end of [list_head]
implement
{x}(*tmp*)
list_tail (xs) =
  let val+list_cons (_, xs) = xs in xs end
// end of [list_tail]
implement
{x}(*tmp*)
list_last (xs) = let
//
fun loop
  (xs: List1 (x)): x = let
  val+list_cons (x, xs) = xs
in
  case+ xs of
  | list_cons _ => loop (xs) | list_nil _ => x
end // end of [loop]
//
in
  $effmask_all (loop (xs))
end // end of [list_last]

(* ****** ****** *)

implement
{x}(*tmp*)
list_head_exn (xs) =
(
case+ xs of
| list_cons (x, _) => x | _ => $raise ListSubscriptExn()
) (* end of [list_head_exn] *)

implement
{x}(*tmp*)
list_tail_exn (xs) =
(
case+ xs of
| list_cons (_, xs) => xs | _ => $raise ListSubscriptExn()
) (* end of [list_tail_exn] *)

implement
{x}(*tmp*)
list_last_exn (xs) =
(
case+ xs of
| list_cons _ => list_last (xs) | _ => $raise ListSubscriptExn()
) (* end of [list_last_exn] *)

(* ****** ****** *)

implement
{a}(*tmp*)
list_nth (xs, i) = let
//
fun loop
  {n,i:nat | i < n} .<i>. (
  xs: list (a, n), i: int i
) :<> a =
  if i > 0 then let
    val+list_cons (_, xs) = xs in loop (xs, pred(i))
  end else list_head<a> (xs)
//
in
  loop (xs, i)
end // end of [list_nth]

implement
{a}(*tmp*)
list_nth_opt (xs, i) = let
//
fun loop
  {n:nat} .<n>.
(
  xs: list (a, n), i: intGte(0)
) :<> Option_vt (a) =
(
case+ xs of
| list_nil () => None_vt ()
| list_cons (x, xs) =>
    if i = 0 then Some_vt(x) else loop (xs, pred(i))
  // end of [list_vt_cons]
) (* end of [loop] *)
//
prval () = lemma_list_param (xs)
//
in
  loop (xs, i)
end // end of [list_nth_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
list_get_at (xs, i) = list_nth<a> (xs, i)
implement
{a}(*tmp*)
list_get_at_opt (xs, i) = list_nth_opt<a> (xs, i)

(* ****** ****** *)

implement
{a}(*tmp*)
list_set_at
  (xs, i, x_new) = let
  val (xs1, xs2) =
    $effmask_wrt (list_split_at<a> (xs, i))
  val+list_cons (x_old, xs2) = xs2
  val xs2 = list_cons{a}(x_new, xs2)
in
  $effmask_wrt (list_append1_vt<a> (xs1, xs2))
end // ed of [list_set_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_exch_at
  (xs, i, x_new) = let
  val (xs1, xs2) =
    $effmask_wrt (list_split_at<a> (xs, i))
  val+list_cons (x_old, xs2) = xs2
  val xs2 = list_cons{a}(x_new, xs2)
in
  ($effmask_wrt (list_append1_vt<a> (xs1, xs2)), x_old)
end // ed of [list_exch_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_insert_at
  (xs, i, x) = let
//
fun loop{n:int}
  {i:nat | i <= n} .<i>.
(
  xs: list (a, n)
, i: int i, x: a
, res: &ptr? >> list (a, n+1)
) :<!wrt> void =
  if i > 0 then let
    val+list_cons (x1, xs1) = xs
    val () = res :=
      list_cons{a}{0}(x1, _(*?*))
    val+list_cons
      (_, res1) = res // res1 = res.1
    val () = loop (xs1, i-1, x, res1)
    prval () = fold@ (res)
  in
    // nothing
  end else res := list_cons (x, xs)
//
var res: ptr
val () = $effmask_wrt (loop (xs, i, x, res))
//
in
  res
end // end of [list_insert_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_takeout_at
  (xs, i, x0) = let
//
fun loop{n:int}
  {i:nat | i < n} .<i>.
(
  xs: list (a, n)
, i: int i, x0: &a? >> a
, res: &ptr? >> list (a, n-1)
) :<!wrt> void = let
//
val+list_cons (x, xs) = xs
//
in
//
if i > 0 then let
  val () =
    res := list_cons{a}{0}(x, _(*?*))
  val+list_cons
    (_, res1) = res // res1 = res.1
  val () = loop (xs, i-1, x0, res1)
  prval () = fold@ (res)
in
  // nothing
end else let
  val () = x0 := x; val () = res := xs
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
var res: ptr?
val () = loop (xs, i, x0, res)
//
in
  res
end // end of [list_takeout_at]

(* ****** ****** *)

implement
{x}(*tmp*)
list_length (xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {i,j:nat} .<i>. (
  xs: list (x, i), j: int j
) :<> int (i+j) = (
  case+ xs of
  | list_cons (_, xs) => loop (xs, j+1) | _ =>> j
) // end of [loop]
//
in
  loop (xs, 0)
end // end of [list_length]

(* ****** ****** *)

implement
{x}(*tmp*)
list_copy
  (xs) = res where {
//
vtypedef res = List0_vt (x)
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>.
(
  xs: list (x, n)
, res: &res? >> list_vt (x, n)
) :<!wrt> void = let
in
//
case+ xs of
| list_cons
    (x, xs) => let
    val () = res :=
      list_vt_cons{x}{0}(x, _(*?*))
    val+list_vt_cons
      (_, res1) = res // res1 = res.1
    val () = loop (xs, res1)
    prval () = fold@ (res)
  in
    // nothing
  end // end of [cons]
| list_nil () => res := list_vt_nil ()
//
end // end of [loop]
//
var res: res? ; val () = loop (xs, res)
//
} // end of [list_copy]

(* ****** ****** *)

implement
{a}(*tmp*)
list_append
  {m,n} (xs, ys) = let
  val ys = __cast (ys) where {
    extern castfn __cast (ys: list (a, n)):<> list_vt (a, n)
  } // end of [where] // end of [val]
in
$effmask_wrt
(
  list_of_list_vt (list_append2_vt (xs, ys))
) // end of [$effmask_wrt]
end // end of [list_append]

implement
{a}(*tmp*)
list_append1_vt
  {m,n} (xs, ys) = let
  val ys = __cast (ys) where {
    extern castfn __cast (ys: list (a, n)):<> list_vt (a, n)
  } // end of [val]
in
  list_of_list_vt (list_vt_append (xs, ys))
end // end of [list_append1_vt]

implement
{a}(*tmp*)
list_append2_vt
  {m,n} (xs, ys) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_vt_param (ys)
//
fun loop
  {m:nat} .<m>. (
  xs: list (a, m)
, ys: list_vt (a, n)
, res: &ptr? >> list_vt (a, m+n)
) :<!wrt> void =
  case+ xs of
  | list_cons
      (x, xs) => let
      val () = res :=
        list_vt_cons{a}{0}(x, _(*?*))
      val+list_vt_cons
        (_, res1) = res // res1 = res.1
      val () = loop (xs, ys, res1)
      prval () = fold@ (res)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => res := ys
// end of [loop]
var res: ptr // uninitialized
val () = loop (xs, ys, res)
//
in
  res
end // end of [list_append2_vt]

(* ****** ****** *)

implement
{a}(*tmp*)
list_extend (xs, y) =
(
  list_append2_vt<a> (xs, list_vt_sing (y))
) // end of [list_extend]

(* ****** ****** *)

implement
{x}(*tmp*)
list_reverse (xs) = (
  list_reverse_append2_vt<x> (xs, list_vt_nil)
) // end of [list_reverse]

(* ****** ****** *)

implement
{a}(*tmp*)
list_reverse_append
  {m,n} (xs, ys) = let
//
val ys = __cast (ys) where
{
  extern castfn __cast (ys: list (a, n)):<> list_vt (a, n)
} // end of [where] // end of [val]
//
in
//
$effmask_wrt
(
  list_of_list_vt (list_reverse_append2_vt<a> (xs, ys))
) (* end of [$effmask_wrt] *)
//
end // end of [list_reverse_append]

implement
{a}(*tmp*)
list_reverse_append1_vt
  {m,n} (xs, ys) = let
//
prval (
) = lemma_list_vt_param (xs)
prval () = lemma_list_param (ys)
//
fun loop{m,n:nat} .<m>.
(
  xs: list_vt (a, m), ys: list (a, n)
) :<!wrt> list (a, m+n) = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val xs1_ = xs1
    val ys = __cast (ys) where {
      extern castfn __cast (ys: list (a, n)):<> list_vt (a, n)
    } // end of [val]
    val () = xs1 := ys
    prval () = fold@ (xs)
  in
    loop (xs1_, list_of_list_vt{a}(xs))
  end // end of [list_vt_cons]
| ~list_vt_nil () => ys
//
end // end of [loop]
//
in
  loop (xs, ys)
end // end of [list_reverse_append1_vt]

implement
{a}(*tmp*)
list_reverse_append2_vt
  (xs, ys) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_vt_param (ys)
//
fun loop
  {m,n:nat} .<m>.
(
  xs: list (a, m), ys: list_vt (a, n)
) :<!wrt> list_vt (a, m+n) =
  case+ xs of
  | list_cons
      (x, xs) => loop (xs, list_vt_cons{a}(x, ys))
  | list_nil () => ys // end of [list_nil]
// end of [loop]
in
  loop (xs, ys)
end // end of [list_reverse_append2_vt]

(* ****** ****** *)

implement
{a}(*tmp*)
list_concat (xss) = let
//
prval () = lemma_list_param (xss)
//
typedef T = List (a)
fun aux {n:nat} .<n>.
(
  xs0: T
, xss: list (T, n)
) :<!wrt> List0_vt (a) = let
  prval () = lemma_list_param (xs0)
in
  case+ xss of
  | list_cons
      (xs, xss) => let
      val res = aux (xs, xss)
      val ys0 = list_copy (xs0)
    in
      list_vt_append<a> (ys0, res)
    end // end of [list_cons]
  | list_nil () => list_copy (xs0)
end // end of [aux]
//
in
//
case+ xss of
| list_cons
    (xs, xss) => aux (xs, xss)
| list_nil () => list_vt_nil ()
//
end // end of [list_concat]

(* ****** ****** *)

implement
{a}(*tmp*)
list_take (xs, i) = let
//
fun loop
  {n:int}
  {i:nat | i <= n} .<i>. (
  xs: list (a, n), i: int i
, res: &ptr? >> list_vt (a, i)
) :<!wrt> void =
  if i > 0 then let
    val+list_cons (x, xs) = xs
    val () = res :=
      list_vt_cons{a}{0}(x, _(*?*))
    val+list_vt_cons
      (_, res1) = res // res1 = res.1
    val () = loop (xs, i-1, res1)
    val () = fold@ (res)
  in
    // nothing
  end else (res := list_vt_nil ())
// end of [loop]
//
var res: ptr
val () = loop (xs, i, res)
//
in
  res
end // end of [list_take]

implement
{a}(*tmp*)
list_take_exn
  {n}{i} (xs, i) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat}
  {i:nat} .<i>. (
  xs: list (a, n), i: int i
, res: &ptr? >> list_vt (a, j)
) :<!wrt> #[
  j:nat | (i <= n && i == j) || (i > n && n == j)
] bool (i <= n) = let
//
in
//
if i > 0
then let
in
//
case+ xs of
| list_cons
    (x, xs1) => let
    val ((*void*)) =
    res := list_vt_cons{a}{0}(x, _)
    val+list_vt_cons (_, res1) = res
    val ans = loop (xs1, i-1, res1)
  in
    fold@ (res); ans
  end // end of [list_cons]
| list_nil () => let
    val ((*void*)) =
    res := list_vt_nil () in false(*fail*)
  end // end of [list_nil]
//
end // end of [then]
else let
  val () = res := list_vt_nil () in true(*succ*)
end // end of [else]
// end of [if]
//
end // end of [loop] 
//   
var res: ptr
val ans = loop{n}{i}(xs, i, res)
//
in
//
if ans
then res // i <= n && length (res) == i
else let
  val () = list_vt_free<a> (res) in $raise ListSubscriptExn()
end // end of [if]
//
end (* end of [list_take_exn] *)

(* ****** ****** *)

implement
{a}(*tmp*)
list_drop (xs, i) = let
//
fun loop
  {n:int}
  {i:nat | i <= n} .<i>.
  (xs: list (a, n), i: int i):<> list (a, n-i) =
  if i > 0 then let
    val+list_cons (_, xs) = xs in loop (xs, i-1)
  end else xs // end of [if]
//
in
  loop (xs, i)
end // end of [list_drop]

implement
{a}(*tmp*)
list_drop_exn
  (xs, i) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat}{i:nat} .<i>. (
  xs: list (a, n), i: int i
) :<!exn> [i <= n] list (a, n-i) =
  if i > 0 then (
    case+ xs of
    | list_cons (_, xs) => loop (xs, i-1)
    | list_nil () => $raise ListSubscriptExn()
  ) else (xs) // end of [if]
//
in
  loop (xs, i)
end // end of [list_drop_exn]

(* ****** ****** *)

implement
{x}(*tmp*)
list_split_at
  (xs, i) = let
//
fun loop
  {n:int}
  {i:nat | i <= n} .<n>.
(
  xs: list (x, n), i: int i
, res: &ptr? >> list_vt (x, i)
) :<!wrt> list (x, n-i) =
(
if i > 0
  then let
    val+list_cons (x, xs) = xs
    val () =
      res := list_vt_cons{x}{0}(x, _)
    // end of [val]
    val+list_vt_cons (_, res1) = res
    val xs2 = loop (xs, i-1, res1)
    prval () = fold@ (res)
  in
    xs2
  end // end of [then]
  else let
    val () = res := list_vt_nil () in xs
  end // end of [else]
// end of [if]
)
//
var res: ptr
val xs2 = loop (xs, i, res)
//
in
  (res, xs2)
end // end of [list_split_at]

(* ****** ****** *)

implement
{x}(*tmp*)
list_exists (xs) = let
in
//
case+ xs of
| list_cons (x, xs) =>
    if list_exists$pred<x> (x) then true else list_exists<x> (xs)
| list_nil () => false
//
end // end of [list_exists]

implement
{x}(*tmp*)
list_forall (xs) = let
in
//
case+ xs of
| list_cons (x, xs) =>
    if list_forall$pred<x> (x) then list_forall<x> (xs) else false
| list_nil () => true
//
end // end of [list_forall]

(* ****** ****** *)

implement
{a}(*tmp*)
list_equal$eqfn = gequal_val_val<a>

implement
{x}(*tmp*)
list_equal
  (xs1, xs2) = let
in
//
case+ xs1 of
| list_cons (x1, xs1) =>
  (
    case+ xs2 of
    | list_cons
        (x2, xs2) => let
        val iseq = list_equal$eqfn<x> (x1, x2)
      in
        if iseq then list_equal<x> (xs1, xs2) else false
      end
    | list_nil () => false
  ) // end of [list_cons]
| list_nil ((*void*)) =>
  (
    case+ xs2 of list_cons _ => false | list_nil () => true
  ) // end of [list_nil]
//
end // end of [list_equal]

(* ****** ****** *)

implement
{x}(*tmp*)
list_find_exn (xs) = let
in
//
case+ xs of
| list_cons (x, xs) =>
    if list_find$pred<x> (x) then x else list_find_exn<x> (xs)
| list_nil () => $raise NotFoundExn()
//
end // end of [list_find_exn]

implement
{x}(*tmp*)
list_find_opt (xs) = let
in
//
case+ xs of
| list_cons (x, xs) =>
    if list_find$pred<x> (x) then Some_vt{x}(x) else list_find_opt<x> (xs)
| list_nil () => None_vt(*void*)
//
end // end of [list_find_opt]

(* ****** ****** *)

implement
{key}(*tmp*)
list_assoc$eqfn = gequal_val_val<key>

implement
{key,itm}
list_assoc
  (kxs, k0, x0) = let
//
fun loop
(
  kxs: List @(key, itm)
, k0: key, x0: &itm? >> opt (itm, b)
) : #[b:bool] bool(b) =
(
  case+ kxs of
  | list_cons
      (kx, kxs) => let
      val iseq = list_assoc$eqfn<key> (k0, kx.0)
    in
      if iseq
        then let
          val () = x0 := kx.1
          prval () = opt_some{itm}(x0)
        in
          true
        end // end of [then]
        else loop (kxs, k0, x0)
      // end of [if]
    end // end of [list_cons]
  | list_nil ((*void*)) =>
      let prval () = opt_none{itm}(x0) in false end 
    // end of [list_nil]
) (* end of [loop] *)
//
in
  $effmask_all (loop (kxs, k0, x0))
end // end of [list_assoc]

(* ****** ****** *)

implement
{key,itm}
list_assoc_exn
  (kxs, k0) = let
  var x0: itm?
  val ans = list_assoc<key,itm> (kxs, k0, x0)
in
//
if ans
  then let
    prval () = opt_unsome{itm}(x0) in x0
  end // end of [then]
  else let
    prval () = opt_unnone{itm}(x0) in $raise NotFoundExn()
  end // end of [else]
//
end // end of [list_assoc_exn]

(* ****** ****** *)

implement
{key,itm}
list_assoc_opt
  (kxs, k0) = let
  var x0: itm?
  val ans = list_assoc<key,itm> (kxs, k0, x0)
in
//
if ans
  then let
    prval () = opt_unsome{itm}(x0) in Some_vt{itm}(x0)
  end // end of [then]
  else let
    prval () = opt_unnone{itm}(x0) in None_vt((*void*))
  end // end of [else]
//
end // end of [list_assoc_opt]

(* ****** ****** *)

implement
{x}(*tmp*)
list_filter {n} (xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list (x, n)
, res: &ptr? >> listLte_vt (x, n)
) : void = (
  case+ xs of
  | list_cons (x, xs) => let
      val test = list_filter$pred<x> (x)
    in
      case+ test of
      | true => let
          val () = res :=
            list_vt_cons{x}{0}(x, _(*?*))
          val+list_vt_cons
            (_, res1) = res // res1 = res.1
          val () = loop (xs, res1)
          prval () = fold@ (res)
        in
          // nothing
        end // end of [true]
      | false => loop (xs, res)
    end // end of [list_cons]
  | list_nil () => (res := list_vt_nil)
) // end of [loop]
//
var res: ptr
val () = loop (xs, res)
//
in
  res (*listLte_vt(x, n)*)
end // end of [list_filter]

(* ****** ****** *)

implement
{x}(*tmp*)
list_labelize
  (xs) = res where {
//
typedef ix = @(int, x)
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list (x, n), i: int
, res: &ptr? >> list_vt (ix, n)
) :<!wrt> void = let
in
  case+ xs of
  | list_cons
      (x, xs) => let
      val () = res :=
        list_vt_cons{ix}{0}(_, _)
      val+list_vt_cons (ix, res1) = res
      val () = ix.0 := i and () = ix.1 := x
      val () = loop (xs, i+1, res1)
    in
      fold@ (res)
    end // end of [list_cons]
  | list_nil () => (res := list_vt_nil)
end // end of [loop]
//
var res: ptr ; val () = loop (xs, 0, res)
//
} // end of [list_labelize]

(* ****** ****** *)

implement
{x}(*tmp*)
list_app (xs) = let
//
prval () = lemma_list_param (xs)
//
fun
loop{n:nat} .<n>. (xs: list (x, n)): void =
(
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (list_app$fwork(x); loop (xs))
) (* end of [loop] *)
//
in
  loop (xs)
end // end of [list_app]

(* ****** ****** *)

implement
{x}(*tmp*)
list_app_fun(xs, f) = let
//
prval () = lemma_list_param (xs)
//
fun
loop{n:nat} .<n>.
(
  xs: list (x, n), f: (x) -<fun1> void
) : void = (
//
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (f(x); loop (xs, f))
//
) (* end of [loop] *)
//
in
  loop (xs, f)
end // end of [list_app_fun]

implement
{x}(*tmp*)
list_app_cloref(xs, f) = let
//
prval () = lemma_list_param (xs)
//
fun
loop{n:nat} .<n>.
(
  xs: list (x, n), f: (x) -<cloref1> void
) : void = (
//
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (f(x); loop (xs, f))
//
) (* end of [loop] *)
//
in
  loop (xs, f)
end // end of [list_app_cloref]

(* ****** ****** *)

implement
{x}{y}(*tmp*)
list_map{n}(xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list (x, n)
, res: &ptr? >> list_vt (y, n)
) : void = (
  case+ xs of
  | list_cons (x, xs) => let
      val y =
        list_map$fopr<x><y> (x)
      val () = res :=
        list_vt_cons{y}{0}(y, _(*?*))
      val+list_vt_cons
        (_, res1) = res // res1 = res.1
      val () = loop (xs, res1)
      prval () = fold@ (res)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => (res := list_vt_nil)
) // end of [loop]
//
var res: ptr
val () = loop (xs, res)
//
in
  res (*list_vt (y, n)*)
end // end of [list_map]

(* ****** ****** *)

implement
{x}{y}(*tmp*)
list_map_fun
  (xs, f) = let
//
implement
{x2}{y2}
list_map$fopr (x2) = $UN.castvwtp0{y2}(f($UN.cast{x}(x2)))
//
in
  list_map<x><y> (xs)
end // end of [list_map_fun]

implement
{x}{y}(*tmp*)
list_map_clo
  (xs, f) = let
//
val f = $UN.cast{(x) -<cloref1> y}(addr@f)
//
implement
{x2}{y2}
list_map$fopr (x2) = $UN.castvwtp0{y2}(f($UN.cast{x}(x2)))
//
in
  list_map<x><y> (xs)
end // end of [list_map_clo]

implement
{x}{y}(*tmp*)
list_map_cloref
  (xs, f) = let
//
implement
{x2}{y2}
list_map$fopr (x2) = $UN.castvwtp0{y2}(f($UN.cast{x}(x2)))
//
in
  list_map<x><y> (xs)
end // end of [list_map_cloref]

(* ****** ****** *)

(*
implement
{x}{y}(*tmp*)
list_map_funenv
  {v}{vt}{n}{fe}
  (pfv | xs, f, env) = let
//
viewtypedef ys = List0_vt (y)
//
prval () =
  lemma_list_param (xs) // prove [n >= 0]
// end of [prval]
fun loop {n:nat} .<n>. (
  pfv: !v
| xs: list (x, n)
, f: (!v | x, !vt) -<fun,fe> y
, env: !vt
, res: &ys? >> list_vt (y, n)
) :<!wrt,fe> void = let
in
//
case+ xs of
| list_cons
    (x, xs) => let
    val y = f (pfv | x, env)
    val () = res :=
      list_vt_cons{y}{0}(y, _(*?*))
    val+list_vt_cons
      (_, res1) = res // res1 = res.1
    val () = loop (pfv | xs, f, env, res1)
    prval () = fold@ (res)
  in
    (*nothing*)
  end // end of [list_vt_cons]
| list_nil (
  ) => (res := list_vt_nil ())
//
end // end of [loop]
//
var res: ys // uninitialized
val () = loop (pfv | xs, f, env, res)
//
in
  res(*list_vt(y,n)*)
end // end of [list_map_funenv]
*)

(* ****** ****** *)

implement
{x}{y}
list_imap{n}(xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat}{i:nat} .<n>.
(
  xs: list (x, n), i: int(i)
, res: &ptr? >> list_vt (y, n)
) : void = (
  case+ xs of
  | list_cons
      (x, xs) => let
      val y =
        list_imap$fopr<x><y> (i, x)
      val () = res :=
        list_vt_cons{y}{0}(y, _(*?*))
      val+list_vt_cons
        (_, res1) = res // res1 = res.1
      val () = loop (xs, i+1, res1)
      prval ((*void*)) = fold@ (res)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => (res := list_vt_nil)
) // end of [loop]
//
var res: ptr
val () = loop (xs, 0, res)
//
in
  res (*list_vt (y, n)*)
end // end of [list_imap]

(* ****** ****** *)

implement
{x}{y}
list_mapopt{n}(xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list (x, n)
, res: &ptr? >> listLte_vt (y, n)
) : void = let
in
//
case+ xs of
| list_cons (x, xs) => let
    val opt =
      list_mapopt$fopr<x><y> (x)
    // end of [val]
  in
    case+ opt of
    | ~Some_vt (y) => let
        val () = res :=
          list_vt_cons{y}{0}(y, _(*?*))
        val+list_vt_cons
          (_, res1) = res // res1 = res.1
        val () = loop (xs, res1)
        prval () = fold@ (res)
      in
        // nothing
      end // end of [Some_vt]
    | ~None_vt () => loop (xs, res)
  end // end of [list_cons]
| list_nil () => (res := list_vt_nil)
//
end // end of [loop]
//
var res: ptr
val () = loop (xs, res)
//
in
  res (*listLte_vt(y, n)*)
end // end of [list_mapopt]

(* ****** ****** *)

(*
implement
{x}{y}(*tmp*)
list_mapopt_funenv
  {v}{vt}{n}{fe}
  (pfv | xs, f, env) = let
//
viewtypedef ys = List0_vt (y)
//
prval () =
  lemma_list_param (xs) // prove [n >= 0]
// end of [prval]
fun loop {n:nat} .<n>. (
  pfv: !v
| xs: list (x, n)
, f: (!v | x, !vt) -<fun,fe> Option_vt (y)
, env: !vt
, res: &ys? >> listLte_vt (y, n)
) :<!wrt,fe> void = let
in
  case+ xs of
  | list_cons
      (x, xs) => let
      val opt = f (pfv | x, env)
    in
      case+ opt of
      | ~Some_vt (y) => let
          val () = res :=
            list_vt_cons{y}{0}(y, _(*?*))
          val+list_vt_cons
            (_, res1) = res // res1 = res.1
          val () = loop (pfv | xs, f, env, res1)
          prval () = fold@ (res)
        in
          (*nothing*)
        end // end of [Some_vt]
      | ~None_vt () => loop (pfv | xs, f, env, res)
    end // end of [list_vt_cons]
  | list_nil () => (res := list_vt_nil ())
    // end of [list_nil]
end // end of [loop]
//
var res: ys // uninitialized
val () = loop (pfv | xs, f, env, res)
//
in
  res(*listLte_vt(y,n)*)
end // end of [list_mapopt_funenv]
*)

(* ****** ****** *)

implement
{x1,x2}{y}(*tmp*)
list_map2{n1,n2}(xs1, xs2) = let
//
prval () = lemma_list_param (xs1)
prval () = lemma_list_param (xs2)
//
fun
loop{n1,n2:nat}
(
  xs1: list (x1, n1)
, xs2: list (x2, n2)
, res: &ptr? >> list_vt (y, min(n1,n2))
) : void = let
in
//
case+ (xs1, xs2) of
| (list_cons (x1, xs1),
   list_cons (x2, xs2)) =>
  {
    val y = list_map2$fopr (x1, x2)
    val () =
      res := list_vt_cons{y}{0}(y, _)
    val+list_vt_cons (_, res1) = res
    val ((*void*)) = loop (xs1, xs2, res1)
    prval ((*folded*)) = fold@ (res)
  } (* end of [cons, cons] *)
| (_, _) =>> (res := list_vt_nil((*void*)))
//
end // end of [loop]
//
var res: ptr
val ((*void*)) = loop (xs1, xs2, res)
//
in
  res
end // end of [list_map2]

(* ****** ****** *)

implement
{x}(*tmp*)
list_tabulate
  (n) = res where {
//
fun loop
  {n:int}
  {i:nat | i <= n}
  .<n-i>. (
  n: int n, i: int i
, res: &ptr? >> list_vt (x, n-i)
) : void =
  if n > i then let
    val x =
      list_tabulate$fopr<x> (i)
    val () = res :=
      list_vt_cons{x}{0}(x, _(*?*))
    val+list_vt_cons
      (_, res1) = res // res1 = res.1
    val () = loop (n, succ(i), res1)
    prval () = fold@ (res)
  in
    // nothing
  end else (res := list_vt_nil)
//
var res: ptr
val () = loop (n, 0, res)
//
} // end of [list_tabulate]

(* ****** ****** *)

implement
{a}(*tmp*)
list_tabulate_fun (n, f) = let
//
val f = $UN.cast{int -> a}(f)
//
implement(a2)
list_tabulate$fopr<a2> (n) = $UN.castvwtp0{a2}(f(n))
//
in
  list_tabulate<a> (n)
end // end of [list_tabulate_fun]

implement
{a}(*tmp*)
list_tabulate_clo (n, f) = let
//
val f = $UN.cast{int -<cloref1> a}(addr@f)
//
implement(a2)
list_tabulate$fopr<a2> (n) = $UN.castvwtp0{a2}(f(n))
//
in
  list_tabulate<a> (n)
end // end of [list_tabulate_clo]

implement
{a}(*tmp*)
list_tabulate_cloref (n, f) = let
//
val f = $UN.cast{int -<cloref1> a}(f)
//
implement(a2)
list_tabulate$fopr<a2> (n) = $UN.castvwtp0{a2}(f(n))
//
in
  list_tabulate<a> (n)
end // end of [list_tabulate_cloref]

(* ****** ****** *)

implement
{x,y}
list_zip (xs, ys) = let
//
typedef xy = @(x, y)
//
implement
list_zipwith$fopr<x,y><xy> (x, y) = @(x, y)
//
in
  $effmask_all (list_zipwith<x,y><xy> (xs, ys))
end // end of [list_zip]

implement
{x,y}{xy}
list_zipwith
  (xs, ys) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_param (ys)
//
fun loop
  {m,n:nat} .<m>. (
  xs: list (x, m)
, ys: list (y, n)
, res: &ptr? >> list_vt (xy, min(m,n))
) : void = let
in
//
case+ xs of
| list_cons (x, xs) => (
  case+ ys of
  | list_cons (y, ys) => let
      val xy =
        list_zipwith$fopr<x,y><xy> (x, y)
      // end of [val]
      val () = res :=
        list_vt_cons{xy}{0}(xy, _(*y*))
      val+list_vt_cons
        (xy, res1) = res // res1 = res.1
      val () = loop (xs, ys, res1)
    in
      fold@ (res)
    end // end of [list_cons]
  | list_nil () => (res := list_vt_nil)
  ) // end of [list_cons]
| list_nil () => (res := list_vt_nil)
//
end // end of [loop]
//
var res: ptr
val () = loop (xs, ys, res)
in
  res
end // end of [list_zipwith]

(* ****** ****** *)

implement
{x,y}
list_cross (xs, ys) = let
//
typedef xy = @(x, y)
//
implement
list_crosswith$fopr<x,y><xy> (x, y) = @(x, y)
//
in
  $effmask_all (list_crosswith<x,y><xy> (xs, ys))
end // end of [list_cross]

implement
{x,y}{xy}
list_crosswith (xs, ys) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_param (ys)
//
fnx loop1
  {m,n:nat} .<m,0,0>.
(
  xs: list (x, m)
, ys: list (y, n)
, res: &ptr? >> list_vt (xy, m*n)
) : void = let
in
  case+ xs of
  | list_cons
      (x, xs) => loop2 (xs, ys, x, ys, res)
  | list_nil () => (res := list_vt_nil)
end // end of [loop1]

and loop2
  {m,n,n2:nat} .<m,n2,1>.
(
  xs: list (x, m)
, ys: list (y, n)
, x: x, ys2: list (y, n2)
, res: &ptr? >> list_vt (xy, m*n+n2)
) : void = let
in
//
case+ ys2 of
| list_cons
    (y, ys2) => let
    val xy = 
      list_crosswith$fopr<x,y><xy> (x, y)
    // end of [val]
    val () = res :=
      list_vt_cons{xy}{0}(xy, _(*?*))
    val+list_vt_cons (_, res1) = res
    val () = loop2 (xs, ys, x, ys2, res1)
    prval () = mul_gte_gte_gte {m,n} ()
  in
    fold@ (res)
  end // end of [list_cons]
| list_nil () => loop1 (xs, ys, res)
//
end // end of [loop2]
//
var res: ptr
val () = loop1 (xs, ys, res)
//
in
  res
end // end of [list_crosswith]

(* ****** ****** *)

implement
{x}(*tmp*)
list_foreach (xs) = let
  var env: void = () in list_foreach_env<x><void> (xs, env)
end // end of [list_foreach]

implement
{x}{env}
list_foreach_env
  (xs, env) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list (x, n), env: &env
) : void = let
in
//
case+ xs of
| list_cons (x, xs) => let
    val test =
      list_foreach$cont<x><env> (x, env)
    // end of [val]
  in
    if test then let
      val () = list_foreach$fwork<x><env> (x, env)
    in
      loop (xs, env)
    end else () // end of [if]
  end // end of [list_cons]
| list_nil ((*void*)) => ()
//
end // end of [loop]
//
in
  loop (xs, env)
end // end of [list_foreach_env]

(* ****** ****** *)

implement
{x}{env}
list_foreach$cont (x, env) = true

(* ****** ****** *)

implement
{x}(*tmp*)
list_foreach_fun
  (xs, f) = let
//
fun loop (xs: List(x)): void =
//
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (f (x); loop (xs))
//
in
  $effmask_all (loop (xs))
end // end of [list_foreach_fun]

implement
{x}(*tmp*)
list_foreach_cloref
  (xs, f) = let
//
fun loop (xs: List(x)): void =
//
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (f (x); loop (xs))
//
in
  $effmask_all (loop (xs))
end // end of [list_foreach_cloref]

(* ****** ****** *)

implement
{x}(*tmp*)
list_foreach_funenv
  {v}{vt}{fe}
  (pfv | xs, f, env) = let
//
prval () = lemma_list_param (xs)
//
fun loop {n:nat} .<n>. (
  pfv: !v
| xs: list (x, n)
, f: (!v | x, !vt) -<fun,fe> void
, env: !vt
) :<fe> void =
  case+ xs of
  | list_cons (x, xs) => let
      val () = f (pfv | x, env) in loop (pfv | xs, f, env)
    end // end of [list_cons]
  | list_nil ((*void*)) => ()
// end of [loop]
in
  loop (pfv | xs, f, env)
end // end of [list_foreach_funenv]

(* ****** ****** *)

implement
{x,y}(*tmp*)
list_foreach2 (xs, ys) = let
  var env: void = () in list_foreach2_env<x,y><void> (xs, ys, env)
end // end of [list_foreach2]

implement
{x,y}{env}
list_foreach2_env
  (xs, ys, env) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_param (ys)
//
fun loop
  {m,n:nat} .<m>. (
  xs: list (x, m), ys: list (y, n), env: &env
) : void = let
in
//
case+ xs of
| list_cons
    (x, xs) => (
  case+ ys of
  | list_cons (y, ys) => let
      val test =
        list_foreach2$cont<x,y><env> (x, y, env)
      // end of [val]
    in
      if test then let
        val () = list_foreach2$fwork<x,y><env> (x, y, env)
      in
        loop (xs, ys, env)
      end else () // end of [if]
    end // end of [list_cons]
  | list_nil () => ()
  ) // end of [list_cons]
| list_nil () => ()
//
end // end of [loop]
//
in
  loop (xs, ys, env)
end // end of [list_foreach2_env]

(* ****** ****** *)

implement
{x,y}{env}
list_foreach2$cont (x, y, env) = true

(* ****** ****** *)

implement
{x}(*tmp*)
list_iforeach (xs) = let
  var env: void = () in list_iforeach_env<x><void> (xs, env)
end // end of [list_iforeach]

implement
{x}{env}
list_iforeach_env
  (xs, env) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat}
  {i:nat} .<n>.
(
  i: int i, xs: list (x, n), env: &env
) : intBtwe(i,n+i) =
  case+ xs of
  | list_cons
      (x, xs) => let
      val test =
        list_iforeach$cont<x><env> (i, x, env)
      // end of [test]
    in
      if test then let
        val () = list_iforeach$fwork<x><env> (i, x, env)
      in
        loop (succ(i), xs, env)
      end else (i) // end of [if]
    end // end of [list_cons]
  | list_nil () => (i) // number of processed elements
// end of [loop]
//
in
  loop (0, xs, env)
end // end of [list_iforeach_env]

(* ****** ****** *)

implement
{x}{env}(*tmp*)
list_iforeach$cont (i, x, env) = true

(* ****** ****** *)

implement
{x}(*tmp*)
list_iforeach_funenv
  {v}{vt}{n}{fe}
  (pfv | xs, f, env) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {i:nat | i <= n} .<n-i>. (
  pfv: !v
| i: int i
, xs: list (x, n-i)
, f: (!v | natLt(n), x, !vt) -<fun,fe> void
, env: !vt
) :<fe> int n =
  case+ xs of
  | list_cons (x, xs) => let
      val () = f (pfv | i, x, env) in loop (pfv | i+1, xs, f, env)
    end // end of [list_cons]
  | list_nil () => i // = size(xs)
// end of [loop]
in
  loop (pfv | 0, xs, f, env)
end // end of [list_iforeach_funenv]

(* ****** ****** *)

implement
{x,y}(*tmp*)
list_iforeach2
  (xs, ys) = let
  var env: void = ()
in
  list_iforeach2_env<x,y><void> (xs, ys, env)
end // end of [list_iforeach2]

implement
{x,y}{env}
list_iforeach2_env
  (xs, ys, env) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_param (ys)
//
fun loop
  {m,n:nat}{i:nat} .<m>.
(
  i: int i, xs: list (x, m), ys: list (y, n), env: &env
) : intBtwe(i, min(m,n)+i) = let
in
//
case+ xs of
| list_cons (x, xs) => (
  case+ ys of
  | list_cons (y, ys) => let
      val test =
        list_iforeach2$cont<x,y><env> (i, x, y, env)
      // end of [val]
    in
      if test then let
        val () = list_iforeach2$fwork<x,y><env> (i, x, y, env)
      in
        loop (succ(i), xs, ys, env)
      end else (i) // end of [if]
    end // end of [list_cons]
  | list_nil () => i // the number of processed elements
  ) // end of [list_cons]
| list_nil () => i // the number of processed elements
//
end // end of [loop]
//
in
  loop (0, xs, ys, env)
end // end of [list_iforeach2_env]

(* ****** ****** *)

implement
{x,y}{env}
list_iforeach2$cont (i, x, y, env) = true

(* ****** ****** *)

implement
{res}{x}
list_foldleft (xs, ini) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>.
(
  xs: list (x, n), acc: res
) : res =
  case+ xs of
  | list_nil () => acc
  | list_cons (x, xs) => let
      val acc =
        list_foldleft$fopr<res><x> (acc, x)
      // end of [val]
    in
      loop (xs, acc)
    end // end of [list_cons]
// end of [loop]
//
in
  loop (xs, ini)
end // end of [list_foldleft]

(* ****** ****** *)

implement
{x}{res}
list_foldright (xs, snk) = let
//
prval () = lemma_list_param (xs)
//
fun aux
  {n:nat} .<n>.
(
  xs: list (x, n), acc: res
) : res =
  case+ xs of
  | list_nil () => acc
  | list_cons (x, xs) =>
      list_foldright$fopr<x><res> (x, aux (xs, acc))
    // end of [list_cons]
// end of [aux]
//
in
  aux (xs, snk)
end // end of [list_foldright]

(* ****** ****** *)

implement
{a}(*tmp*)
list_mergesort$cmp
  (x1, x2) = gcompare_val_val<a> (x1, x2)
// end of [list_mergesort$cmp]

implement
{a}(*tmp*)
list_mergesort
  (xs) = let
//
val xs = list_copy<a> (xs)
//
implement
list_vt_mergesort$cmp<a>
  (x1, x2) = list_mergesort$cmp<a> (x1, x2)
//
in
  list_vt_mergesort<a> (xs)
end // end of [list_mergesort]

(* ****** ****** *)

implement
{a}(*tmp*)
list_mergesort_fun
  (xs, cmp) = let
//
implement
{a2}(*tmp*)
list_mergesort$cmp
  (x1, x2) = let
//
typedef cmp2 = cmpval(a2)
//
val cmp2 = $UN.cast{cmp2}(cmp) in cmp2 (x1, x2)
//
end // end of [list_mergesort$cmp]
//
in
  list_mergesort<a> (xs)
end // end of [list_mergesort_fun]

implement
{a}(*tmp*)
list_mergesort_cloref
  (xs, cmp) = let
//
implement
{a2}(*tmp*)
list_mergesort$cmp
  (x1, x2) = let
//
typedef cmp2 = (a2, a2) -<cloref> int
//
val cmp2 = $UN.cast{cmp2}(cmp) in cmp2 (x1, x2)
//
end // end of [list_mergesort$cmp]
//
in
  list_mergesort<a> (xs)
end // end of [list_mergesort_cloref]

(* ****** ****** *)

implement
{a}(*tmp*)
list_quicksort$cmp
  (x1, x2) = gcompare_val_val<a> (x1, x2)
// end of [list_quicksort$cmp]

implement
{a}(*tmp*)
list_quicksort
  (xs) = let
//
val xs = list_copy<a> (xs)
//
implement
list_vt_quicksort$cmp<a>
  (x1, x2) = list_quicksort$cmp<a> (x1, x2)
//
in
  list_vt_quicksort<a> (xs)
end // end of [list_quicksort]

(* ****** ****** *)

implement
{a}(*tmp*)
list_quicksort_fun
  (xs, cmp) = let
//
implement
{a2}(*tmp*)
list_quicksort$cmp
  (x1, x2) = let
//
val cmp = $UN.cast{cmpval(a2)}(cmp) in cmp (x1, x2)
//
end // end of [list_quicksort$cmp]
//
in
  list_quicksort<a> (xs)
end // end of [list_quicksort_fun]

(* ****** ****** *)

(* end of [list.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/strptr.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload _(*anon*) = "prelude/DATS/integer.dats"

(* ****** ****** *)

#define CNUL '\000'
#define nullp the_null_ptr

(* ****** ****** *)

overload + with add_ptr_bsz

(* ****** ****** *)

implement{}
strptr_is_null (str) = (strptr2ptr (str) = nullp)
implement{}
strptr_isnot_null (str) = (strptr2ptr (str) > nullp)

(* ****** ****** *)

implement{}
strptr_is_empty (str) = let
  val p = strptr2ptr (str) in $UN.ptr1_get<char>(p) = CNUL
end // end of [strptr_is_empty]
implement{}
strptr_isnot_empty (str) = let
  val p = strptr2ptr (str) in $UN.ptr1_get<char>(p) != CNUL
end // end of [strptr_isnot_empty]

(* ****** ****** *)

implement{}
strnptr_get_at_size (str, i) =
  $UN.ptr0_get<charNZ>(strnptr2ptr(str) + i)
// end of [strnptr_get_at_size]

implement{tk}
strnptr_get_at_gint (str, i) =
  strnptr_get_at_size (str, g1int2uint (i))
// end of [strnptr_get_at_gint]
implement{tk}
strnptr_get_at_guint (str, i) =
  strnptr_get_at_size (str, g1uint2uint (i))
// end of [strnptr_get_at_guint]

(* ****** ****** *)

implement{}
strnptr_set_at_size (str, i, c) =
  $UN.ptr0_set<charNZ>(strnptr2ptr(str) + i, c)
// end of [strnptr_set_at_size]

implement{tk}
strnptr_set_at_gint (str, i, c) =
  strnptr_set_at_size (str, g1int2uint (i), c)
// end of [strnptr_set_at_gint]
implement{tk}
strnptr_set_at_guint (str, i, c) =
  strnptr_set_at_size (str, g1uint2uint (i), c)
// end of [strnptr_set_at_guint]

(* ****** ****** *)

implement
lt_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) < 0)
implement
lte_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) <= 0)
implement
gt_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) > 0)
implement
gte_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) >= 0)
implement
eq_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) = 0)
implement
neq_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) != 0)

(* ****** ****** *)

(*
//
// HX: implemented in [strptr.cats]
//
implement
print_strptr (x) = fprint_strptr (stdout_ref, x)
implement
prerr_strptr (x) = fprint_strptr (stderr_ref, x)
*)

(* ****** ****** *)

implement{}
strnptr_is_null (str) = (strnptr2ptr (str) = nullp)
implement{}
strnptr_isnot_null (str) = (strnptr2ptr (str) > nullp)

(* ****** ****** *)

implement{}
strptr_length(x) = let
  val isnot = ptr_isnot_null(strptr2ptr(x))
in
//
if isnot
  then g0u2i(string_length($UN.strptr2string(x)))
  else g0i2i(~1)
//
end // end of [strptr_length]

implement{}
strnptr_length(x) = let
  prval () = lemma_strnptr_param (x)
  val isnot = ptr_isnot_null(strnptr2ptr(x))
in
//
if isnot
  then g1u2i(string_length($UN.strnptr2string(x)))
  else g1i2i(~1)
//
end // end of [strnptr_length]

(* ****** ****** *)

implement{}
strptr0_copy(x) = let
  val isnot = ptr_isnot_null(strptr2ptr(x))
in
//
if isnot
  then string0_copy($UN.strptr2string(x)) else strptr_null()
//
end // end of [strptr0_copy]

implement{}
strptr1_copy(x) = string0_copy($UN.strptr2string(x))

(* ****** ****** *)

implement{}
strnptr_copy
  {n}(x) = x2 where
{
  val x = strnptr2ptr(x)
  val x = $UN.castvwtp0{Strptr0}(x)
  val x2 = $UN.castvwtp0{strnptr(n)}(strptr0_copy(x))
  prval ((*void*)) = $UN.cast2void(x)
} (* end of [strnptr_copy] *)

(* ****** ****** *)

implement{}
strptr_append
  (x1, x2) = let
//
val isnot1 = ptr_isnot_null (strptr2ptr(x1))
//
in
//
if isnot1 then let
//
val isnot2 = ptr_isnot_null (strptr2ptr(x2))
//
in
//
if
isnot2
then
  strnptr2strptr(string1_append ($UN.strptr2string(x1), $UN.strptr2string(x2)))
else
  strptr1_copy (x1)
// end of [if]
//
end else
  strptr0_copy (x2)
// end of [if]
//
end // end of [strptr_append]

(* ****** ****** *)

implement{}
strptrlst_free (xs) = let
//
fun loop
  (xs: List_vt(Strptr0)): void = let
in
//
case+ xs of
| ~list_vt_cons
    (x, xs) => (strptr_free (x); loop (xs))
| ~list_vt_nil () => ()
//
end // end of [loop]
//
in
  $effmask_all (loop (xs))
end // end of [strptrlst_free]

(* ****** ****** *)

implement{}
strptrlst_concat (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n0:nat} .<n0>.
(
  xs: &list_vt(Strptr0, n0)>>list_vt(Strptr1, n1)
) :<!wrt> #[n1:nat | n1 <= n0] void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val isnot = strptr_isnot_null (x)
  in
    if isnot then let
      val () = loop (xs1)
      prval () = fold@ (xs)
    in
      // nothing
    end else let
      prval () =
        strptr_free_null (x)
      val xs1 = xs1
      val () = free@{..}{0}(xs)
      val ((*void*)) = (xs := xs1)
    in
      loop (xs)
    end // end of [if]
  end // end of [list_vt_cons]
| @list_vt_nil () => fold@ (xs)
//
end // end of [loop]
//
var xs = xs
val () = loop (xs)
//
in
//
case+ xs of
| ~list_vt_nil () => strptr_null ()
| ~list_vt_cons (x, ~list_vt_nil ()) => x
| _ => let
    val res =
      stringlst_concat ($UN.castvwtp1{List(string)}(xs))
    val () =
    loop (xs) where {
      fun loop {n:nat} .<n>.
        (xs: list_vt (Strptr1, n)):<!wrt> void =
        case+ xs of
        | ~list_vt_cons (x, xs) => (strptr_free (x); loop (xs))
        | ~list_vt_nil ((*void*)) => ()
      // end of [loop]
    } // end of [where] // end of [val]
  in
    res
  end // end of [_]
//
end // end of [strptrlst_concat]

(* ****** ****** *)

implement
{env}(*tmp*)
strnptr_foreach$cont (c, env) = true

(* ****** ****** *)

implement
{}(*tmp*)
strnptr_foreach (str) = let
  var env: void = () in strnptr_foreach_env<void> (str, env)
end // end of [strnptr_foreach]

(* ****** ****** *)

implement
{env}(*tmp*)
strnptr_foreach_env
  {n} (str, env) = let
//
fun loop
(
  p: ptr, env: &env >> _
) : ptr = let
//
#define NUL '\000'
//
val c = $UN.ptr0_get<Char> (p)
//
in
//
if
(c != NUL)
then let
  val (pf, fpf | p) =
    $UN.ptr0_vtake{charNZ}(p)
  val cont =
    strnptr_foreach$cont<env> (!p, env)
  // end of [val]
in
  if cont
    then let
      val () =
      strnptr_foreach$fwork<env> (!p, env)
      prval ((*void*)) = fpf (pf)
    in
      loop (ptr_succ<char> (p), env)
    end // end of [then]
    else let
      prval ((*void*)) = fpf (pf) in (p)
    end // end of [else]    
end // end of [then]
else (p) // end of [else]
//
end // end of [loop]
//
val p0 = ptrcast(str)
//
in
  $UN.cast{sizeLte(n)}(loop (p0, env) - p0)
end // end of [strnptr_foreach_env]

(* ****** ****** *)

implement
{env}(*tmp*)
strnptr_rforeach$cont (c, env) = true

(* ****** ****** *)

implement
{}(*tmp*)
strnptr_rforeach (str) = let
  var env: void = () in strnptr_rforeach_env<void> (str, env)
end // end of [strnptr_rforeach]

(* ****** ****** *)

implement
{env}(*tmp*)
strnptr_rforeach_env
  {n} (str, env) = let
//
fun loop
(
  p0: ptr, p1: ptr, env: &env >> _
) : ptr = let
in
//
if
(p1 > p0)
then let
  val p2 = ptr_pred<char> (p1)
  val (pf, fpf | p2) =
    $UN.ptr0_vtake{charNZ}(p2)
  val cont =
    strnptr_rforeach$cont<env> (!p2, env)
  // end of [val]
in
  if cont
    then let
      val () =
      strnptr_rforeach$fwork<env> (!p2, env)
      prval ((*void*)) = fpf (pf)
    in
      loop (p0, p2, env)
    end // end of [then]
    else let
      prval ((*void*)) = fpf (pf) in (p1)
    end // end of [else]    
end // end of [then]
else (p1) // end of [else]
//
end // end of [loop]
//
val p0 = ptrcast(str)
val p1 = ptr_add<char> (p0, length(str))
//
in
  $UN.cast{sizeLte(n)}(p1 - loop (p0, p1, env))
end // end of [strnptr_rforeach_env]

(* ****** ****** *)

(* end of [strptr.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/basics.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2012 *)

(* ****** ****** *)
//
staload
UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)
//
primplmnt
false_elim() = case+ 0 of _ =/=> ()
//
(* ****** ****** *)

primplmnt prop_verify () = ()
primplmnt prop_verify_and_add () = ()

(* ****** ****** *)

primplmnt pridentity_v (x) = ()
primplmnt pridentity_vt (x) = ()

(* ****** ****** *)

primplmnt eqint_make () = EQINT ()
primplmnt eqint_make_gint (x) = EQINT ()
primplmnt eqint_make_guint (x) = EQINT ()

(* ****** ****** *)

primplmnt eqaddr_make () = EQADDR ()
primplmnt eqaddr_make_ptr (x) = EQADDR ()

(* ****** ****** *)

primplmnt eqbool_make () = EQBOOL ()
primplmnt eqbool_make_bool (x) = EQBOOL ()

(* ****** ****** *)

implement
{a}(*tmp*)
lazy_force (lazyval) = !lazyval
implement
{a}(*tmp*)
lazy_vt_force (lazyval) = !lazyval

(* ****** ****** *)
//
implement
{a}(*tmp*)
stamped_vt2t_ref{x}(x) =
  $UN.ptr0_get<stamped_t(a,x)>(addr@x)
//
(* ****** ****** *)

primplmnt
unit_v_elim (pf) = let
  prval unit_v () = pf in (*nothing*)
end // end of [unit_v_elim]

(* ****** ****** *)
//
implement{a} box(x) = $UN.cast(x)
implement{a} unbox(x) = $UN.cast(x)
//
implement{a} box_vt(x) = $UN.castvwtp0(x)
implement{a} unbox_vt(x) = $UN.castvwtp0(x)
//
(* ****** ****** *)
//
// HX:
// See prelude/basics_dyn.sats
//
implement
{a}(*tmp*)
opt_unsome_get (x) =
  let prval () = opt_unsome (x) in x end
//
(* ****** ****** *)

(*
//
// HX: [atspre_argv_at_at] in basics.cats
//
implement
argv_get_at
  (argv, i) = x where {
  val (pf, fpf | p) =
    argv_takeout_strarr (argv)
  val x = !p.[i]
  prval () = minus_addback (fpf, pf | argv)
} // end of [argv_get_at]
*)

(* ****** ****** *)

implement{}
assertexn_bool0 (b) = if not(b) then $raise AssertExn()
implement{}
assertexn_bool1 (b) = if not(b) then $raise AssertExn()

(* ****** ****** *)

implement{a} gidentity (x) = x
implement{a} gidentity_vt (x) = x

(* ****** ****** *)

implement
{a}(*tmp*)
gcopy_val (x) = (x)
implement
(a:t@ype)
gcopy_ref<a> (x) = (x)

(* ****** ****** *)
//
implement
gequal_val_val<int> (x, y) = (x = y)
implement
gequal_val_val<bool> (x, y) = (x = y)
implement
gequal_val_val<char> (x, y) = (x = y)
implement
gequal_val_val<double> (x, y) = (x = y)
implement
gequal_val_val<string> (x, y) = (x = y)
//
(* ****** ****** *)
//
implement
(a:t@ype)
gequal_ref_ref<a>
  (x, y) = gequal_val_val<a> (x, y)
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
tostring_val(x) = let
//
val str =
  $effmask_wrt(tostrptr_val<a>(x))
in
  strptr2string(str)
end // end of [tostring_val]
//
implement
{a}(*tmp*)
tostring_ref(x) = let
//
val str =
  $effmask_wrt(tostrptr_ref<a>(x))
in
  strptr2string(str)
end // end of [tostring_ref]
//
(* ****** ****** *)

implement
(a:t@ype)
tostrptr_ref<a> (x) = tostrptr_val<a> (x)

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_val (out, x) = let
  val str = tostrptr_val<a> (x)
  val ((*void*)) = fprint_strptr (out, str)
  val ((*void*)) = strptr_free (str)
in
  // nothing
end // end of [fprint_val]

(* ****** ****** *)

implement
(a:t@ype)
fprint_ref<a> (out, x) = fprint_val<a> (out, x)

(* ****** ****** *)

(*
//
// HX-2014-02-25: commented out
//
implement{a}
print_val (x) = fprint_val<a> (stdout_ref, x)
implement{a}
prerr_val (x) = fprint_val<a> (stderr_ref, x)
implement{a}
print_ref (x) = fprint_ref<a> (stdout_ref, x)
implement{a}
prerr_ref (x) = fprint_ref<a> (stderr_ref, x)
*)

(* ****** ****** *)

(* end of [basics.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/arrayptr.atxt
** Time of generation: Sat Oct 17 15:19:57 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_make_elt
  (asz, elt) = let
//
val
(
  pf, pfgc | p
) = array_ptr_alloc<a> (asz)
//
val () = array_initize_elt<a> (!p, asz, elt)
//
in
  arrayptr_encode(pf, pfgc | p)
end // end of [arrayptr_make_elt]

(* ****** ****** *)

implement
{}(*tmp*)
arrayptr_make_intrange
  {l,r} (l, r) = let
//
val asz = g1int2uint (r-l)
val [A:addr] A =
  arrayptr_make_uninitized<int> (asz)
//
fun loop
  {n:nat} .<n>. (
  p: ptr, asz: size_t n, l: int
) :<!wrt> void = let
in
//
if asz > 0 then let
  val () = $UN.ptr0_set<int> (p, l)
in
  loop (ptr0_succ<int> (p), pred (asz), l+1)
end else () // end of [if]
//
end // end of [loop]
//
val () = loop (ptrcast (A), asz, l)
//
in
  $UN.castvwtp0{arrayptr(intBtw(l,r),A,r-l)}(A)
end // end of [arrayptr_make_intrange]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_make_list
  (asz, xs) = let
//
prval () = lemma_list_param (xs)
//
val (
  pf, pfgc | p
) = array_ptr_alloc<a> (i2sz(asz))
//
val () = array_initize_list<a> (!p, asz, xs)
//
in
  arrayptr_encode(pf, pfgc | p)
end // end of [arrayptr_make_list]

implement
{a}(*tmp*)
arrayptr_make_rlist
  (asz, xs) = let
//
prval () = lemma_list_param (xs)
//
val (
  pf, pfgc | p
) = array_ptr_alloc<a> (i2sz(asz))
//
val () = array_initize_rlist<a> (!p, asz, xs)
//
in
  arrayptr_encode(pf, pfgc | p)
end // end of [arrayptr_make_rlist]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_make_subarray
  {n}{st,ln}(A, st, ln) = let
//
val p1 =
ptr_add<a> ($UN.cast2ptr(A), st)
val (
  pf1, fpf | p1
) = $UN.ptr_vtake{array(a,ln)}(p1)
//
val A2 =
arrayptr_make_uninitized<a> (ln)
val p2 = ptrcast (A2)
prval pf2 = arrayptr_takeout (A2)
//
val () = array_copy<a> (!p2, !p1, ln)
//
prval () = fpf (pf1)
prval () = arrayptr_addback (pf2 | A2)
//
in
  A2
end // end of [arrayptr_make_subarray]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_make_list_vt
  (asz, xs) = let
//
prval () = lemma_list_vt_param (xs)
//
val (
 pf, pfgc | p
) = array_ptr_alloc<a> (i2sz(asz))
val () = array_initize_list_vt<a> (!p, asz, xs)
//
in
  arrayptr_encode(pf, pfgc | p)
end // end of [arrayptr_make_list_vt]

implement
{a}(*tmp*)
arrayptr_make_rlist_vt
  (asz, xs) = let
//
prval () = lemma_list_vt_param (xs)
//
val (
 pf, pfgc | p
) = array_ptr_alloc<a> (i2sz(asz))
val () = array_initize_rlist_vt<a> (!p, asz, xs)
//
in
  arrayptr_encode(pf, pfgc | p)
end // end of [arrayptr_make_rlist_vt]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_make_uninitized
  (asz) = let
in
  arrayptr_encode2(array_ptr_alloc<a> (asz))
end // end of [arrayptr_uninitize]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_imake_list
  (A, asz) = res where
{
//
val p = ptrcast(A)
prval pf = arrayptr_takeout (A)
val res = list_make_array (!p, asz)
prval () = arrayptr_addback (pf | A)
} // end of [arrayptr_imake_list]

(* ****** ****** *)

(*
implement
arrayptr_free = ATS_MFREE // HX: in arrayptr.cats
*)

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_arrayptr
  (out, A, n) = () where
{
//
val p = ptrcast(A)
prval pf = arrayptr_takeout (A)
val () = fprint_array<a> (out, !p, n)
prval () = arrayptr_addback (pf | A)
//
} // end of [fprint_arrayptr]

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_arrayptr_sep
  (out, A, n, sep) = () where
{
//
val p = ptrcast (A)
prval pf = arrayptr_takeout (A)
val () = fprint_array_sep<a> (out, !p, n, sep)
prval () = arrayptr_addback (pf | A)
//
} // end of [fprint_arrayptr_sep]

(* ****** ****** *)

implement
{a}{tk}
arrayptr_get_at_gint
  (A, i) = let
  val p = ptrcast (A) in
  $UN.ptr0_get<a> (ptr1_add_gint<a><tk> (p, i))
end // end of [arrayptr_get_at_gint]

implement
{a}{tk}
arrayptr_get_at_guint
  (A, i) = let
  val p = ptrcast (A) in
  $UN.ptr0_get<a> (ptr1_add_guint<a><tk> (p, i))
end // end of [arrayptr_get_at_guint]

(* ****** ****** *)

implement
{a}{tk}
arrayptr_set_at_gint
  (A, i, x) = let
  val p = ptrcast (A) in
  $UN.ptr0_set<a> (ptr1_add_gint<a><tk> (p, i), x)
end // end of [arrayptr_set_at_gint]

implement
{a}{tk}
arrayptr_set_at_guint
  (A, i, x) = let
  val p = ptrcast (A) in
  $UN.ptr0_set<a> (ptr1_add_guint<a><tk> (p, i), x)
end // end of [arrayptr_set_at_guint]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_interchange
  (A, i, j) = let
//
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val () = array_interchange (!p, i, j)
  prval () = arrayptr_addback (pfarr | A)
//
in
  // noting
end // end of [arrayptr_interchange]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_foreach
  (A, asz) = let
  var env: void = () in
  arrayptr_foreach_env<a><void> (A, asz, env)
end // end of [arrayptr_foreach]

implement
{a}{env}
arrayptr_foreach_env
  (A, asz, env) = res where {
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val res = array_foreach_env<a><env> (!p, asz, env)
  prval () = arrayptr_addback (pfarr | A)
} // end of [arrayptr_foreach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_foreach_fun
  (A, asz, f) = let
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val () = array_foreach_fun<a> (!p, asz, f)
  prval () = arrayptr_addback (pfarr | A)
in
  // nothing
end // end of [arrayptr_foreach_fun]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_foreach_funenv
  (pfv | A, asz, f, env) = let
//
val p = ptrcast (A)
prval pfarr = arrayptr_takeout (A)
val () =
  array_foreach_funenv<a> (pfv | !p, asz, f, env)
prval () = arrayptr_addback (pfarr | A)
//
in
  // nothing
end // end of [arrayptr_foreach_funenv]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_iforeach
  (A, asz) = let
  var env: void = () in
  arrayptr_iforeach_env<a><void> (A, asz, env)
end // end of [arrayptr_iforeach]

implement
{a}{env}
arrayptr_iforeach_env
  (A, asz, env) = res where {
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val res = array_iforeach_env<a><env> (!p, asz, env)
  prval () = arrayptr_addback (pfarr | A)
} // end of [arrayptr_iforeach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_rforeach
  (A, asz) = let
  var env: void = () in
  arrayptr_rforeach_env<a><void> (A, asz, env)
end // end of [arrayptr_rforeach]

implement
{a}{env}
arrayptr_rforeach_env
  (A, asz, env) = res where {
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val res = array_rforeach_env<a><env> (!p, asz, env)
  prval () = arrayptr_addback (pfarr | A)
} // end of [arrayptr_rforeach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_initize
  (A, asz) = () where {
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val () = array_initize<a> (!p, asz)
  prval () = arrayptr_addback (pfarr | A)
} // end of [arrayptr_initize]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_uninitize
  (A, asz) = () where {
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val () = array_uninitize<a> (!p, asz)
  prval () = arrayptr_addback (pfarr | A)
} // end of [arrayptr_uninitize]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_freelin
  (A, asz) = let
//
val () = arrayptr_uninitize<a> (A, asz)
//
in
  arrayptr_free{a?}(A)
end // end of [arrayptr_freelin]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_tabulate
  (asz) = arrayptr_encode2(array_ptr_tabulate<a> (asz))
// end of [arrayptr_tabulate]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_tabulate_cloref
  {n} (asz, f) = let
//
implement(a2)
array_tabulate$fopr<a2> (i) = $UN.castvwtp0{a2}(f($UN.cast{sizeLt(n)}(i)))
//
in
  arrayptr_tabulate<a> (asz)
end // end of [arrayptr_tabulate_cloref]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_quicksort
  (A, asz) = () where
{
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val () = array_quicksort<a> (!p, asz)
  prval () = arrayptr_addback (pfarr | A)
} (* end of [arrayptr_quicksort] *)

(* ****** ****** *)

(* end of [arrayptr.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/integer_fixed.atxt
** Time of generation: Sat Oct 17 15:19:53 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: February, 2014 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)
//
//
(* ****** ****** *)
//
staload UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)

implement
g0int2int<int8knd,intknd> = g0int2int_int8_int
implement
g0int2int<int16knd,intknd> = g0int2int_int16_int
implement
g0int2int<int32knd,intknd> = g0int2int_int32_int
implement
g0int2int<int64knd,intknd> = g0int2int_int64_int

(* ****** ****** *)

implement g0int_neg<int8knd> = g0int_neg_int8
implement g0int_abs<int8knd> = g0int_abs_int8
implement g0int_succ<int8knd> = g0int_succ_int8
implement g0int_pred<int8knd> = g0int_pred_int8
implement g0int_half<int8knd> = g0int_half_int8
implement g0int_add<int8knd> = g0int_add_int8
implement g0int_sub<int8knd> = g0int_sub_int8
implement g0int_mul<int8knd> = g0int_mul_int8
implement g0int_div<int8knd> = g0int_div_int8
implement g0int_mod<int8knd> = g0int_mod_int8
implement g0int_asl<int8knd> = g0int_asl_int8
implement g0int_asr<int8knd> = g0int_asr_int8
implement g0int_isltz<int8knd> = g0int_isltz_int8
implement g0int_isltez<int8knd> = g0int_isltez_int8
implement g0int_isgtz<int8knd> = g0int_isgtz_int8
implement g0int_isgtez<int8knd> = g0int_isgtez_int8
implement g0int_iseqz<int8knd> = g0int_iseqz_int8
implement g0int_isneqz<int8knd> = g0int_isneqz_int8
implement g0int_lt<int8knd> = g0int_lt_int8
implement g0int_lte<int8knd> = g0int_lte_int8
implement g0int_gt<int8knd> = g0int_gt_int8
implement g0int_gte<int8knd> = g0int_gte_int8
implement g0int_eq<int8knd> = g0int_eq_int8
implement g0int_neq<int8knd> = g0int_neq_int8
implement g0int_compare<int8knd> = g0int_compare_int8
implement g0int_max<int8knd> = g0int_max_int8
implement g0int_min<int8knd> = g0int_min_int8
//
implement fprint_val<int8> (out, x) = fprint_int8 (out, x)
//
implement g0int_neg<int16knd> = g0int_neg_int16
implement g0int_abs<int16knd> = g0int_abs_int16
implement g0int_succ<int16knd> = g0int_succ_int16
implement g0int_pred<int16knd> = g0int_pred_int16
implement g0int_half<int16knd> = g0int_half_int16
implement g0int_add<int16knd> = g0int_add_int16
implement g0int_sub<int16knd> = g0int_sub_int16
implement g0int_mul<int16knd> = g0int_mul_int16
implement g0int_div<int16knd> = g0int_div_int16
implement g0int_mod<int16knd> = g0int_mod_int16
implement g0int_asl<int16knd> = g0int_asl_int16
implement g0int_asr<int16knd> = g0int_asr_int16
implement g0int_isltz<int16knd> = g0int_isltz_int16
implement g0int_isltez<int16knd> = g0int_isltez_int16
implement g0int_isgtz<int16knd> = g0int_isgtz_int16
implement g0int_isgtez<int16knd> = g0int_isgtez_int16
implement g0int_iseqz<int16knd> = g0int_iseqz_int16
implement g0int_isneqz<int16knd> = g0int_isneqz_int16
implement g0int_lt<int16knd> = g0int_lt_int16
implement g0int_lte<int16knd> = g0int_lte_int16
implement g0int_gt<int16knd> = g0int_gt_int16
implement g0int_gte<int16knd> = g0int_gte_int16
implement g0int_eq<int16knd> = g0int_eq_int16
implement g0int_neq<int16knd> = g0int_neq_int16
implement g0int_compare<int16knd> = g0int_compare_int16
implement g0int_max<int16knd> = g0int_max_int16
implement g0int_min<int16knd> = g0int_min_int16
//
implement fprint_val<int16> (out, x) = fprint_int16 (out, x)
//
implement g0int_neg<int32knd> = g0int_neg_int32
implement g0int_abs<int32knd> = g0int_abs_int32
implement g0int_succ<int32knd> = g0int_succ_int32
implement g0int_pred<int32knd> = g0int_pred_int32
implement g0int_half<int32knd> = g0int_half_int32
implement g0int_add<int32knd> = g0int_add_int32
implement g0int_sub<int32knd> = g0int_sub_int32
implement g0int_mul<int32knd> = g0int_mul_int32
implement g0int_div<int32knd> = g0int_div_int32
implement g0int_mod<int32knd> = g0int_mod_int32
implement g0int_asl<int32knd> = g0int_asl_int32
implement g0int_asr<int32knd> = g0int_asr_int32
implement g0int_isltz<int32knd> = g0int_isltz_int32
implement g0int_isltez<int32knd> = g0int_isltez_int32
implement g0int_isgtz<int32knd> = g0int_isgtz_int32
implement g0int_isgtez<int32knd> = g0int_isgtez_int32
implement g0int_iseqz<int32knd> = g0int_iseqz_int32
implement g0int_isneqz<int32knd> = g0int_isneqz_int32
implement g0int_lt<int32knd> = g0int_lt_int32
implement g0int_lte<int32knd> = g0int_lte_int32
implement g0int_gt<int32knd> = g0int_gt_int32
implement g0int_gte<int32knd> = g0int_gte_int32
implement g0int_eq<int32knd> = g0int_eq_int32
implement g0int_neq<int32knd> = g0int_neq_int32
implement g0int_compare<int32knd> = g0int_compare_int32
implement g0int_max<int32knd> = g0int_max_int32
implement g0int_min<int32knd> = g0int_min_int32
//
implement fprint_val<int32> (out, x) = fprint_int32 (out, x)
//
implement g0int_neg<int64knd> = g0int_neg_int64
implement g0int_abs<int64knd> = g0int_abs_int64
implement g0int_succ<int64knd> = g0int_succ_int64
implement g0int_pred<int64knd> = g0int_pred_int64
implement g0int_half<int64knd> = g0int_half_int64
implement g0int_add<int64knd> = g0int_add_int64
implement g0int_sub<int64knd> = g0int_sub_int64
implement g0int_mul<int64knd> = g0int_mul_int64
implement g0int_div<int64knd> = g0int_div_int64
implement g0int_mod<int64knd> = g0int_mod_int64
implement g0int_asl<int64knd> = g0int_asl_int64
implement g0int_asr<int64knd> = g0int_asr_int64
implement g0int_isltz<int64knd> = g0int_isltz_int64
implement g0int_isltez<int64knd> = g0int_isltez_int64
implement g0int_isgtz<int64knd> = g0int_isgtz_int64
implement g0int_isgtez<int64knd> = g0int_isgtez_int64
implement g0int_iseqz<int64knd> = g0int_iseqz_int64
implement g0int_isneqz<int64knd> = g0int_isneqz_int64
implement g0int_lt<int64knd> = g0int_lt_int64
implement g0int_lte<int64knd> = g0int_lte_int64
implement g0int_gt<int64knd> = g0int_gt_int64
implement g0int_gte<int64knd> = g0int_gte_int64
implement g0int_eq<int64knd> = g0int_eq_int64
implement g0int_neq<int64knd> = g0int_neq_int64
implement g0int_compare<int64knd> = g0int_compare_int64
implement g0int_max<int64knd> = g0int_max_int64
implement g0int_min<int64knd> = g0int_min_int64
//
implement fprint_val<int64> (out, x) = fprint_int64 (out, x)
//
(* ****** ****** *)
//
implement
g0int2uint<int8knd,uintknd> = g0int2uint_int8_uint
implement
g0int2uint<int16knd,uintknd> = g0int2uint_int16_uint
implement
g0int2uint<int32knd,uintknd> = g0int2uint_int32_uint
implement
g0int2uint<int64knd,uintknd> = g0int2uint_int64_uint
//
implement
g0uint2int<uint8knd,intknd> = g0uint2int_uint8_int
implement
g0uint2int<uint16knd,intknd> = g0uint2int_uint16_int
implement
g0uint2int<uint32knd,intknd> = g0uint2int_uint32_int
implement
g0uint2int<uint64knd,intknd> = g0uint2int_uint64_int
//
implement
g0uint2uint<uint8knd,uintknd> = g0uint2uint_uint8_uint
implement
g0uint2uint<uint16knd,uintknd> = g0uint2uint_uint16_uint
implement
g0uint2uint<uint32knd,uintknd> = g0uint2uint_uint32_uint
implement
g0uint2uint<uint64knd,uintknd> = g0uint2uint_uint64_uint
//
(* ****** ****** *)

implement g0uint_succ<uint8knd> = g0uint_succ_uint8
implement g0uint_pred<uint8knd> = g0uint_pred_uint8
implement g0uint_half<uint8knd> = g0uint_half_uint8
implement g0uint_add<uint8knd> = g0uint_add_uint8
implement g0uint_sub<uint8knd> = g0uint_sub_uint8
implement g0uint_mul<uint8knd> = g0uint_mul_uint8
implement g0uint_div<uint8knd> = g0uint_div_uint8
implement g0uint_mod<uint8knd> = g0uint_mod_uint8
implement g0uint_lsl<uint8knd> = g0uint_lsl_uint8
implement g0uint_lsr<uint8knd> = g0uint_lsr_uint8
implement g0uint_lnot<uint8knd> = g0uint_lnot_uint8
implement g0uint_lor<uint8knd> = g0uint_lor_uint8
implement g0uint_lxor<uint8knd> = g0uint_lxor_uint8
implement g0uint_land<uint8knd> = g0uint_land_uint8
implement g0uint_isgtz<uint8knd> = g0uint_isgtz_uint8
implement g0uint_iseqz<uint8knd> = g0uint_iseqz_uint8
implement g0uint_isneqz<uint8knd> = g0uint_isneqz_uint8
implement g0uint_lt<uint8knd> = g0uint_lt_uint8
implement g0uint_lte<uint8knd> = g0uint_lte_uint8
implement g0uint_gt<uint8knd> = g0uint_gt_uint8
implement g0uint_gte<uint8knd> = g0uint_gte_uint8
implement g0uint_eq<uint8knd> = g0uint_eq_uint8
implement g0uint_neq<uint8knd> = g0uint_neq_uint8
implement g0uint_compare<uint8knd> = g0uint_compare_uint8
implement g0uint_max<uint8knd> = g0uint_max_uint8
implement g0uint_min<uint8knd> = g0uint_min_uint8
//
implement fprint_val<uint8> (out, x) = fprint_uint8 (out, x)
//
implement g0uint_succ<uint16knd> = g0uint_succ_uint16
implement g0uint_pred<uint16knd> = g0uint_pred_uint16
implement g0uint_half<uint16knd> = g0uint_half_uint16
implement g0uint_add<uint16knd> = g0uint_add_uint16
implement g0uint_sub<uint16knd> = g0uint_sub_uint16
implement g0uint_mul<uint16knd> = g0uint_mul_uint16
implement g0uint_div<uint16knd> = g0uint_div_uint16
implement g0uint_mod<uint16knd> = g0uint_mod_uint16
implement g0uint_lsl<uint16knd> = g0uint_lsl_uint16
implement g0uint_lsr<uint16knd> = g0uint_lsr_uint16
implement g0uint_lnot<uint16knd> = g0uint_lnot_uint16
implement g0uint_lor<uint16knd> = g0uint_lor_uint16
implement g0uint_lxor<uint16knd> = g0uint_lxor_uint16
implement g0uint_land<uint16knd> = g0uint_land_uint16
implement g0uint_isgtz<uint16knd> = g0uint_isgtz_uint16
implement g0uint_iseqz<uint16knd> = g0uint_iseqz_uint16
implement g0uint_isneqz<uint16knd> = g0uint_isneqz_uint16
implement g0uint_lt<uint16knd> = g0uint_lt_uint16
implement g0uint_lte<uint16knd> = g0uint_lte_uint16
implement g0uint_gt<uint16knd> = g0uint_gt_uint16
implement g0uint_gte<uint16knd> = g0uint_gte_uint16
implement g0uint_eq<uint16knd> = g0uint_eq_uint16
implement g0uint_neq<uint16knd> = g0uint_neq_uint16
implement g0uint_compare<uint16knd> = g0uint_compare_uint16
implement g0uint_max<uint16knd> = g0uint_max_uint16
implement g0uint_min<uint16knd> = g0uint_min_uint16
//
implement fprint_val<uint16> (out, x) = fprint_uint16 (out, x)
//
implement g0uint_succ<uint32knd> = g0uint_succ_uint32
implement g0uint_pred<uint32knd> = g0uint_pred_uint32
implement g0uint_half<uint32knd> = g0uint_half_uint32
implement g0uint_add<uint32knd> = g0uint_add_uint32
implement g0uint_sub<uint32knd> = g0uint_sub_uint32
implement g0uint_mul<uint32knd> = g0uint_mul_uint32
implement g0uint_div<uint32knd> = g0uint_div_uint32
implement g0uint_mod<uint32knd> = g0uint_mod_uint32
implement g0uint_lsl<uint32knd> = g0uint_lsl_uint32
implement g0uint_lsr<uint32knd> = g0uint_lsr_uint32
implement g0uint_lnot<uint32knd> = g0uint_lnot_uint32
implement g0uint_lor<uint32knd> = g0uint_lor_uint32
implement g0uint_lxor<uint32knd> = g0uint_lxor_uint32
implement g0uint_land<uint32knd> = g0uint_land_uint32
implement g0uint_isgtz<uint32knd> = g0uint_isgtz_uint32
implement g0uint_iseqz<uint32knd> = g0uint_iseqz_uint32
implement g0uint_isneqz<uint32knd> = g0uint_isneqz_uint32
implement g0uint_lt<uint32knd> = g0uint_lt_uint32
implement g0uint_lte<uint32knd> = g0uint_lte_uint32
implement g0uint_gt<uint32knd> = g0uint_gt_uint32
implement g0uint_gte<uint32knd> = g0uint_gte_uint32
implement g0uint_eq<uint32knd> = g0uint_eq_uint32
implement g0uint_neq<uint32knd> = g0uint_neq_uint32
implement g0uint_compare<uint32knd> = g0uint_compare_uint32
implement g0uint_max<uint32knd> = g0uint_max_uint32
implement g0uint_min<uint32knd> = g0uint_min_uint32
//
implement fprint_val<uint32> (out, x) = fprint_uint32 (out, x)
//
implement g0uint_succ<uint64knd> = g0uint_succ_uint64
implement g0uint_pred<uint64knd> = g0uint_pred_uint64
implement g0uint_half<uint64knd> = g0uint_half_uint64
implement g0uint_add<uint64knd> = g0uint_add_uint64
implement g0uint_sub<uint64knd> = g0uint_sub_uint64
implement g0uint_mul<uint64knd> = g0uint_mul_uint64
implement g0uint_div<uint64knd> = g0uint_div_uint64
implement g0uint_mod<uint64knd> = g0uint_mod_uint64
implement g0uint_lsl<uint64knd> = g0uint_lsl_uint64
implement g0uint_lsr<uint64knd> = g0uint_lsr_uint64
implement g0uint_lnot<uint64knd> = g0uint_lnot_uint64
implement g0uint_lor<uint64knd> = g0uint_lor_uint64
implement g0uint_lxor<uint64knd> = g0uint_lxor_uint64
implement g0uint_land<uint64knd> = g0uint_land_uint64
implement g0uint_isgtz<uint64knd> = g0uint_isgtz_uint64
implement g0uint_iseqz<uint64knd> = g0uint_iseqz_uint64
implement g0uint_isneqz<uint64knd> = g0uint_isneqz_uint64
implement g0uint_lt<uint64knd> = g0uint_lt_uint64
implement g0uint_lte<uint64knd> = g0uint_lte_uint64
implement g0uint_gt<uint64knd> = g0uint_gt_uint64
implement g0uint_gte<uint64knd> = g0uint_gte_uint64
implement g0uint_eq<uint64knd> = g0uint_eq_uint64
implement g0uint_neq<uint64knd> = g0uint_neq_uint64
implement g0uint_compare<uint64knd> = g0uint_compare_uint64
implement g0uint_max<uint64knd> = g0uint_max_uint64
implement g0uint_min<uint64knd> = g0uint_min_uint64
//
implement fprint_val<uint64> (out, x) = fprint_uint64 (out, x)
//
(* ****** ****** *)

(* end of [integer_fixed.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/intrange.atxt
** Time of generation: Sat Oct 17 15:19:54 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: June, 2012 *)

(* ****** ****** *)

implement{}
intrange_foreach
  (l, r) = let
  var env: void = ()
in
  intrange_foreach_env<void> (l, r, env)
end // end of [intrange_foreach]

implement{tenv}
intrange_foreach_env
  (l, r, env) = let
//
fun loop
(
  l: int, r: int, env: &tenv
) : int =
(
//
if
l < r
then let
  val cont = intrange_foreach$cont<tenv> (l, env)
in
//
if
cont
then (
  intrange_foreach$fwork<tenv> (l, env); loop (succ(l), r, env)
) else l // end of [if]
//
end // end of [then]
else l // end of [else]
//
) // end of [loop]
//
in
  loop (l, r, env)
end // end of [intrange_foreach_env]

(* ****** ****** *)

implement{env}
intrange_foreach$cont (i, env) = true
(*
implement{env}
intrange_foreach$fwork (i, env) = ((*void*))
*)

(* ****** ****** *)

implement
{}(*tmp*)
int_foreach_cloref
  (n, fwork) = (
//
intrange_foreach_cloref<> (0, n, fwork)
//
) (* end of [int_foreach_cloref] *)

(* ****** ****** *)

implement
{}(*tmp*)
intrange_foreach_cloref
  (l, r, fwork) = let
//
implement
(env)(*tmp*)
intrange_foreach$cont<env> (i, env) = true
implement
(env)(*tmp*)
intrange_foreach$fwork<env>(i, env) = fwork(i)
//
var env: void = ()
//
in
  intrange_foreach_env<void> (l, r, env)
end // end of [intrange_foreach_cloref]

(* ****** ****** *)

implement{}
intrange_rforeach
  (l, r) = let
  var env: void = ()
in
  intrange_rforeach_env<void> (l, r, env)
end // end of [intrange_rforeach]

implement{tenv}
intrange_rforeach_env
  (l, r, env) = let
//
fun loop
(
  l: int, r: int, env: &tenv
) : int =
(
//
if
l < r
then let
  val r1 = pred (r)
  val cont = intrange_rforeach$cont<tenv> (r1, env)
in
//
if
cont
then (
  intrange_rforeach$fwork<tenv> (r1, env); loop (l, r1, env)
) else r // end of [if]
//
end // end of [then]
else r // end of [else]
//
) // end of [loop]
//
in
  loop (l, r, env)
end // end of [intrange_rforeach_env]

(* ****** ****** *)

implement{env}
intrange_rforeach$cont (i, env) = true
(*
implement{env}
intrange_rforeach$fwork (i, env) = ((*void*))
*)

(* ****** ****** *)

implement
{}(*tmp*)
int_rforeach_cloref
  (n, fwork) = (
//
intrange_rforeach_cloref<> (0, n, fwork)
//
) (* end of [int_rforeach_cloref] *)

(* ****** ****** *)

implement
{}(*tmp*)
intrange_rforeach_cloref
  (l, r, fwork) = let
//
implement
(env)(*tmp*)
intrange_rforeach$cont<env> (i, env) = true
implement
(env)(*tmp*)
intrange_rforeach$fwork<env>(i, env) = fwork(i)
//
var env: void = ()
//
in
  intrange_rforeach_env<void> (l, r, env)
end // end of [intrange_rforeach_cloref]

(* ****** ****** *)

implement{}
intrange2_foreach
  (l1, r1, l2, r2) = let
  var env: void = () in
  intrange2_foreach_env<void> (l1, r1, l2, r2, env)
end // end of [intrange2_foreach]

(* ****** ****** *)

implement{tenv}
intrange2_foreach_env
  (l1, r1, l2, r2, env) = let
//
fnx
loop1
(
  i: int, env: &(tenv) >> _
) : void =
(
if i < r1 then loop2 (i, l2, env) else ()
)
//
and
loop2
(
  i: int, j: int, env: &(tenv) >> _
) : void =
(
if
j < r2
then (
  intrange2_foreach$fwork(i, j, env); loop2 (i, j+1, env)
) else loop1 (i+1, env)
)
//
in
  loop1 (l1, env)
end // end of [intrange2_foreach]

(* ****** ****** *)

(* end of [intrange.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gnumber.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

(* Author: Brandon Barker *)
(* Authoremail: brandon.barker AT gmail DOT com *)
(* Start time: July, 2013 *)

(* ****** ****** *)

implement
{a}(*tmp*)
gadd_val_int(x, y) = gadd_val_val<a> (x, gnumber_int<a> (y))
implement
{a}(*tmp*)
gsub_val_int(x, y) = gsub_val_val<a> (x, gnumber_int<a> (y))
  
(* ****** ****** *)

implement
{a}(*tmp*)
gmul_int_val(x, y) = gmul_val_val<a> (gnumber_int<a> (x), y)
implement
{a}(*tmp*)
gmul_val_int(x, y) = gmul_val_val<a> (x, gnumber_int<a> (y))

(* ****** ****** *)

implement
{a}(*tmp*)
gdiv_int_val(x, y) = gdiv_val_val<a> (gnumber_int<a> (x), y)
implement
{a}(*tmp*)
gdiv_val_int(x, y) = gdiv_val_val<a> (x, gnumber_int<a> (y))
implement
{a}(*tmp*)
gmod_val_int(x, y) = gmod_val_val<a> (x, gnumber_int<a> (y))

(* ****** ****** *)

implement
{a}(*tmp*)
gpow_int_val
  (n, x) = let
//
fun
loop
{n:pos} .<n>.
(
  n: int(n), x: a, res: a
) :<> (a) =
(
//
if
n >= 2
then let
  val n2 = half(n)
  val r2 = n - (n2 + n2)
in
  if r2 = 0
    then loop (n2, gmul_val_val<a> (x, x), res)
    else loop (n2, gmul_val_val<a> (x, x), gmul_val_val<a> (x, res))
  // end of [if]
end else gmul_val_val<a> (x, res)
//
) (* end of [loop] *)
//
in
//
if
n >= 2
then loop (n-1, x, x)
else (
  if n >= 1 then x else gnumber_int<a> (1)
) (* end of [else] *)
//
end // end of [gpow_int_val]

(* ****** ****** *)

#include "./SHARE/gnumber_int.dats"
#include "./SHARE/gnumber_uint.dats"

(* ****** ****** *)

#include "./SHARE/gnumber_float.dats"

(* ****** ****** *)

(* end of [gnumber.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/arrayref.atxt
** Time of generation: Sat Oct 17 15:19:57 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_make_elt (asz, x) =
  arrayptr_refize(arrayptr_make_elt<a> (asz, x))
// end of [arrayref_make_elt]

(* ****** ****** *)

implement
{}(*tmp*)
arrayref_make_intrange (l, r) =
  arrayptr_refize{int}(arrayptr_make_intrange (l, r))
// end of [arrayref_make_intrange]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_make_list (asz, xs) =
  arrayptr_refize(arrayptr_make_list<a> (asz, xs))
// end of [arrayref_make_list]

implement
{a}(*tmp*)
arrayref_make_rlist (asz, xs) =
  arrayptr_refize(arrayptr_make_rlist<a> (asz, xs))
// end of [arrayref_make_rlist]

(* ****** ****** *)
//
implement
{a}(*tmp*)
arrayref_head(A) = $UN.ptr0_get<a> (arrayref2ptr(A))
implement
{a}(*tmp*)
arrayref_tail{n}(A) =
  $UN.cast{arrayref(a,n-1)}(ptr_succ<a>(arrayref2ptr(A)))
//
(* ****** ****** *)

implement
{a}{tk}(*tmp*)
arrayref_get_at_gint
  (A, i) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_get_at_gint (!p, i)
end // end of [arrayref_get_at_gint]
implement
{a}{tk}(*tmp*)
arrayref_get_at_guint
  (A, i) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_get_at_guint (!p, i)
end // end of [arrayref_get_at_guint]

(* ****** ****** *)

implement
{a}{tk}(*tmp*)
arrayref_set_at_gint
  (A, i, x) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_set_at_gint (!p, i, x)
//
end // end of [arrayref_set_at_gint]
implement
{a}{tk}(*tmp*)
arrayref_set_at_guint
  (A, i, x) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_set_at_guint (!p, i, x)
//
end // end of [arrayref_set_at_guint]

(* ****** ****** *)

implement
{a}{tk}(*tmp*)
arrayref_exch_at_gint
  (A, i, x) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_exch_at_gint (!p, i, x)
//
end // end of [arrayref_exch_at_gint]
implement
{a}{tk}(*tmp*)
arrayref_exch_at_guint
  (A, i, x) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_exch_at_guint (!p, i, x)
//
end // end of [arrayref_exch_at_guint]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_interchange
  (A, i, j) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_interchange<a> (!p, i, j)
//
end // end of [arrayref_interchange]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_subcirculate
  (A, i, j) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_subcirculate<a> (!p, i, j)
//
end // end of [arrayref_subcirculate]

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_arrayref
  (out, A, n) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (fprint_array<a> (out, !p, n))
end // end of [fprint_arrayref]

implement
{a}(*tmp*)
fprint_arrayref_sep
  (out, A, n, sep) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (fprint_array_sep<a> (out, !p, n, sep))
end // end of [fprint_arrayref_sep]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_copy
  {n} (A, n) = let
//
val (pf, fpf | p) =
  $UN.ptr0_vtake{array(a,n)}(ptrcast(A))
//
val (pf2, pf2gc | p2) = array_ptr_alloc<a> (n)
val ((*void*)) = array_copy<a> (!p2, !p, n)
//
prval ((*void*)) = fpf (pf)
//
in
  $UN.castvwtp0{arrayptr(a,n)}((pf2, pf2gc | p2))
end // end of [arrayref_copy]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_tabulate
  (asz) = arrayptr_refize (arrayptr_tabulate<a> (asz))
// end of [arrayref_tabulate]

implement
{a}(*tmp*)
arrayref_tabulate_cloref
  (asz, f) = arrayptr_refize (arrayptr_tabulate_cloref<a> (asz, f))
// end of [arrayref_tabulate_cloref]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_foreach
  (A, asz) = let
  var env: void = ()
  in arrayref_foreach_env<a><void> (A, asz, env)
end // end of [arrayref_foreach]

implement
{a}{env}
arrayref_foreach_env
  (A, asz, env) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (array_foreach_env<a><env> (!p, asz, env))
end // end of [arrayref_foreach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_iforeach
  (A, asz) = let
  var env: void = () in
  arrayref_iforeach_env<a><void> (A, asz, env)
end // end of [arrayref_iforeach]

implement
{a}{env}
arrayref_iforeach_env
  (A, asz, env) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (array_iforeach_env<a><env> (!p, asz, env))
end // end of [arrayref_iforeach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_rforeach
  (A, asz) = let
  var env: void = () in
  arrayref_rforeach_env<a><void> (A, asz, env)
end // end of [arrayref_rforeach]

implement
{a}{env}
arrayref_rforeach_env
  (A, asz, env) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (array_rforeach_env<a><env> (!p, asz, env))
end // end of [arrayref_rforeach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_quicksort
  (A, asz) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (array_quicksort<a> (!p, asz))
end // end of [arrayref_quicksort]

(* ****** ****** *)

local

datatype
arrszref
(
  a:viewt@ype
) =
  {n:int}
  ARRSZREF of (arrayref (a, n), size_t (n))
// end of [arrszref]

assume
arrszref_vt0ype_type = arrszref

in (* in of [local] *)

implement
{}(*tmp*)
arrszref_make_arrpsz
  (psz) = let
//
var asz: size_t
val A = arrpsz_get_ptrsize (psz, asz)
val A = arrayptr_refize (A)
//
in
  ARRSZREF(A, asz)
end // end of [arrszref_make_arrpsz]

(* ****** ****** *)
//
implement
{}(*tmp*)
arrszref_make_arrayref
  (A, asz) = ARRSZREF(A, asz)
//
(* ****** ****** *)

implement
{}(*tmp*)
arrszref_get_ref
  (ASZ) = let
//
val+
ARRSZREF(A, _) = ASZ in $UN.cast2Ptr1(A)
//
end // end of [arrszref_get_size]

(* ****** ****** *)

implement
{}(*tmp*)
arrszref_get_size
  (ASZ) = let
//
val+ARRSZREF(_, n) = ASZ in (n)
//
end // end of [arrszref_get_size]

(* ****** ****** *)

implement
{}(*tmp*)
arrszref_get_refsize
  (ASZ, nref) = let
//
val+ARRSZREF(A, n) = ASZ
//
prval () = lemma_arrayref_param (A)
//
in
  nref := n; A(*arrayref*)
end // end of [arrszref_get_refsize]

end // end of [local]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_make_elt
  (n, x) = let
//
val n = g1ofg0_uint (n)
val A = arrayref_make_elt<a> (n, x)
//
in
  arrszref_make_arrayref (A, n)
end // end of [arrszref_make_elt]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_make_list
  (xs) = let
//
val n = list_length<a> (xs)
val A = arrayref_make_list (n, xs)
//
prval () = lemma_list_param (xs)
//
in
  arrszref_make_arrayref (A, i2sz(n))
end // end of [arrszref_make_list]

implement
{a}(*tmp*)
arrszref_make_rlist
  (xs) = let
//
prval () = lemma_list_param (xs)
//
val n = list_length<a> (xs)
val A = arrayref_make_rlist (n, xs)
//
in
  arrszref_make_arrayref (A, i2sz(n))
end // end of [arrszref_make_rlist]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_get_at_size
  (ASZ, i) = $effmask_wrt let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
val i = g1ofg0_uint (i)
//
in
//
if n > i
then arrayref_get_at_guint (A, i)
else $raise ArraySubscriptExn((*void*))
//
end // end of [arrszref_get_at_size]

implement
{a}{tk}
arrszref_get_at_gint
  (ASZ, i) = let
in
//
if (
i >= 0
) then (
  arrszref_get_at_size (ASZ, g0i2u(i))
) else (
  $raise ArraySubscriptExn((* i < 0 *))
) // end of [if]
end // end of [arrszref_get_at_gint]

implement
{a}{tk}
arrszref_get_at_guint
  (ASZ, i) = let
in
  arrszref_get_at_size (ASZ, g0u2u(i))
end // end of [arrszref_get_at_guint]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_set_at_size
  (ASZ, i, x) = $effmask_wrt let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
val i = g1ofg0_uint (i)
//
in
//
if n > i
then arrayref_set_at_guint (A, i, x)
else $raise ArraySubscriptExn((*void*))
//
end // end of [arrszref_set_at_size]

implement
{a}{tk}
arrszref_set_at_gint
  (ASZ, i, x) = let
in
//
if (
i >= 0
) then (
  arrszref_set_at_size (ASZ, g0i2u(i), x)
) else $raise ArraySubscriptExn((*i < 0*))
//
end // end of [arrszref_set_at_gint]

implement
{a}{tk}
arrszref_set_at_guint
  (ASZ, i, x) = let
in
  arrszref_set_at_size (ASZ, g0u2u(i), x)
end // end of [arrszref_set_at_guint]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_exch_at_size
  (ASZ, i, x) = $effmask_wrt let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
val i = g1ofg0_uint (i)
//
in
//
if n > i
then arrayref_exch_at_guint (A, i, x)
else $raise ArraySubscriptExn((*void*))
// end of [if]
//
end // end of [arrszref_exch_at_size]

implement
{a}{tk}
arrszref_exch_at_gint
  (ASZ, i, x) = let
in
//
if (
i >= 0
) then (
  arrszref_exch_at_size (ASZ, g0i2u(i), x)
) else $raise ArraySubscriptExn((*i < 0*))
//
end // end of [arrszref_exch_at_gint]

implement
{a}{tk}
arrszref_exch_at_guint
  (ASZ, i, x) = let
in
  arrszref_exch_at_size (ASZ, g0u2u(i), x)
end // end of [arrszref_exch_at_guint]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_interchange
(
  ASZ, i, j
) = $effmask_wrt let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
val i = g1ofg0_uint (i)
val j = g1ofg0_uint (j)
//
in
//
if n > i
then (
  if n > j
  then arrayref_interchange (A, i, j)
  else $raise ArraySubscriptExn((*void*))
) else $raise ArraySubscriptExn((*void*))
//
end // end of [arrszref_interchange]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_subcirculate
(
  ASZ, i, j
) = $effmask_wrt let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
val i = g1ofg0_uint (i)
val j = g1ofg0_uint (j)
//
in
//
if n > i
then (
  if n > j
  then arrayref_subcirculate (A, i, j)
  else $raise ArraySubscriptExn((*void*))
) else $raise ArraySubscriptExn((*void*))
//
end // end of [arrszref_subcirculate]

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_arrszref
  (out, ASZ) = let
//
var asz: size_t
val A = arrszref_get_refsize (ASZ, asz)
//
in
  fprint_arrayref (out, A, asz)
end // end of [fprint_arrszref]

implement
{a}(*tmp*)
fprint_arrszref_sep
  (out, ASZ, sep) = let
//
var asz: size_t
val A = arrszref_get_refsize (ASZ, asz)
//
in
  fprint_arrayref_sep (out, A, asz, sep)
end // end of [fprint_arrszref_sep]

(* ****** ****** *)
//
implement
{a}(*tmp*)
arrszref_tabulate (asz) = let
  val asz = g1ofg0_uint (asz)
  val A = arrayref_tabulate<a> (asz) in arrszref_make_arrayref(A, asz)
end // end of [arrszref_tabulate]
//
implement
{a}(*tmp*)
arrszref_tabulate_cloref (asz, f) = let
  val A = arrayref_tabulate_cloref<a> (asz, f) in arrszref_make_arrayref(A, asz)
end // end of [arrszref_tabulate_cloref]
//
(* ****** ****** *)

(* end of [arrayref.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/matrix.atxt
** Time of generation: Sat Oct 17 15:19:57 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
matrix_getref_at_int
  (M, i, n, j) =
  $UN.cast{cPtr1(a)}(ptr_add<a> (addr@(M), i*n+j))
// end of [matrix_getref_at_int]

implement{a}
matrix_getref_at_size
  (M, i, n, j) =
  $UN.cast{cPtr1(a)}(ptr_add<a> (addr@(M), i*n+j))
// end of [matrix_getref_at_size]

(* ****** ****** *)

implement{a}
matrix_get_at_int
  (M, i, n, j) = $UN.cptr_get (matrix_getref_at_int (M, i, n, j))
// end of [matrix_get_at_int]

implement{a}
matrix_set_at_int
  (M, i, n, j, x) = $UN.cptr_set (matrix_getref_at_int (M, i, n, j), x)
// end of [matrix_set_at_int]

implement{a}
matrix_exch_at_int
  (M, i, n, j, x) = $UN.cptr_exch (matrix_getref_at_int (M, i, n, j), x)
// end of [matrix_exch_at_int]

(* ****** ****** *)

implement{a}
matrix_get_at_size
  (M, i, n, j) = $UN.cptr_get (matrix_getref_at_size (M, i, n, j))
// end of [matrix_get_at_size]

implement{a}
matrix_set_at_size
  (M, i, n, j, x) = $UN.cptr_set (matrix_getref_at_size (M, i, n, j), x)
// end of [matrix_set_at_size]

implement{a}
matrix_exch_at_size
  (M, i, n, j, x) = $UN.cptr_exch (matrix_getref_at_size (M, i, n, j), x)
// end of [matrix_exch_at_size]

(* ****** ****** *)

implement{a}
matrix_ptr_alloc
  (row, col) = let
//
val
(
  pfarr, pfgc | p
) = array_ptr_alloc<a> (row*col)
//
prval pfmat = array2matrix_v(pfarr)
//
in
  @(pfmat, pfgc | p)
end // end of [matrix_ptr_alloc]

(* ****** ****** *)

implement{}
matrix_ptr_free
  {a} (pfmat, pfgc | p) = let
//
prval pfarr = matrix2array_v (pfmat)
//
in
  array_ptr_free (pfarr, pfgc | p)
end // end of [matrix_ptr_free]

(* ****** ****** *)

implement{a}
matrix_ptr_tabulate
  (row, col) = let
//
val (pf, pfgc | p) = matrix_ptr_alloc<a> (row, col)
//
implement
matrix_initize$init<a> (i, j, x) = x := matrix_tabulate$fopr<a> (i, j)
//
val () = matrix_initize<a> (!p, row, col)
//
in
  @(pf, pfgc | p)
end // end of [matrix_ptr_tabulate]

(* ****** ****** *)

implement{}
fprint_matrix$sep1 (out) = fprint (out, ", ")
implement{}
fprint_matrix$sep2 (out) = fprint (out, "; ")

implement{a}
fprint_matrix_int
  (out, M, m, n) = let
//
prval () = lemma_matrix_param (M)
//
in
  fprint_matrix_size (out, M, i2sz(m), i2sz(n))
end // end of [fprint_matrix_int]

implement{a}
fprint_matrix_size
  {m,n} (out, M, m, n) = let
//
implement
fprint_array$sep<> (out) = fprint_matrix$sep1 (out)
//
fun loop {l:addr}
(
  out: FILEref, p0: ptr l, m: size_t m, n: size_t n, i: size_t
) : void = let
in
//
if i < m then let
  val () =
  (
    if i > 0 then fprint_matrix$sep2 (out)
  ) : void // end of [val]
  val (
    pf, fpf | p0
  ) = $UN.ptr_vtake{array(a,n)}(p0)
  val () = fprint_array (out, !p0, n)
  prval () = fpf (pf)
in
  loop (out, ptr_add<a> (p0, n), m, n, succ(i))
end else () // end of [if]
//
end // end of [loop]
//
in
  loop (out, addr@ (M), m, n, i2sz(0))
end // end of [fprint_matrix_size]

(* ****** ****** *)

implement{a}
fprint_matrix_sep
(
  out, M, m, n, sep1, sep2
) = let
//
implement
fprint_matrix$sep1<> (out) = fprint (out, sep1)
implement
fprint_matrix$sep2<> (out) = fprint (out, sep2)
//
in
  fprint_matrix_size (out, M, m, n)
end // end of [fprint_matrix_sep]

(* ****** ****** *)

implement{a}
matrix_foreach (A, m, n) = let
  var env: void = () in matrix_foreach_env<a><void> (A, m, n, env)
end // end of [matrix_foreach]

implement
{a}{env}
matrix_foreach_env
  (A, m, n, env) = let
//
implement
array_foreach$cont<a><env> (x, env) = true
implement
array_foreach$fwork<a><env> (x, env) = matrix_foreach$fwork<a><env> (x, env)
//
val p = addr@(A)
prval pf = matrix2array_v (view@(A))
val _(*mn*) = array_foreach_env<a> (!p, m*n, env)
prval () = view@(A) := array2matrix_v (pf)
//
in
  // nothing
end // end of [matrix_foreach_env]

(* ****** ****** *)

implement{a}
matrix_initize
  (M, m, n) = let
//
infixl (/) %
#define % g0uint_mod
//
implement
array_initize$init<a>
  (ij, x) = let
in
  matrix_initize$init<a> (ij/n, ij%n, x)
end // end of [array_initize$init]
//
val p = addr@(M)
prval pf = matrix2array_v (view@(M))
val () = array_initize<a> (!p, m * n)
prval () = view@(M) := array2matrix_v (pf)
//
in
  // nothing
end // end of [matrix_initize]

(* ****** ****** *)

implement
{a}{b}
matrix_mapto
  {m,n} (A, B, m, n) = let
//
val pA = addr@(A)
val pB = addr@(B)
//
prval pfA = matrix2array_v (view@(A))
prval pfB = matrix2array_v (view@(B))
//
local
//
implement
array_mapto$fwork<a><b>
  (x, y) = matrix_mapto$fwork<a><b> (x, y)
//
in (* in of [local] *)
//
val ((*void*)) = array_mapto<a><b> (!pA, !pB, m*n)
//
end // end of [local]
//
prval () = view@(A) := array2matrix_v {a}{..}{m,n} (pfA)
prval () = view@(B) := array2matrix_v {b}{..}{m,n} (pfB)
//
in
  // nothing
end (* end of [matrix_mapto] *)

(* ****** ****** *)

implement
{a,b}{c}
matrix_map2to
  {m,n} (A, B, C, m, n) = let
//
val pA = addr@(A)
val pB = addr@(B)
val pC = addr@(C)
//
prval pfA = matrix2array_v (view@(A))
prval pfB = matrix2array_v (view@(B))
prval pfC = matrix2array_v (view@(C))
//
local
//
implement
array_map2to$fwork<a,b><c>
  (x, y, z) = matrix_map2to$fwork<a,b><c> (x, y, z)
//
in (* in of [local] *)
//
val ((*void*)) = array_map2to<a,b><c> (!pA, !pB, !pC, m*n)
//
end // end of [local]
//
prval () = view@(A) := array2matrix_v {a}{..}{m,n} (pfA)
prval () = view@(B) := array2matrix_v {b}{..}{m,n} (pfB)
prval () = view@(C) := array2matrix_v {c}{..}{m,n} (pfC)
//
in
  // nothing
end (* end of [matrix_map2to] *)

(* ****** ****** *)

(* end of [matrix.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/char.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{tk}
g0int_of_char
  (c) = __cast (c) where {
  extern castfn __cast (c: char):<> g0int (tk)
} // end of [g0int_of_char]
implement{tk}
g0int_of_schar
  (c) = __cast (c) where {
  extern castfn __cast (c: schar):<> g0int (tk)
} // end of [g0int_of_schar]
implement{tk}
g0int_of_uchar
  (c) = __cast (c) where {
  extern castfn __cast (c: uchar):<> g0int (tk)
} // end of [g0int_of_uchar]

implement{tk}
g0uint_of_uchar
  (c) = __cast (c) where {
  extern castfn __cast (c: uchar):<> g0uint (tk)
} // end of [g0uint_of_uchar]

(* ****** ****** *)

implement{tk}
g1int_of_char1
  {c} (c) = __cast (c) where {
  extern castfn __cast (c: char c):<> g1int (tk, c)
} // end of [g1int_of_char1]
implement{tk}
g1int_of_schar1
  {c} (c) = __cast (c) where {
  extern castfn __cast (c: schar c):<> g1int (tk, c)
} // end of [g1int_of_schar1]
implement{tk}
g1int_of_uchar1
  {c} (c) = __cast (c) where {
  extern castfn __cast (c: uchar c):<> g1int (tk, c)
} // end of [g1int_of_uchar1]

implement{tk}
g1uint_of_uchar1
  {c} (c) = __cast (c) where {
  extern castfn __cast (c: uchar c):<> g1uint (tk, c)
} // end of [g1uint_of_uchar1]

(* ****** ****** *)

implement
{}(*tmp*)
char2string(c) =
$effmask_wrt
(
  $UN.castvwtp0{string}(char2strptr(c))
) (* end of [char2string] *)
implement
{}(*tmp*)
char2strptr(c) = let
//
#define BSZ 16
//
typedef
cstring = $extype"atstype_string"
//
var buf = @[byte][BSZ]()
val bufp = $UN.cast{cstring}(addr@buf)
//
val _(*int*) =
  $extfcall(ssize_t, "snprintf", bufp, BSZ, "%c", c)
//
in
  $UN.castvwtp0{Strptr1}(string0_copy($UN.cast{string}(bufp)))
end // end of [char2strptr]

(* ****** ****** *)
//
implement fprint_val<char> = fprint_char
implement fprint_val<uchar> = fprint_uchar
implement fprint_val<schar> = fprint_schar
//
(* ****** ****** *)

(* end of [char.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: February, 2012
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [fcontainer.dats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/fcontainer.sats"

(* ****** ****** *)

implement
{xs}{x}
iforeach (xs) = let
//
var i
  : size_t = g0int2uint (0)
val p_i = $UN.cast2Ptr1 (addr@ (i))
//
implement
foreach$fwork<x>
  (x) = () where {
  val i = $UN.ptr1_get<size_t> (p_i)
  val () = iforeach$fwork<x> (i, x)
  val () = $UN.ptr1_set<size_t> (p_i, succ(i))
} // [foreach$work]
//
in
  foreach<xs><x> (xs)
end // end of [iforeach]

(* ****** ****** *)

implement
{xs}{x}{init}
foldleft_funenv
  {v}{vt}{fe:eff}
  (pfv | xs, init, f, env) = let
//
var res: init = init
viewtypedef pvt = (ptr(res), vt)
//
val env1 = __cast (env) where {
  extern castfn __cast (env: !vt >> vt?):<> vt
} // end of [val]
//
val p_res = addr@ (res)
var penv: pvt = (p_res, env1)
viewdef v1 = (v, init@res, pvt @ penv)
fn f1 (
  pf: !v1 | x: x, penv: !ptr(penv)
) :<fe> void = let
  val p = penv->0
  val x = f (pf.0 | !p, x, penv->1)
in
  $effmask_wrt (!p := x)
end // end of [f1]
//
prval pfv1 = (pfv, view@(res), view@(penv))
val () = foreach_funenv{v1}{ptr(penv)} (pfv1 | xs, f1, addr@(penv))
prval () = pfv := pfv1.0
prval () = view@(res) := pfv1.1
prval () = view@(penv) := pfv1.2
//
prval () =
  __xfree (env, penv.1) where {
  extern praxi __xfree (env: !vt? >> vt, env1: vt): void
} // end of [where] // end of [prval]
//
in
  res
end // end of [foldleft_funenv]

implement
{xs}{x}{init}
foldleft_clo
  {fe:eff}(xs, init, f) = let
  typedef clo_t =
    (init, x) -<clo,fe> init
  // end of [typedef]
  val p_f = addr@ (f)
  prval [lf:addr]
    EQADDR () = ptr_get_index (p_f)
  viewdef v = clo_t @ lf
  fn app (
    pf: !v | init: init, x: x, p_f: !ptr(lf)
  ) :<fe> init = !p_f (init, x)
in
  foldleft_funenv<xs><x> {v}{ptr(lf)} (view@ f | xs, init, app, p_f)
end // end of [foldleft_clo]

implement
{xs}{x}{init}
foldleft_vclo
  {v} {fe:eff}
  (pfv | xs, init, f) = let
  typedef clo_t =
    (!v | init, x) -<clo,fe> init
  // end of [typedef]
  val p_f = addr@ (f)
  prval [lf:addr]
    EQADDR () = ptr_get_index (p_f)
  viewdef v2 = (v, clo_t @ lf)
  fn app (
    pf: !v2
  | init: init, x: x, p_f: !ptr lf
  ) :<fe> init = res where {
    prval (pf1, pf2) = pf
    val res = !p_f (pf1 | init, x)
    prval () = pf := (pf1, pf2)
  } // end of [val]
  prval pf = (pfv, view@ f)
  val res = foldleft_funenv<xs><x> {v2} {ptr(lf)} (pf | xs, init, app, p_f)
  prval () = pfv := pf.0 and () = view@ (f) := pf.1
in
  res(*init*)
end // end of [foldleft_vclo]

implement
{xs}{x}{init}
foldleft_cloref
  {fe:eff} (xs, init, f) = let
  typedef cloref_t = (init, x) -<cloref,fe> init
  fn app (
    pf: !unit_v | init: init, x: x, f: !cloref_t 
  ) :<fe> init = f (init, x)
  prval pfu = unit_v ()
  val res = foldleft_funenv<xs><x> {unit_v} {cloref_t} (pfu | xs, init, app, f)
  prval unit_v () = pfu
in
  res(*init*)
end // end of [foldleft_cloref]

(* ****** ****** *)

implement
{xs}{x}{sink}
foldright_funenv
  {v}{vt}{fe:eff}
  (pfv | xs, f, sink, env) = let
//
typedef tfun = (!v | x, sink, !vt) -<fun,fe> sink
//
fun loop {n:nat} .<n>. (
  pfv: !v
| xs: list_vt (x, n), f: tfun, sink: sink, env: !vt
) :<fe> sink = (
  case+ xs of
  | ~list_vt_cons (x, xs) =>
      loop (pfv | xs, f, f (pfv | x, sink, env), env)
  | ~list_vt_nil () => sink
) (* end of [loop] *)
//
val rxs = rlistize (xs)
//
in
  loop (pfv | rxs, f, sink, env)
end // end of [foldright_funenv]

implement
{xs}{x}{sink}
foldright_clo
  {fe:eff}(xs, f, sink) = let
  typedef clo_t =
    (x, sink) -<clo,fe> sink
  // end of [typedef]
  val p_f = addr@ (f)
  prval [lf:addr]
    EQADDR () = ptr_get_index (p_f)
  viewdef v = clo_t @ lf
  fn app (
    pf: !v | x: x, sink: sink, p_f: !ptr(lf)
  ) :<fe> sink = !p_f (x, sink)
in
  foldright_funenv<xs><x> {v}{ptr(lf)} (view@ f | xs, app, sink, p_f)
end // end of [foldright_clo]
implement
{xs}{x}{sink}
foldright_vclo
  {v} {fe:eff}
  (pfv | xs, f, sink) = let
  typedef clo_t =
    (!v | x, sink) -<clo,fe> sink
  // end of [typedef]
  val p_f = addr@ (f)
  prval [lf:addr]
    EQADDR () = ptr_get_index (p_f)
  viewdef v2 = (v, clo_t @ lf)
  fn app (
    pf: !v2 | x: x, sink: sink, p_f: !ptr lf
  ) :<fe> sink = res where {
    prval (pf1, pf2) = pf
    val res = !p_f (pf1 | x, sink)
    prval () = pf := (pf1, pf2)
  } // end of [val]
  prval pf = (pfv, view@ f)
  val res = foldright_funenv<xs><x> {v2} {ptr(lf)} (pf | xs, app, sink, p_f)
  prval () = pfv := pf.0 and () = view@ (f) := pf.1
in
  res(*sink*)
end // end of [foldright_vclo]

implement
{xs}{x}{sink}
foldright_cloref
  {fe:eff} (xs, f, sink) = let
  typedef cloref_t = (x, sink) -<cloref,fe> sink
  fn app (
    pf: !unit_v | x: x, sink: sink, f: !cloref_t 
  ) :<fe> sink = f (x, sink)
  prval pfu = unit_v ()
  val res = foldright_funenv<xs><x> {unit_v} {cloref_t} (pfu | xs, app, sink, f)
  prval unit_v () = pfu
in
  res(*sink*)
end // end of [foldright_cloref]

(* ****** ****** *)
//
// HX-2012-02:
// this implementation makes use
// of the (local) exception mechanism
//
implement
{xs}{x}
exists_funenv
  {v}{vt}{fe:eff}
  (pfv | xs, p, env) = let
  exception Found of ()
  fn f (
    pfv: !v | x: x, env: !vt
  ) :<fe,!exn> void =
    if p (pfv | x, env) then $raise (Found) else ()
  // end of [f]
  val ptr = __cast (env) where {
    extern castfn __cast (env: !vt):<> ptr
  } // end of [val]
in try let
  val env = __encode (ptr) where {
    extern castfn __encode (x: ptr):<> vt
  } // end of [val]
  prval (pfv, fpfv) = __assert () where {
    extern praxi __assert (): (v, v -<lin,prf> void)
  } // end of [prval]
  val () = $effmask_exn (foreach_funenv<xs><x> (pfv | xs, f, env))
  prval () = fpfv (pfv)
  val ptr = __decode (env) where {
    extern castfn __decode (x: vt):<> ptr
  } // end of [val]
in
  true (* element satifying [p] is found *)
end with
  ~Found () => false
// end of [try]
end // end of [exists_funenv]

(* ****** ****** *)

implement
{xs}{x}
forall_funenv
  {v}{vt}{fe:eff}
  (pfv | xs, p, env) = let
  fn np (pfv: !v | x: x, env: !vt):<fe> bool = ~p (pfv | x, env)
in
  ~(exists_funenv<xs><x> (pfv | xs, np, env))
end // end of [forall_funenv]

(* ****** ****** *)

implement
{xs}{x}
ismember_fun
  {fe} (xs, x0, eq) = let
  var p_clo =
    lam@ (x: x) =<fe> eq (x0, x) in exists_clo<xs><x> (xs, p_clo)
  // end of [var]
end // end of [ismemer_fun]

(* ****** ****** *)

implement
{xs}{x}
rlistize (xs) = res where {
  var res
    : List0_vt (x) = list_vt_nil ()
  viewdef v = List0_vt (x) @ res
  var p_clo = lam@ (
    pf: !v >> v | x: x
  ) : void =<clo> $effmask_wrt (res := list_vt_cons (x, res))
  val () = foreach_vclo {v}{effnil} (view@ (res) | xs, p_clo)
} // end of [rlistize]

implement
{xs}{x}{y}
rlistize_funenv
  {v}{vt}{fe}
  (pfv | xs, f, env) = let
  var res
    : List0_vt (y) = list_vt_nil ()
  viewdef v2 = @(v, List0_vt (y) @ res)
  val ptr =
    $UN.castvwtp1 {ptr}{vt} (env)
  // end of [val]
  var p_clo = lam@
    (pf: !v2 >> v2 | x: x): void =<clo,fe> let
    extern castfn __encode (x: ptr):<> vt
    extern castfn __decode (x: vt):<> ptr
    val env = __encode (ptr)
    val y = f (pf.0 | x, env)
    val ptr = __decode (env)
    prval pfat = pf.1
    val () = $effmask_wrt (res := list_vt_cons (y, res))
    prval () = pf.1 := pfat
  in
    (*nothing*)
  end // end of [var]
  prval pf = (pfv, view@ (res))
  val () = foreach_vclo {v2} (pf | xs, p_clo)
  prval () = pfv := pf.0
  prval () = view@ (res) := pf.1
in
  res
end // end of [rlistize_funenv]

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [fcontainer.dats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [fcontainer.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: February, 2012
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [giterator.dats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/giterator.sats"

(* ****** ****** *)

implement
{knd}{x}
fprint_giter_sep
  {kpm}{f,r}
  (out, itr, sep) = let
//
val () = lemma_giter_param (itr)
//
stadef giter
  (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | r >= 0} .<r>. (
  out: FILEref
, itr: !giter (f, r) >> giter (f+r, 0)
, sep: string
, notbeg: bool
) : void = let
  val test = giter_isnot_atend (itr)
in
  if test then let
    val p = giter_getref_inc<knd><x> (itr)
    val (pf, fpf | p) = $UN.ptr_vtake{x}(p)
    val () = if notbeg then fprint_string (out, sep)
    val () = fprint_ref<x> (out, !p)
    prval () = fpf (pf)
  in
    loop (out, itr, sep, true)
  end else () // end of [if]
end // end of [loop]
//
in
  loop (out, itr, sep, false(*notbeg*))
end // end of [fprint_giter_sep]

(* ****** ****** *)

implement
{knd}{x}
giter_isnot_atbeg (itr) = let
  prval () = lemma_giter_param (itr) in ~giter_is_atbeg (itr)
end // end of [giter_isnot_atbeg]

implement
{knd}{x}
giter_isnot_atend (itr) = let
  prval () = lemma_giter_param (itr) in ~giter_is_atend (itr)
end // end of [giter_isnot_atend]

(* ****** ****** *)

implement
{knd}{x}
giter_vttake (itr) = let
  val p =
    giter_getref<knd><x> (itr)
  val (
    pf, fpf | p
  ) = $UN.ptr_vtake{x}(p)
  val res = $UN.vttakeout_void{x}(!p)
  prval () = fpf (pf)
in
  res
end // end of [giter_vttake]

implement
{knd}{x}
giter_get (itr) = x where {
  val (fpf | x) = giter_vttake<knd><x> (itr); prval () = fpf (x)
} // end of [giter_get]

implement
{knd}{x}
giter_set (itr, x) =
  $UN.ptr1_set<x> (giter_getref<knd><x> (itr), x)
// end of [giter_set]

(* ****** ****** *)

implement
{knd}{x}
giter_getref_inc (itr) = let
  val p = giter_getref<knd><x> (itr) in giter_inc<knd><x> (itr); p
end // end of [giter_getref_inc]

implement
{knd}{x}
giter_vttake_inc (itr) = let
  val p =
    giter_getref_inc<knd><x> (itr)
  val (
    pf, fpf | p
  ) = $UN.ptr_vtake{x}(p)
  val res = $UN.vttakeout_void{x}(!p)
  prval () = fpf (pf)
in
  res
end // end of [giter_vttake_inc]

implement
{knd}{x}
giter_get_inc
  (itr) = x where {
  val (fpf | x) =
    giter_vttake_inc<knd><x> (itr)
  prval () = fpf (x)
} // end of [giter_get_inc]
implement
{knd}{x}
giter_set_inc (itr, x) =
  $UN.ptr1_set<x> (giter_getref_inc<knd><x> (itr), x)
// end of [giter_set_inc]
implement
{knd}{x}
giter_exch_inc (itr, x) =
  $UN.ptr1_exch<x> (giter_getref_inc<knd><x> (itr), x)
// end of [giter_exch_inc]

(* ****** ****** *)

implement
{knd}{x}
giter_dec_getref (itr) = let
  prval () =
    lemma_giter_param (itr)
  val () = giter_dec<knd><x> (itr)
in
  giter_getref<knd><x> (itr)
end // end of [giter_dec_getref]

implement
{knd}{x}
giter_dec_vttake (itr) = let
  val p =
    giter_dec_getref<knd><x> (itr)
  val (
    pf, fpf | p
  ) = $UN.ptr_vtake{x}(p)
  val res = $UN.vttakeout_void{x}(!p)
  prval () = fpf (pf)
in
  res
end // end of [giter_dec_vttake]

implement
{knd}{x}
giter_dec_get
  (itr) = x where {
  val (fpf | x) =
    giter_dec_vttake<knd><x> (itr)
  prval () = fpf (x)
} // end of [giter_dec_get]
implement
{knd}{x}
giter_dec_set (itr, x) =
  $UN.ptr1_set<x> (giter_dec_getref<knd><x> (itr), x)
// end of [giter_dec_set]
implement
{knd}{x}
giter_dec_exch (itr, x) =
  $UN.ptr1_exch<x> (giter_dec_getref<knd><x> (itr), x)
// end of [giter_dec_exch]

(* ****** ****** *)
(*
** HX: forward-get, set and exchange
*)
implement
{knd}{x}
giter_fget_at (itr, i) =
  $UN.ptr1_get<x> (giter_fgetref_at<knd><x> (itr, i))
// end of [giter_fget_at]
implement
{knd}{x}
giter_fset_at (itr, i, x) =
  $UN.ptr1_set<x> (giter_fgetref_at<knd><x> (itr, i), x)
// end of [giter_fset_at]
implement
{knd}{x}
giter_fexch_at (itr, i, x) =
  $UN.ptr1_exch<x> (giter_fgetref_at<knd><x> (itr, i), x)
// end of [giter_fexch_at]

(* ****** ****** *)
(*
** HX: forward/backward-get, set and exchange
*)
implement
{knd}{x}
giter_fbget_at (itr, i) =
  $UN.ptr1_get<x> (giter_fbgetref_at<knd><x> (itr, i))
// end of [giter_fbget_at]
implement
{knd}{x}
giter_fbset_at (itr, i, x) =
  $UN.ptr1_set<x> (giter_fbgetref_at<knd><x> (itr, i), x)
// end of [giter_fbset_at]
implement
{knd}{x}
giter_fbexch_at (itr, i, x) =
  $UN.ptr1_exch<x> (giter_fbgetref_at<knd><x> (itr, i), x)
// end of [giter_fbexch_at]

(* ****** ****** *)

implement
{knd}{x}
giter_fgetlst {kpm} (itr, i) = let
//
prval () = lemma_giter_param (itr)
//
stadef giter
  (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | r >= 0} {i:nat} .<r>. (
  itr: !giter (f, r) >> giter (f+i1, r-i1)
, i: &int(i) >> int(i-i1)
, res: &ptr? >> list_vt (x, i1)
) : #[i1:int | i1 == min(i,r)] void = let
in
//
if i > 0 then let
  val test = giter_isnot_atend (itr)
in
  if test then let
    val () = i := i - 1
    val x = giter_get_inc (itr)
    val () = res :=
      list_vt_cons {x}{0} (x, _)
    val+ list_vt_cons (x, res1) = res
    val () = loop (itr, i, res1)
    prval () = fold@ (res)
  in
    // nothing
  end else (res := list_vt_nil)
end else (res := list_vt_nil) // endif
//
end // end of [loop]
//
var res: ptr
val () = loop (itr, i, res)
//
in
  res
end // end of [giter_fgetlst]

(* ****** ****** *)

implement
{knd}{x}
giter_bgetlst {kpm} (itr, i) = let
//
prval () = lemma_giter_param (itr)
//
stadef giter
  (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | f >= 0} {i:nat} .<f>. (
  itr: !giter (f, r) >> giter (f-i1, r+i1)
, i: &int(i) >> int(i-i1)
, res: &ptr? >> list_vt (x, i1)
) : #[i1:int | i1 == min(i,f)] void = let
in
//
if i > 0 then let
  val test = giter_isnot_atbeg (itr)
in
  if test then let
    val () = i := i - 1
    val x = giter_dec_get (itr)
    val () = res :=
      list_vt_cons {x}{0} (x, _)
    val+ list_vt_cons (x, res1) = res
    val () = loop (itr, i, res1)
    prval () = fold@ (res)
  in
    // nothing
  end else (res := list_vt_nil)
end else (res := list_vt_nil) // endif
//
end // end of [loop]
//
var res: ptr
val () = loop (itr, i, res)
//
in
  res
end // end of [giter_bgetlst]

(* ****** ****** *)

implement
{knd}{x}
giter_ins_inc (itr, x) = let
  prval () = lemma_giter_param (itr)
  val () = giter_ins (itr, x) in giter_inc (itr)
end // end of [giter_ins_inc]

implement
{knd}{x}
giter_dec_rmv (itr) = let
  prval () = lemma_giter_param (itr)
  val () = giter_dec (itr) in giter_rmv (itr)
end // end of [giter_dec_rmv]

(* ****** ****** *)
//
// HX: some common generic functions on giterators
//
(* ****** ****** *)

implement
{knd}{x}
giter_listize_cpy {kpm} (itr) = let
//
prval () = lemma_giter_param (itr)
//
stadef giter (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | r >= 0} .<r>. (
  itr: !giter (f, r) >> giter (f+r, 0), res: &ptr? >> list_vt (x, r)
) : void = let
  val test = giter_isnot_atend (itr)
in
  if test then let
    val x = giter_get_inc (itr)
    val () = res :=
      list_vt_cons {x}{0} (x, _)
    val+ list_vt_cons (x, res1) = res
    val () = loop (itr, res1)
    prval () = fold@ (res)
  in
    // nothing
  end else (res := list_vt_nil)
end // end of [loop]
//
var res: ptr
val () = loop (itr, res)
//
in
  res
end // end of [giter_listize_cpy]

implement
{knd}{x}
giter_rlistize_cpy
  {kpm} (itr) = let
//
prval () = lemma_giter_param (itr)
//
stadef giter (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | r >= 0}{r2:nat} .<r>. (
  itr: !giter (f, r) >> giter (f+r, 0), res: list_vt (x, r2)
) : list_vt (x, r+r2) = let
  val test = giter_isnot_atend (itr)
in
  if test then let
    val x = giter_get_inc (itr)
  in
    loop (itr, list_vt_cons (x, res))
  end else res // end of [if]
end // end of [loop]
//
in
  loop (itr, list_vt_nil)
end // end of [giter_listize_cpy]

(* ****** ****** *)

implement
{knd}{x}
giter_foreach (itr) = let
  var env: void = () in giter_foreach_env<knd><x><void> (itr, env)
end // end of [giter_foreach]

implement
{knd}{x}{env}
giter_foreach_env
  {kpm}{f,r} (itr, env) = let
//
prval () = lemma_giter_param (itr)
//
stadef giter (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | r >= 0} .<r>. (
  itr: !giter (f, r) >> giter (f1, r1), env: &env
) : #[f1,r1:int | f <= f1 | f+r==f1+r1] void = let
  val isnotend =
    giter_isnot_atend<knd><x> (itr) 
  // end of [val]
in
  if isnotend then let
    val p =
      giter_getref_inc<knd><x> (itr)
    val (pf, fpf | p) = $UN.ptr_vtake{x}(p)
    val cont = giter_foreach$cont (!p, env)
  in
    if cont then let
      val () = giter_foreach$fwork (!p, env)
      prval () = fpf (pf)
    in
      loop (itr, env)
    end else let
      prval () = fpf (pf)
    in
      (*nothing*)
    end // end of [if]
  end else ((*void*)) // end of [if]
end // end of [loop]
//
in
  loop (itr, env)
end // end of [giter_foreach_env]

(* ****** ****** *)
(*
** HX-2012-05-23:
** this is a very exiciting example for myself :)
*)
implement
{knd}{x}
giter_bsearch
  {kpm} (itr, ra) = let
//
prval () = lemma_giter_param (itr)
prval () = lemma_g1uint_param (ra)
//
stadef giter
  (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:nat}
  {ra:nat | ra <= r} .<ra>. (
  itr: !giter (f, r) >> giter (f1, r1)
, ra: size_t (ra)
) : #[
  f1,r1:int | f1>=f;f+ra>=f1;f+r==f1+r1
] void = (
  if ra > 0 then let
    val ra2 = half (ra)
    val p =
      giter_fgetref_at (itr, ra2)
    val (
      pf, fpf | p
    ) = $UN.ptr_vtake{x}(p)
    val sgn = giter_bsearch$ford (!p)
    prval () = fpf (pf)
  in
    if sgn <= 0 then
      loop (itr, ra2)
    else let
      val ra21 = succ(ra2)
      val () = giter_fjmp (itr, ra21)
    in
      loop (itr, ra-ra21)
    end // end of [if]
  end else () // end of [if]
) (* end of [loop] *)
//
in
  loop (itr, ra)
end // end of [giter_bsearch]

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [giterator.dats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [giterator.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list.atxt
** Time of generation: Sun Oct 18 08:38:09 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: July, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)
//
// HX-2014-04-07:
// This is a wild implementation!
//
implement
{a}(*tmp*)
stream_vt2t(xs) = let
//
fun
aux (
  xs: stream_vt(a)
) :<!laz> stream(a) = let
//
val xs = $UN.castvwtp0{ptr}(xs)
//
in
//
$delay
(
let
  val xs =
    $UN.castvwtp0{stream_vt(a)}(xs)
  val xs_con = !xs
in
  case+ xs_con of
  | ~stream_vt_nil
      ((*void*)) => stream_nil ()
    // end of [stream_vt_nil]
  | @stream_vt_cons
      (x, xs1) => let
      val xs1_val = xs1
      val () = xs1 := aux (xs1_val)
    in
      $UN.castvwtp0{stream_con(a)}((view@x, view@xs1 | xs_con))
    end // end of [stream_cons]
end
)
end // end of [aux]
//
in
  aux (xs)
end // end of [stream_vt2t]

(* ****** ****** *)

local
//
// HX-2012: casting stream_vt_cons to list_cons
//
extern
castfn
stream2list_vt_cons
  {l0,l1,l2:addr}
(
  stream_vt_cons_unfold (l0, l1, l2)
) :<> list_vt_cons_unfold (l0, l1, l2)

in (* in-of-local *)

implement
{a}(*tmp*)
stream2list_vt(xs) = let
//
fun
loop (
  xs: stream_vt a
) :<!laz> List0_vt (a) = let
  val xs_con = !xs
in
  case+ xs_con of
  | ~stream_vt_nil
      ((*void*)) => list_vt_nil()
    // end of [stream_vt_nil]
  | @stream_vt_cons
      (x, xs1) => let
      val xs1_val = xs1
      val () = xs1 := loop (xs1_val)
      val xs_con = stream2list_vt_cons (xs_con)
    in
      fold@ (xs_con); xs_con
    end // end of [stream_vt_cons]
end // end of [loop]
//
in
  loop (xs)
end // end of [stream2list_vt]

end // end of [local]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_vt_free (xs) = ~(xs)

(* ****** ****** *)
//
implement
{a}(*tmp*)
stream_vt_drop_exn
  (xs, n) = let
//
fun aux
  : $d2ctype(stream_vt_drop_exn<a>) =
lam (xs, n) =>
(
//
if
n > 0
then (
//
case+ !xs of
| ~stream_vt_cons
    (_, xs) => aux(xs, n-1)
  // end of [stream_vt_cons]
| ~stream_vt_nil
    ((*void*)) => $raise StreamSubscriptExn()
  // end of [stream_vt_nil]
//
) (* end of [then] *)
else (xs) // end of [else]
//
) (* end of [lam] *)
//
in
  aux (xs, n)
end // end of [stream_vt_drop_exn]
//
implement
{a}(*tmp*)
stream_vt_drop_opt
  (xs, n) = let
//
fun aux
  : $d2ctype(stream_vt_drop_opt<a>) =
lam (xs, n) =>
(
//
if
n > 0
then (
//
case+ !xs of
| ~stream_vt_cons
    (_, xs) => aux(xs, n-1)
| ~stream_vt_nil
    ((*void*)) => None_vt((*void*))
//
) (* end of [then] *)
else Some_vt{stream_vt(a)}(xs) // [else]
//
) (* end of [lam] *)
//
in
  aux (xs, n)
end // end of [stream_vt_drop_opt]
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
stream_vt_head(xs) =
(
case+ !xs of
| ~stream_vt_cons (x, xs) =>
    let val () = stream_vt_free (xs) in x end
| ~stream_vt_nil ((*void*)) => $raise StreamSubscriptExn()
) (* end of [stream_vt_head] *)
//
implement
{a}(*tmp*)
stream_vt_tail(xs) =
(
case+ !xs of
| ~stream_vt_cons (x, xs) => (xs)
| ~stream_vt_nil ((*void*)) => $raise StreamSubscriptExn()
) (* end of [stream_vt_tail] *)
//
(* ****** ****** *)

implement
{a}(*tmp*)
stream_vt_uncons(xs0) =
(
case+ !xs0 of
| ~stream_vt_cons
    (x, xs) => (xs0 := xs; x)
| ~stream_vt_nil () => let
    val () =
      xs0 := $ldelay (stream_vt_nil)
    // end of [val]
  in
    $raise StreamSubscriptExn((*void*))
  end // end of [stream_vt_nil]
) (* end of [stream_vt_uncons] *)

(* ****** ****** *)

implement
{a}(*tmp*)
stream_vt_foreach
  (xs) = let
  var env: void = ()
in
  stream_vt_foreach_env<a><void> (xs, env)
end // end of [stream_vt_foreach]

implement
{a}(*tmp*){env}
stream_vt_foreach_env
  (xs, env) = let
  val xs_con = !xs
in
//
case+ xs_con of
| @stream_vt_cons
    (x, xs1) => let
    val xs1 = xs1
    val () = stream_vt_foreach$fwork<a> (x, env)
    val () = free@ {a} (xs_con)
  in
    stream_vt_foreach<a> (xs1)
  end // end of [stream_vt_cons]
| ~stream_vt_nil () => ()
//
end // end of [stream_vt_foreach_env]

(* ****** ****** *)

local

fun{a:t0p}
stream_vt_filter_con
(
  xs: stream_vt (a)
) : stream_vt_con (a) = let
  val xs = !xs
in
//
case+ xs of
| @stream_vt_cons
    (x, xs1) => let
    val test =
      stream_vt_filter$pred<a> (x)
    // end of [val]
  in
    if test then let
      val () =
      xs1 := stream_vt_filter (xs1)
    in
      fold@{a}(xs); xs
    end else let
      val xs1 = xs1
      val ((*void*)) = free@{a}(xs)
    in
      stream_vt_filter_con<a> (xs1)
    end // end of [if]
  end // end of [cons]
| ~stream_vt_nil((*void*)) => stream_vt_nil()
//
end (* end of [stream_vt_filter_con] *)

in (* in of [local] *)

implement
{a}(*tmp*)
stream_vt_filter (xs) =
  $ldelay (stream_vt_filter_con<a> (xs), ~xs)
// end of [stream_vt_filter]

implement
{a}(*tmp*)
stream_vt_filter_fun
  (xs, pred) = let
//
implement{a2}
stream_vt_filter$pred (x) = let
//
val p = addr@(x)
val (pf, fpf | p) = $UN.ptr0_vtake{a}(p)
val test = pred (!p)
prval ((*void*)) = fpf (pf)
//
in
  test
end // end of [stream_vt_filter$pred]
//
in
  stream_vt_filter (xs)
end // end of [stream_vt_filter_fun]

end // end of [local]

(* ****** ****** *)

local

fun{}
auxfree
  {a:t0p}
(
  pred: (&a) -<cloptr> bool
) : void =
  cloptr_free ($UN.castvwtp0{cloptr0}(pred))

fun{a:t0p}
stream_vt_filter_cloptr_con
(
  xs: stream_vt (a), pred: (&a) -<cloptr> bool
) : stream_vt_con (a) = let
  val xs = !xs
in
//
case+ xs of
| @stream_vt_cons
    (x, xs1) => let
    val test = pred (x)
  in
    if test then let
      val () = xs1 :=
      stream_vt_filter_cloptr (xs1, pred)
    in
      fold@{a}(xs); xs
    end else let
      val xs1 = xs1
      val ((*void*)) = free@{a}(xs)
    in
      stream_vt_filter_cloptr_con<a> (xs1, pred)
    end // end of [if]
  end // end of [cons]
| ~stream_vt_nil () =>
    let val () = auxfree(pred) in stream_vt_nil(*void*) end
//
end (* end of [stream_vt_filter_cloptr_con] *)

in (* in of [local] *)

implement
{a}(*tmp*)
stream_vt_filter_cloptr
  (xs, pred) = $ldelay
(
  stream_vt_filter_cloptr_con<a> (xs, pred), (~xs; auxfree(pred))
) (* end of [stream_vt_filter_cloptr] *)

end // end of [local]

(* ****** ****** *)

local

fun{
a:vt0p}{b:vt0p
} stream_vt_map_con
(
  xs: stream_vt (a)
) : stream_vt_con (b) = let
  val xs_con = !xs
in
//
case+ xs_con of
| @stream_vt_cons(x, xs) => let
    val y = stream_vt_map$fopr<a><b> (x)
    val xs = xs
    val ((*void*)) = free@ (xs_con)
  in
    stream_vt_cons{b}(y, stream_vt_map<a><b> (xs))
  end (* end of [stream_vt_con] *)
| ~stream_vt_nil((*void*)) => stream_vt_nil()
//
end // end of [stream_vt_map_con]

in (* in of [local] *)

implement
{a}{b}(*tmp*)
stream_vt_map (xs) = $ldelay (stream_vt_map_con<a><b> (xs), ~xs)

end // end of [local]

(* ****** ****** *)

implement
{a}{b}(*tmp*)
stream_vt_map_fun
  (xs, f) = let
//
implement
{a2}{b2}
stream_vt_map$fopr (x) = let
  prval () = __assert (x) where
  {
    extern praxi __assert (x: &a2 >> a2?!): void
  }
  val (
    pf, fpf | p_x
  ) = $UN.ptr0_vtake{a}(addr@x)
  val res = $UN.castvwtp0{b2}(f(!p_x))
  prval () = $UN.castview0{void}(@(fpf, pf))
in
  res
end (* end of [stream_vt_map$fopr] *)
//
in
  stream_vt_map<a><b> (xs)
end // end of [stream_vt_map_fun]

(* ****** ****** *)

local

fun{
a1,a2:t0p}{b:vt0p
} stream_vt_map2_con
(
  xs1: stream_vt (a1)
, xs2: stream_vt (a2)
) : stream_vt_con (b) = let
  val xs1_con = !xs1
in
//
case+ xs1_con of
| @stream_vt_cons
    (x1, xs1) => let
    val xs2_con = !xs2
  in
    case+ xs2_con of
    | @stream_vt_cons
        (x2, xs2) => let
        val y = stream_vt_map2$fopr<a1,a2><b> (x1, x2)
        val xs1 = xs1
        and xs2 = xs2
        val () = free@ (xs1_con)
        and () = free@ (xs2_con)
      in
        stream_vt_cons{b}(y, stream_vt_map2<a1,a2><b> (xs1, xs2))
      end // end of [stream_vt_cons]
    | ~stream_vt_nil() => let
        val xs1 = xs1
        val () = free@ (xs1_con)
      in
        ~xs1; stream_vt_nil ()
      end // end of [stream_vt_nil]
  end // end of [stream_vt_cons]
| ~stream_vt_nil((*void*)) => (~xs2; stream_vt_nil())
//
end // end of [stream_vt_map_con]

in (* in of [local] *)

implement
{a1,a2}{b}
stream_vt_map2
  (xs1, xs2) = $ldelay
  (stream_vt_map2_con<a1,a2><b> (xs1, xs2), (~xs1; ~xs2))
// end of [stream_vt_map2]

implement
{a1,a2}{b}
stream_vt_map2_fun
  (xs1, xs2, f) = let
//
implement
{a12,a22}{b2}
stream_vt_map2$fopr
  (x1, x2) = let
  val (
    pf1, fpf1 | p_x1
  ) = $UN.ptr0_vtake{a1}(addr@x1)
  and (
    pf2, fpf2 | p_x2
  ) = $UN.ptr0_vtake{a2}(addr@x2)
  val res =
    $UN.castvwtp0{b2}(f(!p_x1, !p_x2))
  prval () = fpf1 (pf1) and () = fpf2 (pf2)
in
  res
end (* end of [stream_vt_map2$fopr] *)
//
in
  stream_vt_map2<a1,a2><b> (xs1, xs2)
end // end of [stream_vt_map2_fun]

end // end of [local]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_vt_tabulate
(
// argumentless
) = aux (0) where
{
//
fun aux (i: intGte(0)): stream_vt (a) =
  $ldelay (stream_vt_cons{a}(stream_vt_tabulate$fopr<a> (i), aux (i+1)))
//
} (* end of [stream_vt_tabulate] *)

(* ****** ****** *)

local
//
datavtype streamer
  (a:vt@ype+) = STREAMER of (stream_vt(a))
//
assume streamer_vtype (a:vt0p) = streamer (a)
//
in (* in-of-local *)

implement
{}(*tmp*)
streamer_vt_make (xs) = STREAMER (xs)

implement
{}(*tmp*)
streamer_vt_free
  (xser) = let val+~STREAMER(xs) = xser in ~xs end
// end of [streamer_free]

implement
{a}(*tmp*)
streamer_vt_eval_exn
  (xser) = let
//
val+@STREAMER(xs) = xser
//
in
//
case+ !xs of
| ~stream_vt_cons
    (x, xs2) =>
  (
    xs := xs2; fold@(xser); x
  ) (* end of [stream_vt_cons] *)
| ~stream_vt_nil
    ((*void*)) => let
    prval () =
     __assert (view@xs) where
    {
      extern
      praxi __assert{l:addr}(!ptr@l >> stream_vt(a)@l): void
    } (* end of [prval] *)
    prval () = fold@(xser)
  in
    $raise StreamSubscriptExn()
  end (* end of [stream_vt_nil] *)
//
end // end of [stream_eval_exn]

end // end of [local]

(* ****** ****** *)

(* end of [stream_vt.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: February, 2012
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [fcontainer_foreach.dats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/fcontainer.sats"

(* ****** ****** *)

implement
{xs}{x}
foreach_fun
  {fe:eff} (xs, f) = let
  val f = coerce (f) where { extern castfn
    coerce (f: (x) -<fe> void):<> (!unit_v | x, !ptr) -<fe> void
  } // end of [val] // HX: this is a safe cast
  prval pfu = unit_v ()
  val () = foreach_funenv<xs><x> {unit_v} {ptr} (pfu | xs, f, the_null_ptr)
  prval unit_v () = pfu
in
  // empty
end // end of [foreach_fun]

implement
{xs}{x}
foreach_clo
  {fe:eff}
  (xs, f) = let
  typedef clo_t = (x) -<clo,fe> void
  val p_f = addr@(f)
  prval [f:addr] EQADDR () = ptr_get_index (p_f)  
  viewdef v = clo_t @ f
  fn app (pf: !v | x: x, p_f: !ptr f):<fe> void = !p_f (x)
in
  foreach_funenv<xs><x> {v}{ptr(f)} (view@ f | xs, app, p_f)
end // end of [foreach_clo]

implement
{xs}{x}
foreach_vclo
  {v} {fe:eff}
  (pfv | xs, f) = let
  typedef clo_t = (!v | x) -<clo,fe> void
  val p_f = addr@(f)
  prval [f:addr] EQADDR () = ptr_get_index (p_f)  
  viewdef v2 = (v, clo_t @ f)
  fn app (pf: !v2 | x: x, p_f: !ptr f):<fe> void = () where {
    val () = !p_f (pf.0 | x)
  } // end of [val]
  prval pf = (pfv, view@ f)
  val () = foreach_funenv<xs><x> {v2} {ptr(f)} (pf | xs, app, p_f)
  prval () = pfv := pf.0 and () = view@ (f) := pf.1
in
  (*nothing*)
end // end of [foreach_vclo]

implement
{xs}{x}
foreach_cloptr
  {fe:eff}
  (xs, f) = let
  viewdef uv = unit_v
  viewtypedef cloptr0_t = (x) -<cloptr,fe> void
  viewtypedef cloptr1_t = (!uv>>uv | x) -<cloptr,fe> void
  prval () = __assert(f) where {
    extern prfun __assert (f: !cloptr0_t >> cloptr1_t): void
  } // end of [val] // HX: this is a safe cast
  prval pfu = unit_v ()
  val () = foreach_vcloptr<xs><x> {uv} (pfu | xs, f)
  prval unit_v () = pfu
  prval () = __assert(f) where {
    extern prfun __assert (f: !cloptr1_t >> cloptr0_t): void
  } // end of [val] // HX: this is a safe cast
in
  (*nothing*)
end // end of [foreach_cloptr]
implement
{xs}{x}
foreach_vcloptr
  {v} {fe:eff} (pf | xs, f) = let
  viewtypedef cloptr_t = (!v | x) -<cloptr,fe> void
  fn app (pf: !v | x: x, f: !cloptr_t):<fe> void = f (pf | x)
in
  foreach_funenv<xs><x> {v} {cloptr_t} (pf | xs, app, f)
end // end of [foreach_vcloptr]

implement
{xs}{x}
foreach_cloref
  {fe:eff}
  (xs, f) = let
  viewdef uv = unit_v
  typedef cloref_t = (x) -<cloref,fe> void
  fn app (pf: !uv | x: x, f: !cloref_t):<fe> void = f (x)
  prval pfu = unit_v ()
  val () = foreach_funenv<xs><x> {uv} {cloref_t} (pfu | xs, app, f)
  prval unit_v () = pfu
in
  (*empty*)
end // end of [foreach_cloref]

(* ****** ****** *)

implement
{xs}{x}
iforeach_funenv
  {v}{vt}{fe} (
  pfv | xs, f, env
) = let
var i: int = 0
val p_i = addr@(i)
viewtypedef ivt = (ptr(i), vt)
//
val env1 = __cast (env) where {
  extern castfn __cast (env: !vt >> vt?):<> vt
} // end of [val]
//
var ienv
  : ivt = (p_i, env1)
val p_ienv = addr@(ienv)
viewdef v1 = (v, int@i, ivt@ienv)
fn f1 (
  pf: !v1 | x: x, p: !ptr(ienv)
) :<fe> void = let
  val i = !(p->0)
  val () = f (pf.0 | i, x, p->1)
in
  $effmask_wrt (!(p->0) := i + 1)
end // end of [f1]
//
prval pfv1 = (pfv, view@(i), view@(ienv))
val () = foreach_funenv{v1}{ptr(ienv)} (pfv1 | xs, f1, p_ienv)
prval () = pfv := pfv1.0
prval () = view@(i) := pfv1.1
prval () = view@(ienv) := pfv1.2
//
prval () =
  __xfree (env, ienv.1) where {
  extern praxi __xfree (env: !vt? >> vt, env1: vt): void
} // end of [where] // end of [prval]
//
in
  i // = the size of [xs]
end // end of [iforeach_funenv]

(* ****** ****** *)

implement
{xs}{x}
iforeach_clo
  {fe:eff}
  (xs, f) = let
  typedef clo_t = (int, x) -<clo,fe> void
  val p_f = addr@(f)
  prval [f:addr] EQADDR () = ptr_get_index (p_f)  
  viewdef v = clo_t @ f
  fn app (pf: !v | i: int, x: x, p_f: !ptr f):<fe> void = !p_f (i, x)
in
  iforeach_funenv<xs><x> {v}{ptr(f)} (view@ f | xs, app, p_f)
end // end of [iforeach_clo]

implement
{xs}{x}
iforeach_vclo
  {v} {fe:eff}
  (pfv | xs, f) = let
  typedef clo_t = (!v | int, x) -<clo,fe> void
  val p_f = addr@(f)
  prval [f:addr] EQADDR () = ptr_get_index (p_f)  
  viewdef v2 = (v, clo_t @ f)
  fn app (
    pf: !v2 | i: int, x: x, p_f: !ptr f
  ) :<fe> void = () where {
    val () = !p_f (pf.0 | i, x)
  } // end of [val]
  prval pf = (pfv, view@ f)
  val nxs = iforeach_funenv<xs><x> {v2} {ptr(f)} (pf | xs, app, p_f)
  prval () = pfv := pf.0 and () = view@ (f) := pf.1
in
  nxs
end // end of [iforeach_vclo]

(* ****** ****** *)

implement
{xs}{x}
iforeach_cloptr
  {fe:eff}
  (xs, f) = let
  viewdef uv = unit_v
  viewtypedef cloptr0_t = (int, x) -<cloptr,fe> void
  viewtypedef cloptr1_t = (!uv >> uv | int, x) -<cloptr,fe> void
  prval () = __assert(f) where {
    extern prfun __assert (f: !cloptr0_t >> cloptr1_t): void
  } // end of [val] // HX: this is a safe cast
  prval pfu = unit_v ()
  val nxs = iforeach_vcloptr<xs><x> {uv} (pfu | xs, f)
  prval unit_v () = pfu
  prval () = __assert(f) where {
    extern prfun __assert (f: !cloptr1_t >> cloptr0_t): void
  } // end of [val] // HX: this is a safe cast
in
  nxs
end // end of [iforeach_cloptr]
implement
{xs}{x}
iforeach_vcloptr
  {v} {fe:eff} (pf | xs, f) = let
  viewtypedef cloptr_t = (!v | int, x) -<cloptr,fe> void
  fn app (pf: !v | i: int, x: x, f: !cloptr_t):<fe> void = f (pf | i, x)
in
  iforeach_funenv<xs><x> {v} {cloptr_t} (pf | xs, app, f)
end // end of [iforeach_vcloptr]

(* ****** ****** *)

implement
{xs}{x}
iforeach_cloref
  {fe:eff}
  (xs, f) = let
  viewdef uv = unit_v
  typedef cloref_t = (int, x) -<cloref,fe> void
  fn app (pf: !uv | i: int, x: x, f: !cloref_t):<fe> void = f (i, x)
  prval pfu = unit_v ()
  val nxs = iforeach_funenv<xs><x> {uv} {cloref_t} (pfu | xs, app, f)
  prval unit_v () = pfu
in
  nxs
end // end of [foreach_cloref]

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [fcontainer_foreach.dats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [fcontainer_foreach.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/matrixref.atxt
** Time of generation: Sat Oct 17 15:19:58 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
matrixref_make_elt
  (nrow, ncol, x) =
  matrixptr_refize(matrixptr_make_elt<a> (nrow, ncol, x))
// end of [matrixref_make_elt]

(* ****** ****** *)

implement{a}
matrixref_get_at_size
  (A, i, n, j) = let
//
val
(
vbox pf | p
) = matrixref_get_viewptr (A)
//
in
  matrix_get_at_size (!p, i, n, j)
end // end of [matrixref_get_at_size]

(* ****** ****** *)
//
implement
{a}(*tmp*)
matrixref_get_at_int
  (M, i, n, j) =
  matrixref_get_at_size (M, i2sz(i), i2sz(n), i2sz(j))
//
(* ****** ****** *)

implement{a}
matrixref_set_at_size
  (A, i, n, j, x) = let
//
val
(
vbox pf | p
) = matrixref_get_viewptr (A)
//
in
  matrix_set_at_size (!p, i, n, j, x)
end // end of [matrixref_set_at_size]

(* ****** ****** *)
//
implement
{a}(*tmp*)
matrixref_set_at_int
  (M, i, n, j, x) =
  matrixref_set_at_size (M, i2sz(i), i2sz(n), i2sz(j), x)
//
(* ****** ****** *)

implement{a}
fprint_matrixref
  {m,n}
(
  out, M, nrow, ncol
) = {
//
val M =
$UN.castvwtp1{matrixptr(a, m, n)}(M)
//
val () = fprint_matrixptr<a> (out, M, nrow, ncol)
//
prval ((*void*)) = $UN.cast2void (M)
//
} (* end of [fprint_matrixref] *)

implement{a}
fprint_matrixref_sep
  {m,n}
(
  out, M, nrow, ncol, sep1, sep2
) = {
//
val M =
$UN.castvwtp1{matrixptr(a, m, n)}(M)
//
val () =
fprint_matrixptr_sep<a> (out, M, nrow, ncol, sep1, sep2)
//
prval ((*void*)) = $UN.cast2void (M)
//
} (* end of [fprint_matrixref_sep] *)

(* ****** ****** *)

implement
{a}(*tmp*)
matrixref_copy
  {m,n} (M, m, n) = let
//
val A = $UN.cast{arrayref(a,m*n)}(M)
//
in
  $UN.castvwtp0{matrixptr(a,m,n)}(arrayref_copy<a> (A, m*n))
end // end of [matrixref_copy]

(* ****** ****** *)

implement{a}
matrixref_tabulate
  (nrow, ncol) =
(
  matrixptr_refize (matrixptr_tabulate<a> (nrow, ncol))
) (* end of [matrixref_tabulate] *)

implement{a}
matrixref_tabulate_cloref
  (nrow, ncol, f) =
  matrixptr_refize (matrixptr_tabulate_cloref<a> (nrow, ncol, f))
// end of [matrixref_tabulate_cloref]

(* ****** ****** *)

implement{a}
matrixref_foreach
  (A, m, n) = let
//
var env: void = ()
//
in
  matrixref_foreach_env<a><void> (A, m, n, env)
end // end of [matrixref_foreach]

implement
{a}{env}
matrixref_foreach_env
  (A, m, n, env) = let
  val (vbox pf | p) = matrixref_get_viewptr (A)
in
  $effmask_ref (matrix_foreach_env<a><env> (!p, m, n, env))
end // end of [matrixref_foreach_env]

(* ****** ****** *)

local
//
datatype
mtrxszref
(
  a:viewt@ype
) =
{m,n:int}
MTRXSZREF of
(
  matrixref(a, m, n)
, size_t(m), size_t(n)
) // end of [mtrxszref]
//
assume mtrxszref_vt0ype_type = mtrxszref
//
in (* in of [local] *)

implement{}
mtrxszref_make_matrixref
  (M, nrow, ncol) = MTRXSZREF (M, nrow, ncol)
// end of [mtrxszref_make_matrixref]

(* ****** ****** *)

implement{}
mtrxszref_get_ref (MSZ) = let
  val+MTRXSZREF (M, nrow, ncol) = MSZ in $UN.cast2Ptr1(M)
end // end of [mtrxszref_get_ref]

(* ****** ****** *)

implement{}
mtrxszref_get_nrow (MSZ) = let
  val+MTRXSZREF (M, nrow, ncol) = MSZ in nrow
end // end of [mtrxszref_get_nrow]

implement{}
mtrxszref_get_ncol (MSZ) = let
  val+MTRXSZREF (M, nrow, ncol) = MSZ in ncol
end // end of [mtrxszref_get_ncol]

(* ****** ****** *)

implement{}
mtrxszref_get_refsize
   (MSZ, nrow_r, ncol_r) = let
//
val+MTRXSZREF (M, nrow, ncol) = MSZ
//
prval ((*void*)) = lemma_matrixref_param (M)
//
in
  nrow_r := nrow; ncol_r := ncol; M(*matrixref*)
end // end of [mtrxszref_get_nrow]

end // end of [local]

(* ****** ****** *)

implement{a}
mtrxszref_make_elt
  (nrow, ncol, x) = let
//
val nrow = g1ofg0_uint (nrow)
val ncol = g1ofg0_uint (ncol)
val M =
  matrixref_make_elt<a> (nrow, ncol, x)
//
in
  mtrxszref_make_matrixref (M, nrow, ncol)
end // end of [mtrxszref_make_elt]

(* ****** ****** *)

implement{a}
mtrxszref_get_at_int
  (MSZ, i, j) = let
//
val i = g1ofg0_int(i)
and j = g1ofg0_int(j)
//
in
//
if
i >= 0
then (
//
if
j >= 0
then (
  mtrxszref_get_at_size(MSZ,i2sz(i),i2sz(j))
) else $raise MatrixSubscriptExn((* j < 0 *))
//
) else $raise MatrixSubscriptExn((* i < 0 *))
//
end // end of [mtrxszref_get_at_gint]

implement{a}
mtrxszref_get_at_size
  (MSZ, i, j) = let
//
var nrow: size_t
and ncol: size_t
//
val M =
$effmask_wrt (
  mtrxszref_get_refsize (MSZ, nrow, ncol)
) (* end of [val] *)
//
val i = g1ofg0_uint(i)
and j = g1ofg0_uint(j)
//
in
//
if
nrow > i
then (
//
if
ncol > j
then (
  matrixref_get_at_size (M, i, ncol, j)
) else $raise MatrixSubscriptExn((*void*))
//
) else $raise MatrixSubscriptExn((*void*))
//
end // end of [mtrxszref_get_at_size]

(* ****** ****** *)

implement{a}
mtrxszref_set_at_int
  (MSZ, i, j, x) = let
//
val i = g1ofg0_int(i)
and j = g1ofg0_int(j)
//
in
//
if
i >= 0
then (
//
if
j >= 0
then (
  mtrxszref_set_at_size(MSZ,i2sz(i),i2sz(j),x)
) else $raise MatrixSubscriptExn( (* j < 0 *) )
//
) else $raise MatrixSubscriptExn( (* i < 0 *) )
//
end // end of [mtrxszref_set_at_int]

implement{a}
mtrxszref_set_at_size
  (MSZ, i, j, x) = let
//
var nrow: size_t
and ncol: size_t
//
val M =
(
  mtrxszref_get_refsize (MSZ, nrow, ncol)
) (* end of [val] *)
//
val i = g1ofg0_uint (i)
and j = g1ofg0_uint (j)
//
in
//
if
nrow > i
then (
//
if
ncol > j
then (
  matrixref_set_at_size(M, i, ncol, j, x)
) else $raise MatrixSubscriptExn((*void*))
//
) else $raise MatrixSubscriptExn((*void*))
//
end // end of [mtrxszref_set_at_size]

(* ****** ****** *)

implement{a}
fprint_mtrxszref
  (out, MSZ) = let
//
var nrow: size_t
and ncol: size_t
val A =
  mtrxszref_get_refsize (MSZ, nrow, ncol)
//
in
  fprint_matrixref<a> (out, A, nrow, ncol)
end // end of [fprint_mtrxszref]

implement{a}
fprint_mtrxszref_sep
  (out, MSZ, sep1, sep2) = let
//
var nrow: size_t
and ncol: size_t
val A =
  mtrxszref_get_refsize (MSZ, nrow, ncol)
//
in
  fprint_matrixref_sep<a> (out, A, nrow, ncol, sep1, sep2)
end // end of [fprint_mtrxszref_sep]

(* ****** ****** *)

implement{a}
mtrxszref_foreach
  (A) = let
//
var env: void = ()
//
in
  mtrxszref_foreach_env<a><void> (A, env)
end // end of [mtrxszref_foreach]

implement
{a}{env}
mtrxszref_foreach_env
  (MSZ, env) = let
//
var nrow: size_t and ncol: size_t
//
val MAT = mtrxszref_get_refsize(MSZ, nrow, ncol)
//
in
  matrixref_foreach_env<a><env> (MAT, nrow, ncol, env)
end // end of [mtrxszref_foreach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
mtrxszref_foreach_cloref
  (MSZ, fwork) = let
//
implement
{a2}{env}
matrix_foreach$fwork
  (x, env) = let
  val (pf, fpf | p) = $UN.ptr_vtake{a}(addr@x)
  val ((*void*)) = fwork(!p)
  prval ((*void*)) = fpf(pf)
in
  // nothing
end // end of [matrix_foreach$work]
//
in
  mtrxszref_foreach(MSZ)
end // end of [mtrxszref_foreach_cloref]

(* ****** ****** *)

implement{a}
mtrxszref_tabulate
  (nrow, ncol) = let
//
val nrow = g1ofg0_uint (nrow)
val ncol = g1ofg0_uint (ncol)
val M =
  matrixref_tabulate<a> (nrow, ncol)
//
in 
  mtrxszref_make_matrixref (M, nrow, ncol)
end // end of [mtrxszref_tabulate]

(* ****** ****** *)

implement{a}
mtrxszref_tabulate_cloref
(
  nrow, ncol, fclo
) = let
//
val M =
matrixref_tabulate_cloref<a>
(
  nrow, ncol, fclo
) (* end of [val] *)
//
in
//
mtrxszref_make_matrixref (M, nrow, ncol)
//
end // end of [mtrxszref_tabulate_cloref]

(* ****** ****** *)

(* end of [matrixref.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: May, 2012
//
(* ****** ****** *)
//
// HX-2012-05-25:
//
// for iterators based on singly-linked lists
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/giterator.sats"

(* ****** ****** *)

sortdef t0p = t@ype
sortdef vt0p = viewt@ype
stadef itrknd = giter_list_vt_kind
stadef itrkpm = giter_list_vt_param

(* ****** ****** *)

dataviewtype
iterk (
  a:viewt@ype+, int(*f*), int(*r*)
) = {f,r:int} ITR (a, f, r) of (list_vt (a, f+r), Ptr1)

(* ****** ****** *)

extern
castfn iterk2giter
  {x:vt0p}{n:int}
  (xs: iterk (x, 0, n)):<> giter (itrknd, itrkpm(), x, 0, n)
// end of [iterk2giter]

extern
castfn giter2iterk
  {x:vt0p}{f,r:int}
  (itr: giter (itrknd, itrkpm(), x, f, r)):<> iterk (x, f, r)
// end of [giter2iterk]

(* ****** ****** *)

implement{x}
giter_make_list_vt
  {n} (xs) = let
  val itr = ITR {x}{0,n} (xs, _)
  val+ ITR (xs, p) = itr
  val () = p := $UN.cast2Ptr1 (addr@ (xs))
  prval () = fold@ (itr)
in
  iterk2giter (itr)
end // end of [giter_make_list_vt]

implement
giter_free_list_vt (itr) = let
  val+ ~ITR (xs, _) = giter2iterk (itr) in xs
end // end of [giter_free_list_vt]

(* ****** ****** *)

extern
praxi encode
  {kpm:tk}{x:vt0p}{f,r:int}
  (xs: !iterk (x, f, r) >> giter (itrknd, kpm, x, f, r)): void
// end of [encode]

extern
praxi decode
  {kpm:tk}{x:vt0p}{f,r:int}
  (itr: !giter (itrknd, kpm, x, f, r) >> iterk (x, f, r)): void
// end of [decode]

(* ****** ****** *)

implement(x)
giter_is_atbeg<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  prval () = decode (itr)
  val+ @ITR (xs0, p) = itr
  val p_xs0 = addr@ (xs0)
  val p = p
  prval () = fold@ (itr)
  prval () = encode (itr)
//
  extern castfn
    __cast {b:bool} (bool(b)):<> [b==(f==0)] bool (b)
  // end of [extern]
in
  if p_xs0 = p then __cast(true) else __cast(false)
end // end of [giter_is_atbeg]

(* ****** ****** *)

implement(x)
giter_is_atend<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  viewtypedef vt = list_vt (x, r)
//
  prval () = decode (itr)
  val+ ITR (_, p) = itr
  prval () = encode (itr)
  val xs = $UN.ptr1_get<vt> (p)
  val isnil = list_vt_is_nil (xs)
  prval () = __vfree (xs) where {
    extern praxi __vfree (xs: vt): void // returned back to [!p]
  } // end of [prval]
in
  isnil
end // end of [giter_is_atend]

(* ****** ****** *)

implement(x)
giter_getref<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  viewtypedef vt = list_vt (x, r)
//
  prval () = decode (itr)
  val+ ITR (_, p) = itr
  prval () = encode (itr)
//
  val xs = $UN.ptr1_get<vt> (p)
  val @list_vt_cons (x, _) = xs
  val p_x = addr@ (x)
  prval () = fold@ (xs)
  prval () = __vfree (xs) where {
    extern praxi __vfree (xs: vt): void // returned back to [!p]
  } // end of [prval]
in
  $UN.cast2Ptr1 (p_x)
end // end of [giter_getref]

(* ****** ****** *)

implement(x)
giter_inc<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  viewtypedef vt = list_vt (x, r)
//
  prval () = decode (itr)
  val+ @ITR (_, p) = itr
  val xs = $UN.ptr1_get<vt> (p)
  val+ @list_vt_cons (_, xs1) = xs
  val () = p := $UN.cast2Ptr1 (addr@ (xs1))
  val () = fold@ (itr)
  prval () = encode (itr)
//
  prval () = fold@ (xs)
  prval () = __vfree (xs) where {
    extern praxi __vfree (xs: vt): void // returned back to [!p]
  } // end of [prval]
in
  // nothing
end // end of [giter_inc]

(* ****** ****** *)

implement(x)
giter_getref_inc<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  viewtypedef vt = list_vt (x, r)
//
  prval () = decode (itr)
  val+ @ITR (_, p) = itr
  val xs = $UN.ptr1_get<vt> (p)
  val+ @list_vt_cons (x, xs1) = xs
  val p_x = addr@ (x)
  val () = p := $UN.cast2Ptr1 (addr@ (xs1))
  val () = fold@ (itr)
  prval () = encode (itr)
//
  prval () = fold@ (xs)
  prval () = __vfree (xs) where {
    extern praxi __vfree (xs: vt): void // returned back to [!p]
  } // end of [prval]
in
  $UN.cast2Ptr1 (p_x)
end // end of [giter_getref_inc]

(* ****** ****** *)

implement(x)
giter_ins<itrknd><x>
  {kpm}{f,r} (itr, x) = let
//
  prval () =
    lemma_giter_param (itr)
  (* end of [prval] *)
//
  viewtypedef vt = list_vt (x, r)
  viewtypedef vt1 = list_vt (x, r+1)
  prval () = decode (itr)
  val+ @ITR (xs0, p) = itr
  val xs = $UN.ptr1_get<vt> (p)
  val () = $UN.ptr1_set<vt1> (p, list_vt_cons (x, xs))
  prval () = let
    extern praxi __assert
      (xs0: !list_vt (x, f+r) >> list_vt (x, f+r+1)): void
    // end of [extern]
  in
    __assert (xs0)
  end // end of [prval]
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_ins]

(* ****** ****** *)

implement(x)
giter_rmv<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  viewtypedef vt = list_vt (x, r)
  viewtypedef vt1 = list_vt (x, r-1)
//
  prval () = decode (itr)
  val+ @ITR (xs0, p) = itr
  val xs = $UN.ptr1_get<vt> (p)
  val+ ~list_vt_cons (x, xs1) = xs
  val () = $UN.ptr1_set<vt1> (p, xs1)
  prval () = let
    extern praxi __assert
      (xs0: !list_vt (x, f+r) >> list_vt (x, f+r-1)): void
    // end of [extern]
  in
    __assert (xs0)
  end // end of [prval]
  prval () = fold@ (itr)
  prval () = encode (itr)
//
in
  x
end // end of [giter_rmv]

(* ****** ****** *)

(* end of [giter_list_vt.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/parray.atxt
** Time of generation: Sat Oct 17 15:19:57 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
parray_is_empty
  {l}{n} (pf | p) = let
//
prval () =
  lemma_parray_v_params (pf)
//
val x = $UN.ptr0_get<ptr> (p)
val [lx:addr] x = g1ofg0_ptr (x)
//
prval () =
__assert () where {
  extern praxi __assert (): [(lx <= null && n == 0) || (lx > null && n > 0)] void
} (* end of [prval] *)
//
in
  lte_ptr1_ptr1 (x, the_null_ptr)
end // end of [parray_is_empty]

implement{a}
parray_isnot_empty
  {l}{n} (pf | p) = let
//
prval () =
  lemma_parray_v_params (pf)
//
val x = $UN.ptr0_get<ptr> (p)
val [lx:addr] x = g1ofg0_ptr (x)
//
prval () =
__assert () where {
  extern praxi __assert (): [(lx <= null && n == 0) || (lx > null && n > 0)] void
} (* end of [prval] *)
//
in
  gt_ptr1_ptr1 (x, the_null_ptr)
end // end of [parray_isnot_empty]

(* ****** ****** *)

implement
{a}(*tmp*)
parray_size
  (pf | p) = let
//
prval () = lemma_parray_v_params (pf)
//
fun
loop
{l:addr}
{i,j:nat} .<i>.
(
  pf: !parray_v (a, l, i) | p: ptr l, j: size_t j
) :<> size_t (i+j) = let
  val isnot = parray_isnot_empty<a> (pf | p)
in
  if isnot
    then let
      prval parray_v_cons(pf1, pf2) = pf
      val asz = loop (pf2 | ptr_succ<a> (p), j+1)
      prval () = pf := parray_v_cons{a}(pf1, pf2)
    in
      asz
    end // end of [then]
    else (j) // end of [else]
  // end if [if]
end (* end of [loop] *)
//
in
  loop (pf | p, i2sz(0))
end // end of [parray_size]

(* ****** ****** *)

(* end of [parray.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/arith_prf.atxt
** Time of generation: Sat Oct 17 15:19:53 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

primplmnt eqint_make () = EQINT ()

(* ****** ****** *)

primplmnt
mul_gte_gte_gte {m,n} () = let
  prfun loop
    {m:nat}{p:int} .<m>.
    (pf: MUL (m, n, p)):<> [p >= 0] void =
    sif m > 0 then let
      prval MULind (pf1) = pf in loop (pf1)
    end else let
      prval MULbas () = pf in (*nothing*)
    end // end of [sif]
  // end of [loop]
  prval pf = mul_make {m,n} ()
in
  loop {m} (pf)
end // end of [mul_gte_gte_gte]

primplmnt
mul_gte_lte_lte {m,n} () = let
  prfun loop
    {m:nat}{p:int} .<m>.
    (pf: MUL (m, n, p)):<> [p <= 0] void =
    sif m > 0 then let
      prval MULind (pf1) = pf in loop (pf1)
    end else let
      prval MULbas () = pf in (*nothing*)
    end // end of [sif]
  // end of [loop]
  prval pf = mul_make {m,n} ()
in
  loop {m} (pf)
end // end of [mul_gte_lte_lte]

primplmnt
mul_lte_gte_lte {m,n} () = mul_gte_lte_lte {n,m} ()

primplmnt
mul_lte_lte_gte {m,n} () = mul_gte_gte_gte {~m,~n} ()

(* ****** ****** *)

primplmnt
mul_nat_nat_nat
  {m,n} (pf) = let
  prval () = mul_elim (pf)
  prval () = mul_gte_gte_gte {m,n} ()
in
  (*nothing*)
end // end of [mul_nat_nat_nat]

primplmnt
mul_pos_pos_pos
  {m,n} (pf) = let
  prval () = mul_elim (pf)
  prval () = mul_gte_gte_gte {m-1,n-1} ()
in
  (*nothing*)
end // end of [mul_pos_pos_pos]

(* ****** ****** *)

primplmnt
mul_negate {m,n} (pf) = let
  prval () = mul_elim (pf) in mul_make {~m,n} ()
end // end of [mul_negate]

primplmnt
mul_negate2 {m,n} (pf) = let
  prval () = mul_elim (pf) in mul_make {m,~n} ()
end // end of [mul_negate2]

(* ****** ****** *)

primplmnt
mul_commute {m,n} (pf) = let
  prval () = mul_elim (pf) in mul_make {n,m} ()
end // end of [mul_commute]

primplmnt
mul_is_commutative
  (pf1, pf2) = let
  prval () = mul_elim (pf1) and () = mul_elim (pf2)
in
  (*nothing*)
end // end of [mul_commute]

(* ****** ****** *)

primplmnt
mul_distribute
  {m}{n1,n2} (pf1, pf2) = let
  prval () = mul_elim (pf1) and () = mul_elim (pf2)
in
  mul_make {m,n1+n2} ()
end // end of [mul_distribute]

primplmnt
mul_distribute2
  {m1,m2}{n} (pf1, pf2) = let
  prval () = mul_elim (pf1) and () = mul_elim (pf2)
in
  mul_make {m1+m2,n} ()
end // end of [mul_distribute]

(* ****** ****** *)

primplmnt
mul_is_associative
  {x,y,z}{xy,yz}
  (pf1, pf2, pf3, pf4) = {
  prval pf1_alt = mul_make {x,y} ()
  prval EQINT () = mul_isfun2 (pf1, pf1_alt)
  prval pf2_alt = mul_make {y,z} ()
  prval EQINT () = mul_isfun2 (pf2, pf2_alt)
  prval pf3_alt = mul_make {xy,z} ()
  prval EQINT () = mul_isfun2 (pf3, pf3_alt)
  prval pf4_alt = mul_make {x,yz} ()
  prval EQINT () = mul_isfun2 (pf4, pf4_alt)
//
} // end of [mul_is_associative]

(* ****** ****** *)

primplmnt
lemma_exp2_param (pf) = let
  prfun aux
    {n:int}
    {p:int}
    .<max(n,0)>. (
    pf: EXP2 (n, p)
  ) : [n>=0;p>=1] void = case+ pf of
    | EXP2ind (pf1) => aux (pf1) | EXP2bas () => ()
  // end of [aux]
in
  aux (pf)
end // end of [lemma_exp2_param]  

(* ****** ****** *)

primplmnt
exp2_istot {n}
  () = istot {n} () where {
  prfun istot
    {n:nat} .<n>. (): [p:nat] EXP2 (n, p) =
    sif n > 0 then EXP2ind (istot {n-1} ()) else EXP2bas ()
} // end of [exp2_istot]

(* ****** ****** *)

primplmnt
exp2_isfun
  (pf1, pf2) =
  isfun (pf1, pf2) where {
  prfun isfun
    {n:nat} {p1,p2:int} .<n>. (
    pf1: EXP2 (n, p1), pf2: EXP2 (n, p2)
  ) : [p1==p2] void =
    case+ pf1 of
    | EXP2ind pf1 => let
        prval EXP2ind pf2 = pf2 in isfun (pf1, pf2)
      end // end of [EXP2ind]
    | EXP2bas () => let
        prval EXP2bas () = pf2 in (* nothing *)
      end // end of [EXP2bas]
  // end of [isfun]
} // end of [exp2_isfun]

(* ****** ****** *)

primplmnt
exp2_is_mono
  (pf1, pf2) =
  aux (pf1, pf2) where {
  prfun aux
    {n1:nat;n2:int | n1 <= n2}
    {p1,p2:int} .<n2>. (
    pf1: EXP2 (n1, p1), pf2: EXP2 (n2, p2)
  ) : [p1 <= p2] void =
    case+ pf2 of
    | EXP2ind (pf2) => (case+ pf1 of
      | EXP2ind (pf1) => aux (pf1, pf2) | EXP2bas () => aux (pf1, pf2)
      ) // end of [EXP2ind]
    | EXP2bas () => let prval EXP2bas () = pf1 in () end
  // end of [aux]
} // end of [exp2_is_mono]

(* ****** ****** *)

primplmnt
exp2_muladd
  (pf1, pf2, pf3) = let
  prfun aux
    {n1,n2:nat}
    {p1,p2:int}
    {p:int} .<n2>. (
    pf1: EXP2 (n1, p1)
  , pf2: EXP2 (n2, p2)
  , pf3: MUL (p1, p2, p)
  ) : [p>=0] EXP2 (n1+n2, p) = case+ pf2 of
    | EXP2ind {n21} {p21} (pf21) => let // n2 = n21+1; p2 = p21 + p21
        prval pf31 = mul_istot {p1,p21} ()
        prval pf32 = mul_distribute (pf31, pf31)
        prval () = mul_isfun (pf3, pf32)
        prval pf1_res = aux (pf1, pf21, pf31)
      in
        EXP2ind pf1_res
      end // end of [EXP2ind]
    | EXP2bas () => let
        prval () =
          lemma_exp2_param (pf1)
        prval () = mul_elim (pf3) in pf1
      end // end of [EXP2bas]
  // end of [aux]
in
  aux (pf1, pf2, pf3)
end // end of [exp2_muladd]

(* ****** ****** *)

(* end of [arith_prf.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement{a}
glt_val_val (x, y) = gcompare_val_val<a> (x, y) < 0
implement{a}
glte_val_val (x, y) = gcompare_val_val<a> (x, y) <= 0
implement{a}
ggt_val_val (x, y) = gcompare_val_val<a> (x, y) > 0
implement{a}
ggte_val_val (x, y) = gcompare_val_val<a> (x, y) >= 0

(* ****** ****** *)

implement{a}
glt_val_int (x, y) = glt_val_val<a> (x, gnumber_int<a>(y))
implement{a}
glte_val_int (x, y) = glte_val_val<a> (x, gnumber_int<a>(y))
implement{a}
ggt_val_int (x, y) = ggt_val_val<a> (x, gnumber_int<a>(y))
implement{a}
ggte_val_int (x, y) = ggte_val_val<a> (x, gnumber_int<a>(y))

(* ****** ****** *)

implement{a}
geq_val_val (x, y) = gcompare_val_val<a> (x, y) = 0
implement{a}
gneq_val_val (x, y) = gcompare_val_val<a> (x, y) != 0

(* ****** ****** *)

implement{a}
geq_val_int (x, y) = geq_val_val<a> (x, gnumber_int<a>(y))
implement{a}
gneq_val_int (x, y) = gneq_val_val<a> (x, gnumber_int<a>(y))

(* ****** ****** *)

implement{a}
gisltz_val (x) = glt_val_int<a> (x, 0)
implement{a}
gisltez_val (x) = glte_val_int<a> (x, 0)
implement{a}
gisgtz_val (x) = ggt_val_int<a> (x, 0)
implement{a}
gisgtez_val (x) = ggte_val_int<a> (x, 0)

(* ****** ****** *)

implement{a}
giseqz_val (x) = geq_val_int<a> (x, 0)
implement{a}
gisneqz_val (x) = gneq_val_int<a> (x, 0)

(* ****** ****** *)

implement{a}
glt_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) < 0
implement{a}
glte_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) <= 0
implement{a}
ggt_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) > 0
implement{a}
ggte_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) >= 0

(* ****** ****** *)

implement{a}
geq_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) = 0
implement{a}
gneq_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) != 0

(* ****** ****** *)

implement(a:t0p)
gcompare_ref_ref<a> (x, y) = gcompare_val_val<a> (x, y)

(* ****** ****** *)

implement{a}
gabs_val (x) =
  if gisgtez_val (x) then x else gneg_val<a> (x)
// end of [gabs_val]

(* ****** ****** *)

implement{a}
gmax_val_val (x, y) = if ggte_val_val (x, y) then x else y
implement{a}
gmin_val_val (x, y) = if glte_val_val (x, y) then x else y

(* ****** ****** *)

#include "./SHARE/gorder_int.dats"
#include "./SHARE/gorder_uint.dats"

(* ****** ****** *)

#include "./SHARE/gorder_bool.dats"
#include "./SHARE/gorder_char.dats"

(* ****** ****** *)

#include "./SHARE/gorder_float.dats"

(* ****** ****** *)

#include "./SHARE/gorder_string.dats"

(* ****** ****** *)

(* end of [gorder.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/grandom.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: June, 2015 *)

(* ****** ****** *)

implement{} grandom_int() = 0
implement{} grandom_uint() = 0u

(* ****** ****** *)

implement{} grandom_bool() = false

(* ****** ****** *)

implement{} grandom_float() = 0.0f
implement{} grandom_double() = 0.0

(* ****** ****** *)

implement
grandom_val<int> () = grandom_int<> ()
implement
grandom_val<uint> () = grandom_uint<> ()

(* ****** ****** *)

implement
grandom_val<bool> () = grandom_bool<> ()

(* ****** ****** *)

implement
grandom_val<double> () = grandom_double<> ()

(* ****** ****** *)

implement
{a}(*tmp*)
grandom_ref(x) = (x := grandom_val<a> ())

(* ****** ****** *)
//
implement
{a}(*tmp*)
grandom_list
  (n) = list_vt2t(grandom_list_vt<a>(n))
//
implement
{a}(*tmp*)
grandom_list_vt
  (n) = res where
{
//
fun loop
  {n:nat} .<n>.
(
  n: int n, res: &ptr? >> list_vt (a, n)
) : void = let
in
//
if n > 0 then let
//
val () =
  res := cons_vt{a}{0} (_, _)
// end of [val]
val+list_vt_cons (x, res1) = res
val () = grandom_ref<a> (x)
val () = loop (pred (n), res1)
//
in
  fold@ (res)
end else res := nil_vt((*void*))
//
end // end of [loop]
//
var res: ptr // uninitialized
val () = loop (n, res)
//
} (* end of [grandom_list_vt] *)
//
(* ****** ****** *)

implement
{a}(*tmp*)
grandom_arrayptr
  (n) = A where {
//
val A =
  arrayptr_make_uninitized<a> (n)
//
implement
array_initize$init<a> (_, x) = grandom_ref<a> (x)
//
prval pf = arrayptr_takeout (A)
val () = array_initize<a> (!(ptrcast(A)), n)
prval () = arrayptr_addback (pf | A)
//
} (* end of [grandom_arrayptr] *)

implement
{a}(*tmp*)
grandom_arrayref (n) =
  arrayptr_refize(grandom_arrayptr<a> (n))
// end of [grandom_arrayref]

implement
{a}(*tmp*)
grandom_arrszref (n) = let
  val n = g1ofg0_uint (n) in
  arrszref_make_arrayref (grandom_arrayref<a> (n), n)
end // end of [grandom_arrszref]

(* ****** ****** *)

(* end of [grandom.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list.atxt
** Time of generation: Sun Oct 18 14:27:09 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: July, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)
//
implement
{a}(*tmp*)
stream_sing(x) =
  stream_cons{a}(x, $delay(stream_nil))
//
(* ****** ****** *)

implement
{a}(*tmp*)
stream2list (xs) = let
//
fun loop
(
  xs: stream (a), res: &ptr? >> List0_vt (a)
) : void = let
in
  case+ !xs of
  | stream_cons
      (x, xs) => let
      val () =
      res := list_vt_cons{a}{0}(x, _)
      val+list_vt_cons (_, res1) = res
      val ((*void*)) = loop (xs, res1)
    in
      fold@ (res)
    end // end of [stream_cons]
  | stream_nil () => res := list_vt_nil ()
end // end of [loop]
var res: ptr // uninitialized
val () = $effmask_all (loop (xs, res))
//
in
  res
end // end of [stream2list]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_nth_exn
  (xs, n) = let
in
  case+ !xs of
  | stream_cons
      (x, xs) =>
    (
      if n > 0
        then stream_nth_exn<a> (xs, pred(n)) else (x)
      // end of [if]
    )
  | stream_nil () => $raise StreamSubscriptExn()
end // end of [stream_nth_exn]

implement
{a}(*tmp*)
stream_nth_opt
  (xs, n) = let
in
  try Some_vt(stream_nth_exn<a> (xs, n)) with ~StreamSubscriptExn() => None_vt()
end // end of [stream_nth_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_take_exn
  (xs, n) = let
//
fun loop{n:nat}
(
  xs: stream a, res: &ptr? >> list_vt (a, n-k), n: int n
) : #[k:nat | k <= n] int k =
  if n > 0 then (
    case+ !xs of
    | stream_cons
        (x, xs) => let
        val () =
        res := list_vt_cons{a}{0}(x, _)
        val+list_vt_cons (_, res1) = res
        val k = loop (xs, res1, pred(n))
        prval () = fold@ (res)
      in
        k
      end // end of [stream_cons]
    | stream_nil () => let
        val () = res := list_vt_nil () in n
      end // end of [stream_nil]
  ) else let
    val () = res := list_vt_nil () in n
  end // end of [if]
//
var res: ptr // uninitialized
val k = $effmask_all (loop (xs, res, n))
//
in
//
$effmask_all (
if k = 0 then res else let
  val () = list_vt_free (res) in $raise StreamSubscriptExn()
end // end of [if]
) // end of [$effmask_all]
//
end // end of [stream_take_exn]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_drop_exn
  (xs, n) = let
in
//
if n > 0 then
(
  case+ !xs of
  | stream_cons
      (_, xs) => stream_drop_exn (xs, pred(n))
  | stream_nil () => $raise StreamSubscriptExn()
) else (xs) // end of [if]
//
end // end of [stream_drop_exn]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_append
  (xs, ys) = let
//
fun aux
(
  xs: stream(a)
, ys: stream(a)
) : stream_con(a) =
  case+ !xs of
  | stream_nil () => !ys
  | stream_cons (x, xs) => stream_cons (x, $delay (aux (xs, ys)))
//
in
//
  $delay (aux (xs, ys))
//
end // end of [stream_append]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_concat (xss) = let
//
fun aux1
(
  xss: stream(stream(a))
) : stream_con(a) =
(
  case+ !xss of
  | stream_nil () => stream_nil ()
  | stream_cons (xs, xss) => aux2 (xs, xss)
)
and aux2
(
  xs: stream(a), xss: stream(stream(a))
) : stream_con(a) =
  case+ !xs of
  | stream_nil () => aux1 (xss)
  | stream_cons (x, xs) => stream_cons (x, $delay (aux2 (xs, xss)))
//
in
  $delay (aux1 (xss))
end // end of [stream_concat]

(* ****** ****** *)

local

fun{a:t0p}
stream_filter_con
  (xs: stream a): stream_con(a) = let
in
//
case+ !xs of
| stream_cons
    (x, xs) =>
  (
    if stream_filter$pred<a> (x)
      then stream_cons{a}(x, stream_filter<a> (xs)) else stream_filter_con<a> (xs)
    // end of [if]
  ) // end of [stream_cons]
| stream_nil () => stream_nil ()
//
end // end of [stream_filter_con]

in (* in of [local] *)

implement
{a}(*tmp*)
stream_filter (xs) =
  $delay (stream_filter_con<a> (xs))
// end of [stream_filter]

implement
{a}(*tmp*)
stream_filter_fun
  (xs, p) = let
//
implement{a2}
stream_filter$pred (x) = p($UN.cast{a}(x))
//
in
  stream_filter (xs)
end // end of [stream_filter_fun]

implement
{a}(*tmp*)
stream_filter_cloref (xs, p) = let
//
implement{a2}
stream_filter$pred (x) = p($UN.cast{a}(x))
//
in
  stream_filter (xs)
end // end of [stream_filter_cloref]

end // end of [local]

(* ****** ****** *)

implement
{a}{b}
stream_map
  (xs) = let
//
fun aux
(
  xs: stream (a)
) :<!laz> stream (b) = $delay
(
case+ !xs of
| stream_nil () => stream_nil ()
| stream_cons (x, xs) =>
    stream_cons{b}(stream_map$fopr<a><b> (x), aux (xs))
  // end of [stream_cons]
) : stream_con (b) // end of [$delay]
//
in
  aux (xs)
end // end of [stream_map]

implement
{a}{b}
stream_map_fun
  (xs, f) = let
//
implement
{a2}{b2}
stream_map$fopr (x) = $UN.cast{b2}(f($UN.cast{a}(x)))
//
in
  stream_map<a><b> (xs)
end // end of [stream_map_fun]

implement
{a}{b}
stream_map_cloref
  (xs, f) = let
//
implement
{a2}{b2}
stream_map$fopr (x) = $UN.cast{b2}(f($UN.cast{a}(x)))
//
in
  stream_map<a><b> (xs)
end // end of [stream_map_cloref]

(* ****** ****** *)

implement
{a}{b}
stream_imap
  (xs) = let
//
fun aux
(
  i: intGte(0), xs: stream (a)
) :<!laz> stream (b) = $delay
(
case+ !xs of
| stream_nil () => stream_nil ()
| stream_cons
    (x, xs) => let
    val y =
      stream_imap$fopr<a><b> (i, x)
    // end of [val]
  in
    stream_cons{b}(y, aux (succ (i), xs))
  end // end of [stream_cons]
) : stream_con (b) // end of [$delay]
//
in
  aux (0, xs)
end // end of [stream_imap]

implement
{a}{b}
stream_imap_fun
  (xs, f) = let
//
implement
{a2}{b2}
stream_imap$fopr
  (i, x) = $UN.cast{b2}(f(i, $UN.cast{a}(x)))
//
in
  stream_imap<a><b> (xs)
end // end of [stream_imap_fun]

implement
{a}{b}
stream_imap_cloref
  (xs, f) = let
//
implement
{a2}{b2}
stream_imap$fopr
  (i, x) = $UN.cast{b2}(f(i, $UN.cast{a}(x)))
//
in
  stream_imap<a><b> (xs)
end // end of [stream_imap_cloref]

(* ****** ****** *)

local

#define :: stream_cons

in (* in of [local] *)

implement
{a1,a2}{b}
stream_map2
(
  xs1, xs2
) = $delay (
(
case+ !xs1 of
| x1 :: xs1 => (
  case+ !xs2 of
  | x2 :: xs2 => let
      val y =
        stream_map2$fopr<a1,a2><b> (x1, x2)
      // end of [val]
    in
      stream_cons{b}(y, stream_map2<a1,a2><b> (xs1, xs2))
    end // end of [::]
  | stream_nil () => stream_nil ()
  ) // end of [::]
| stream_nil () => stream_nil ()
) : stream_con (b)
) // end of [stream_map2]

end // end of [local]

implement
{a1,a2}{b}
stream_map2_fun
  (xs1, xs2, f) = let
//
implement
{a12,a22}{b2}
stream_map2$fopr (x1, x2) =
  $UN.cast{b2}(f($UN.cast{a1}(x1), $UN.cast{a2}(x2)))
//
in
  stream_map2<a1,a2><b> (xs1, xs2)
end // end of [stream_map2_fun]

implement
{a1,a2}{b}
stream_map2_cloref
  (xs1, xs2, f) = let
//
implement
{a12,a22}{b2}
stream_map2$fopr (x1, x2) =
  $UN.cast{b2}(f($UN.cast{a1}(x1), $UN.cast{a2}(x2)))
//
in
  stream_map2<a1,a2><b> (xs1, xs2)
end // end of [stream_map2_cloref]

(* ****** ****** *)

implement
{res}{x}
stream_scan
  (xs, ini) = let
//
fun aux
(
  xs: stream(x), ini: res
) :<!laz> stream (res) = $delay
(
case+ !xs of
| stream_nil
    () => stream_nil ()
  // end of [stream_nil]
| stream_cons(x, xs) =>
  stream_cons{res}
    (stream_scan$fopr<res><x> (ini, x), aux (xs, ini))
  // end of [stream_cons]
) : stream_con(res) // end of [$delay]
//
in
  aux (xs, ini)
end // end of [stream_scan]

(* ****** ****** *)

implement
{res}{x}
stream_scan_fun
  (xs, ini, f) = let
//
implement
{res2}{x2}
stream_scan$fopr
  (ini, x) =
  $UN.cast{res2}(f($UN.cast{res}(ini), $UN.cast{x}(x)))
//
in
  stream_scan<res><x> (xs, ini)
end // end of [stream_scan_fun]

implement
{res}{x}
stream_scan_cloref
  (xs, ini, f) = let
//
implement
{res2}{x2}
stream_scan$fopr
  (ini, x) =
  $UN.cast{res2}(f($UN.cast{res}(ini), $UN.cast{x}(x)))
//
in
  stream_scan<res><x> (xs, ini)
end // end of [stream_scan_cloref]

(* ****** ****** *)

local

#define :: stream_cons

in (* in of [local] *)

implement
{a}(*tmp*)
stream_merge
  (xs10, xs20) = $delay
(
(
case+ !xs10 of
| x1 :: xs1 => (
  case+ !xs20 of
  | x2 :: xs2 => let
      val sgn =
        stream_merge$cmp<a> (x1, x2)
      // end of [val]
    in
      if sgn <= 0 then
        stream_cons{a}(x1, stream_merge (xs1, xs20))
      else
        stream_cons{a}(x2, stream_merge (xs10, xs2))
      // end of [if]
    end // end of [::]
  | stream_nil () => stream_cons{a}(x1, xs1)
  ) (* end of [::] *)
| stream_nil () => !xs20
) : stream_con (a)
) // end of [stream_merge]

end // end of [local]

implement
{a}(*tmp*)
stream_merge_fun
  (xs1, xs2, cmp) = let
//
implement{a2}
stream_merge$cmp (x1, x2) =
  cmp ($UN.cast{a}(x1), $UN.cast{a}(x2))
//
in
  stream_merge (xs1, xs2)
end // end of [stream_merge_fun]

implement
{a}(*tmp*)
stream_merge_cloref
  (xs1, xs2, cmp) = let
//
implement{a2}
stream_merge$cmp (x1, x2) =
  cmp ($UN.cast{a}(x1), $UN.cast{a}(x2))
//
in
  stream_merge (xs1, xs2)
end // end of [stream_merge_cloref]

(* ****** ****** *)
//
implement
{a}(*tmp*)
stream_merge$cmp
  (x1, x2) = gcompare_val_val<a> (x1, x2)
//
(* ****** ****** *)

local

#define :: stream_cons

in (* in of [local] *)

implement
{a}(*tmp*)
stream_mergeq
  (xs10, xs20) = $delay
(
(
case+ !xs10 of
| x1 :: xs1 => (
  case+ !xs20 of
  | x2 :: xs2 => let
      val sgn =
        stream_mergeq$cmp<a> (x1, x2)
      // end of [val]
    in
      if sgn < 0 then
        stream_cons{a}(x1, stream_mergeq (xs1, xs20))
      else if sgn > 0 then
        stream_cons{a}(x2, stream_mergeq (xs10, xs2))
      else
        stream_cons{a}(x1(*=x2*), stream_mergeq (xs1, xs2))
      // end of [if]
    end // end of [::]
  | stream_nil () => stream_cons{a}(x1, xs1)
  ) (* end of [::] *)
| stream_nil () => !xs20
) : stream_con (a)
) // end of [stream_mergeq]

end // end of [local]

implement
{a}(*tmp*)
stream_mergeq_fun
  (xs1, xs2, cmp) = let
//
implement{a2}
stream_mergeq$cmp (x1, x2) =
  cmp ($UN.cast{a}(x1), $UN.cast{a}(x2))
//
in
  stream_mergeq (xs1, xs2)
end // end of [stream_mergeq_fun]

implement
{a}(*tmp*)
stream_mergeq_cloref
  (xs1, xs2, cmp) = let
//
implement{a2}
stream_mergeq$cmp (x1, x2) =
  cmp ($UN.cast{a}(x1), $UN.cast{a}(x2))
//
in
  stream_mergeq (xs1, xs2)
end // end of [stream_mergeq_cloref]

(* ****** ****** *)
//
implement
{a}(*tmp*)
stream_mergeq$cmp
  (x1, x2) = gcompare_val_val<a> (x1, x2)
//
(* ****** ****** *)

implement
{a}(*tmp*)
stream_tabulate () = let
//
fun
aux{n:nat}
(
  n: int(n)
) : stream(a) = $delay
(
  stream_cons{a}(stream_tabulate$fopr<a> (n), aux (n+1))
)
//
in
  aux (0)
end // end of [stream_tabulate]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_tabulate_fun (f) = let
//
implement
{a2}(*tmp*)
stream_tabulate$fopr (n) = $UN.cast{a2}(f(n))
//
in
  stream_tabulate ()
end // end of [stream_tabulate_fun]

implement
{a}(*tmp*)
stream_tabulate_cloref (f) = let
//
implement
{a2}(*tmp*)
stream_tabulate$fopr (n) = $UN.cast{a2}(f(n))
//
in
  stream_tabulate ()
end // end of [stream_tabulate_cloref]

(* ****** ****** *)

implement
{a}{env}
stream_foreach$cont (x, env) = true

implement
{a}(*tmp*)
stream_foreach (xs) = let
  var env: void = () in stream_foreach_env<a><void> (xs, env)
end // end of [stream_foreach]

implement
{a}{env}
stream_foreach_env
  (xs, env) = let
//
fun loop
(
  xs: stream(a), env: &env >> _
) : void =
(
//
case+ !xs of
| stream_nil () => ()
| stream_cons (x, xs) => let
    val test =
      stream_foreach$cont<a><env> (x, env)
    // end of [val]
  in
    if test
      then let
        val () =
          stream_foreach$fwork<a><env> (x, env)
        // end of [val]
      in
        loop (xs, env)
      end // end of [then]
      else () // end of [else]
    // end of [if]
  end // end of [stream_cons]
//
) (* end of [loop] *)
//
in
  loop (xs, env)
end (* end of [stream_foreach_env] *)

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_stream
  (out, xs, n) = let
//
var env: int = 0
typedef tenv = int
//
implement
stream_foreach$cont<a><tenv>
  (x, env) =
  if n > env then true else false
implement
stream_foreach$fwork<a><tenv>
  (x, env) =
{
  val () =
  if env > 0
    then fprint_stream$sep<> (out)
  // end of [if]
  val () = env := env + 1
  val () = fprint_val<a> (out, x)
} (* end of [stream_foreach$fwork] *)
//
in
  stream_foreach_env<a><tenv> (xs, env)
end // end of [fprint_stream]

implement{}
fprint_stream$sep (out) = fprint_string (out, ", ")

(* ****** ****** *)

(* end of [stream.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array.atxt
** Time of generation: Sat Oct 17 15:19:56 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"
staload IT = "prelude/SATS/giterator.sats"

(* ****** ****** *)

macdef castvwtp_trans = $UN.castvwtp0 // former name

(* ****** ****** *)

implement{a}
array_getref_at
  (A, i) = let
  val p = ptr0_add_guint<a> (addr@(A), i) in $UN.cast{cPtr1(a)}(p)
end // end of [array_getref_at]

(* ****** ****** *)

implement{a}{tk}
array_get_at_gint (A, i) = let
  val p = ptr0_add_gint<a> (addr@(A), i) in $UN.ptr0_get<a> (p)
end // end of [array_get_at_gint]
implement{a}{tk}
array_get_at_guint (A, i) = let
  val p = ptr0_add_guint<a> (addr@(A), i) in $UN.ptr0_get<a> (p)
end // end of [array_get_at_guint]

(* ****** ****** *)

implement{a}{tk}
array_set_at_gint (A, i, x) = let
  val p = ptr0_add_gint<a> (addr@(A), i) in $UN.ptr0_set<a> (p, x)
end // end of [array_set_at_uint]
implement{a}{tk}
array_set_at_guint (A, i, x) = let
  val p = ptr0_add_guint<a> (addr@(A), i) in $UN.ptr0_set<a> (p, x)
end // end of [array_set_at_guint]

(* ****** ****** *)

implement{a}{tk}
array_exch_at_gint (A, i, x) = let
  val p = ptr0_add_gint<a> (addr@(A), i) in $UN.ptr0_exch<a> (p, x)
end // end of [array_exch_at_gint]
implement{a}{tk}
array_exch_at_guint (A, i, x) = let
  val p = ptr0_add_guint<a> (addr@(A), i) in $UN.ptr0_exch<a> (p, x)
end // end of [array_exch_at_guint]

(* ****** ****** *)

implement{a}
array_subreverse
  (A, i, j) = let
//
fun
loop
(
  p1: ptr, p2: ptr
) : void =
(
if
p1 < p2
then let
  val x = $UN.ptr0_get<a> (p1)
  val () =
  $UN.ptr0_set<a> (p1, $UN.ptr0_get<a> (p2))
  val () = $UN.ptr0_set<a> (p2, x)
in
  loop (ptr0_succ<a> (p1), ptr0_pred<a> (p2))
end // end of [then]
else () // end of [else]
) (* end of [loop] *)
//
val pA = addr@A
val pi = ptr_add<a> (pA, i)
val pj = ptr_add<a> (pA, j)
//
in
  $effmask_all(loop (pi, ptr0_pred<a> (pj)))
end // end of [array_subreverse]

(* ****** ****** *)

implement{a}
array_interchange
  (A, i, j) = let
in
//
if i != j then let
  val p = addr@(A)
  val pi = ptr0_add_guint<a> (p, i)
  val pj = g1ofg0_ptr (ptr0_add_guint<a> (p, j))
  val (pf, fpf | pj) = $UN.ptr_vtake{a}(pj)
  val () = $UN.ptr0_exch<a> (pi, !pj)
  prval () = fpf (pf)
in
  // nothing
end else () // end of [if]
//
end // end of [array_interchange]

(* ****** ****** *)

implement{a}
array_subcirculate
  (A, i, j) = let
//
extern
fun memmove
(
  dst: ptr, src: ptr, bsz: size_t
) :<!wrt> ptr = "mac#atspre_array_memmove"
//
in
//
if i < j then
{
//
val p0 = ptr_add<a> (addr@(A), i)
val p1 = ptr_add<a> (addr@(A), j)
val A1 = $UN.ptr0_get<a> (p1)
val _(*ptr*) = memmove (ptr_succ<a>(p0), p0, (j-i)*sizeof<a>)
val () = $UN.ptr0_set<a> (p0, A1)
//
} else if i > j then
{
//
val p0 = ptr_add<a> (addr@(A), j)
val p1 = ptr_add<a> (addr@(A), i)
val A0 = $UN.ptr0_get<a> (p0)
val _(*ptr*) = memmove (p0, ptr_succ<a>(p0), (i-j)*sizeof<a>)
val () = $UN.ptr0_set<a> (p1, A0)
//
} else () // end of [if]
//
end // end of [array_subcirculate]

(* ****** ****** *)

implement{a}
array_ptr_takeout
  {l}{n}{i}(pf | p, i) = let
  prval (pf, fpf) =
    array_v_takeout {a}{l}{n}{i} (pf)
  // end of [prval]
in
  (pf, fpf | ptr1_add_guint<a> (p, i))
end // end of [array_ptr_takeout]

(* ****** ****** *)

implement{a}
array_ptr_alloc
  {n} (asz) = let
  val [l:addr] (
    pf, pfgc | p
  ) = malloc_gc (asz * sizeof<a>)
  prval pf =
    __assert (pf) where {
    extern praxi __assert
      (pf: b0ytes (n*sizeof(a)) @ l): array_v (a?, l, n)
    // end of [__assert]
  } // end of [where] // end of [prval]
in
  (pf, pfgc | p)
end // end of [array_ptr_alloc]

(* ****** ****** *)

implement{}
array_ptr_free
  {a}{l}{n}
  (pf, pfgc | p) = let
  prval pf =
    __assert (pf) where {
    extern praxi __assert
      (pf: array_v (a?, l, n)): b0ytes (n*sizeof(a)) @ l
    // end of [__assert]
  } // end of [where] // end of [prval]
in
  mfree_gc (pf, pfgc | p)
end // end of [array_ptr_free]

(* ****** ****** *)

implement{a}
array_ptr_tabulate (asz) = let
//
val
(
  pf, pfgc | p
) = array_ptr_alloc<a> (asz)
//
local
implement{a}
array_initize$init (i, x) = x := array_tabulate$fopr<a> (i)
in (*in of [local]*)
val () = array_initize<a> (!p, asz)
end // end of [local]
//
in
  @(pf, pfgc | p)
end // end of [array_ptr_tabulate]

(* ****** ****** *)

implement{a}
fprint_array_int
  (out, A, asz) = let
//
prval () = lemma_array_param (A)
//
in
  fprint_array_size (out, A, i2sz(asz))
end // end of [fprint_array_int]

implement{a}
fprint_array_size
  (out, A, asz) = let
//
typedef tenv = int
//
implement
array_foreach$fwork<a><tenv>
  (x, env) = let
  val n = env
  val () = if n > 0 then fprint_array$sep<> (out)
  val () = env := n + 1
in
  fprint_ref<a> (out, x)
end // end of [array_foreach$fwork]
//
var env: tenv = 0
val _(*n*) = array_foreach_env<a><tenv> (A, asz, env)
//
in
  // nothing
end // end of [fprint_array_size]

(* ****** ****** *)

implement{}
fprint_array$sep (out) = fprint (out, ", ")

(* ****** ****** *)

implement{a}
fprint_array_sep
  (out, A, asz, sep) = let
//
implement
fprint_array$sep<> (out) = fprint (out, sep)
//
in
  fprint_array<a> (out, A, asz)
end // end of [fprint_array_sep]

(* ****** ****** *)

implement
{a}(*tmp*)
array_copy
  {n} (to, from, n) = let
//
val p_to = addr@(to) and p_from = addr@(from)
//
val _ =
$extfcall
(
  ptr, "atspre_array_memcpy", p_to, p_from, n*sizeof<a>
) (* end of [val] *)
//
extern
praxi __assert {l1,l2:addr}
(
  pf1: !array_v (a?, l1, n) >> array_v (a  , l1, n)
, pf2: !array_v (a , l2, n) >> array_v (a?!, l2, n)
) : void // end of [__assert]
//
prval () = __assert (view@ (to), view@ (from))
//
in
  // nothing
end // end of [array_copy]

(* ****** ****** *)

implement{a}
array_copy_from_list
  (A, xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n)
| p: ptr l, xs: list (a, n)
) :<!wrt> void = (
  case+ xs of
  | list_cons (x, xs) => let
      prval (pf1, pf2) = array_v_uncons (pf)
      val () = !p := x
      val () = loop (pf2 | ptr1_succ<a> (p), xs)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => let
      prval () = pf := array_v_unnil_nil (pf)
    in
      // nothing
    end // end of [list_nil]
) (* end of [loop] *)
//
in
  loop (view@(A) | addr@(A), xs)
end // end of [array_copy_from_list]

(* ****** ****** *)

implement{a}
array_copy_from_list_vt
  (A, xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n)
| p: ptr l, xs: list_vt (a, n)
) :<!wrt> void = (
  case+ xs of
  | ~list_vt_cons (x, xs) => let
      prval (pf1, pf2) = array_v_uncons (pf)
      val () = !p := x
      val () = loop (pf2 | ptr1_succ<a> (p), xs)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      // nothing
    end // end of [list_vt_cons]
  | ~list_vt_nil () => let
      prval () = pf := array_v_unnil_nil (pf)
    in
      // nothing
    end // end of [list_vt_nil]
) (* end of [loop] *)
//
in
  loop (view@(A) | addr@(A), xs)
end // end of [array_copy_from_list_vt]

(* ****** ****** *)

implement{a}
array_copy_to_list_vt
  (A, n) = res where {
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a, l, n) >> array_v (a?!, l, n)
| p: ptr l, n: size_t n, res: &ptr? >> list_vt (a, n)
) :<!wrt> void = (
  if n > 0 then let
    prval (pf1, pf2) = array_v_uncons (pf)
    val () = res := list_vt_cons {a}{0} (!p, _)
    val+list_vt_cons (_, res1) = res
    val () = loop (pf2 | ptr1_succ<a> (p), pred(n), res1)
    prval () = pf := array_v_cons (pf1, pf2)
    prval () = fold@ (res)
  in
    // nothing
  end else let
    prval () = pf := array_v_unnil_nil (pf)
  in
    res := list_vt_nil ()
  end // end of [if]
) (* end of [loop] *)
//
var res: ptr
val () = loop (view@(A) | addr@(A), n, res)
//
} // end of [array_copy_to_list_vt]

(* ****** ****** *)

implement{a}
array_foreach
  (A, asz) = let
  var env: void = ()
in
  array_foreach_env<a><void> (A, asz, env)
end // end of [array_foreach]

implement
{a}{env}
array_foreach_env
  {n0} (A, asz, env) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}
  {n:nat | n <= n0} .<n>.
(
  pf: !array_v (a, l, n)
| p: ptr l, n: size_t n, env: &env
) : sizeLte (n0) = let
in
//
if n > 0 then let
  prval
  (
    pf1, pf2
  ) = array_v_uncons (pf)
  val cont = array_foreach$cont<a><env> (!p, env)
in
  if cont then let
    val () = array_foreach$fwork<a><env> (!p, env)
    val res = loop (pf2 | ptr1_succ<a> (p), pred(n), env)
    prval () = pf := array_v_cons (pf1, pf2)
  in
    res
  end else let
    prval () = pf := array_v_cons (pf1, pf2) in n
  end (* end of [if] *)
end else n(*0*)
//
end // end of [loop]
//
val p_beg = addr@(A)
val n = loop (view@(A) | p_beg, asz, env)
//
in
  asz - n
end // end of [array_foreach_env]

(* ****** ****** *)

implement{a}{env}
array_foreach$cont (x, env) = true
(*
implement{a}{env}
array_foreach$fwork (x, env) = ((*void*))
*)

(* ****** ****** *)

implement{a}
array_foreach_fun
  {n}{fe} (A, asz, f) = let
  typedef tfun = (!unit_v | &a, !ptr) -<fun,fe> void
  val f = $UN.cast{tfun} (f)
  prval pfu = unit_v ()
  var env: ptr = the_null_ptr
  val () = array_foreach_funenv<a> (pfu | A, asz, f, env)
  prval () = unit_v_elim (pfu)
in
  // nothing
end // end of [array_foreach_fun]

implement{a}
array_foreach_cloref
  {n}{fe} (A, asz, f) = let
//
  viewdef v = unit_v
  typedef vt = (&a) -<cloref,fe> void
//
  fun app .<>. (pf: !v | x: &a, env: !vt):<fe> void = env (x)
  prval pfu = unit_v ()
  var env = f
  val () = array_foreach_funenv<a> {v}{vt} (pfu | A, asz, app, env)
  prval () = unit_v_elim (pfu)
in
  // nothing
end // end of [array_foreach_cloref]

(* ****** ****** *)

implement{a}
array_foreach_funenv
  {v}{vt}
(
  pf | A, asz, f, env
) =
  array_foreach_funenv_tsz{a}{v}{vt} (pf | A, asz, sizeof<a>, f, env)
// end of [array_foreach_funenv]

(* ****** ****** *)

implement
{a1,a2}(*tmp*)
array_foreach2
  (A1, A2, asz) = let
  var env: void = ()
in
  array_foreach2_env<a1,a2><void> (A1, A2, asz, env)
end // end of [array_foreach2]

implement
{a1,a2}{env}
array_foreach2_env
  {n0} (A1, A2, asz, env) = let
//
prval () = lemma_array_param (A1)
//
fun loop
  {l1,l2:addr}
  {n:nat | n <= n0} .<n>. (
  pf1: !array_v (a1, l1, n)
, pf2: !array_v (a2, l2, n)
| p1: ptr l1, p2: ptr l2, n: size_t n, env: &env
) : sizeLte (n0) = let
in
  if n > 0 then let
    prval (pf11, pf12) = array_v_uncons (pf1)
    prval (pf21, pf22) = array_v_uncons (pf2)
    val cont = array_foreach2$cont<a1,a2><env> (!p1, !p2, env)
  in
    if cont then let
      val () = array_foreach2$fwork<a1,a2><env> (!p1, !p2, env)
      val res = loop (
        pf12, pf22 | ptr1_succ<a1> (p1), ptr1_succ<a2> (p2), pred(n), env
      ) // end of [val]
      prval () = pf1 := array_v_cons (pf11, pf12)
      prval () = pf2 := array_v_cons (pf21, pf22)
    in
      res
    end else let
      prval () = pf1 := array_v_cons (pf11, pf12)
      prval () = pf2 := array_v_cons (pf21, pf22) in n
    end (* end of [if] *)
  end else n(*0*)
end // end of [loop]
//
val p1_beg = addr@(A1)
val p2_beg = addr@(A2)
val n = loop (view@(A1), view@(A2) | p1_beg, p2_beg, asz, env)
//
in
  asz - n
end // end of [array_foreach2_env]

(* ****** ****** *)

implement
{a1,a2}{env}
array_foreach2$cont (x1, x2, env) = true
(*
implement
{a1,a2}{env}
array_foreach2$fwork (x1, x2, env) = ((*void*))
*)

(* ****** ****** *)

implement{a}
array_iforeach
  (A, asz) = let
  var env: void = ()
in
  array_iforeach_env<a><void> (A, asz, env)
end // end of [array_iforeach]

implement
{a}{env}
array_iforeach_env
  {n0} (A, asz, env) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}
  {n:nat | n <= n0} .<n>. (
  pf: !array_v (a, l, n)
| i: size_t, p: ptr l, n: size_t n, env: &env
) : sizeLte (n0) = let
in
//
if n > 0 then let
  prval (
    pf1, pf2
  ) = array_v_uncons (pf)
  val cont = array_iforeach$cont<a><env> (i, !p, env)
in
  if cont then let
    val () = array_iforeach$fwork<a><env> (i, !p, env)
    val res = loop (pf2 | succ(i), ptr1_succ<a> (p), pred(n), env)
    prval () = pf := array_v_cons (pf1, pf2)
  in
    res
  end else let
    prval () = pf := array_v_cons (pf1, pf2) in n
  end (* end of [if] *)
end else n(*0*)
//
end // end of [loop]
//
val p_beg = addr@(A)
val n = loop (view@(A) | g0int2uint(0), p_beg, asz, env)
//
in
  asz - n
end // end of [array_iforeach_env]

(* ****** ****** *)

implement{a}{env}
array_iforeach$cont (i, x, env) = true
(*
implement{a}{env}
array_iforeach$fwork (i, x, env) = ((*void*))
*)

(* ****** ****** *)

implement{a}
array_rforeach
  (A, asz) = let
  var env: void = ()
in
  array_rforeach_env<a><void> (A, asz, env)
end // end of [array_rforeach]

implement
{a}{env}
array_rforeach_env
  {n0} (A, asz, env) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}
  {n:nat | n <= n0} .<n>.
(
  pf: !array_v (a, l, n)
| p: ptr (l+n*sizeof(a)), n: size_t n, env: &env
) : sizeLte (n0) = let
in
//
if n > 0 then let
  prval
  (
    pf1, pf2
  ) = array_v_unextend (pf)
  val p1 = ptr1_pred<a> (p)
  val (pf2 | p1) = viewptr_match (pf2 | p1)
  val cont = array_rforeach$cont<a><env> (!p1, env)
in
  if cont then let
    val () = array_rforeach$fwork<a><env> (!p1, env)
    val res = loop (pf1 | p1, pred(n), env)
    prval () = pf := array_v_extend (pf1, pf2)
  in
    res
  end else let
    prval () = pf := array_v_extend (pf1, pf2) in n
  end (* end of [if] *)
end else n (*0*)
//
end // end of [loop]
//
val p_end =
  ptr1_add_guint<a> (addr@(A), asz)
val n = loop (view@(A) | p_end, asz, env)
//
in
  asz - n
end // end of [array_rforeach_env]

(* ****** ****** *)

implement{a}{env}
array_rforeach$cont (x, env) = true
(*
implement{a}{env}
array_rforeach$fwork (x, env) = ((*void*))
*)

(* ****** ****** *)

implement{a}
array_initize
  (A, asz) = let
//
stadef V = array_v
//
fun loop
  {l:addr}{n:nat} .<n>.
(
  pf: !V (a?, l, n) >> V (a, l, n)
| p: ptr l, n: size_t n, i: size_t
) : void =
(
if n > 0 then let
  prval (pf1, pf2) = array_v_uncons (pf)
  val () = array_initize$init<a> (i, !p)
  val () = loop (pf2 | ptr1_succ<a> (p), pred(n), succ(i))
  prval () = pf := array_v_cons{a}(pf1, pf2)
in
  // nothing
end else let
  prval () = pf := array_v_unnil_nil (pf)
in
  // nothing
end // end of [if]
) (* end of [loop] *)
//
prval () = lemma_g1uint_param (asz)
//
in
  loop (view@ (A) | addr@ (A), asz, g0int2uint(0))
end // end of [array_initize]

(* ****** ****** *)

implement{a}
array_initize_elt
  (A, asz, elt) = let
//
implement{a2}
array_initize$init
  (i, xi) = xi := $UN.castvwtp0{a2}(elt)
//
in
  $effmask_all (array_initize<a> (A, asz))
end // end of [array_initize_elt]

(* ****** ****** *)

implement{a}
array_initize_list
  {n} (A, asz, xs) = let
//
typedef list0 = listGte (a, 0)
typedef list1 = listGte (a, 1)
//
fun loop
(
  p: ptr, p1: ptr, xs: list0
) : void = let
in
//
if p < p1 then let
  val xs =
    $UN.cast{list1}(xs)
  val+list_cons (x, xs) = xs
  val () = $UN.ptr0_set<a> (p, x)
  val p = ptr_succ<a> (p)
in
  loop (p, p1, xs)
end else () // end of [if]
//
end // end of [loop]
//
prval () = lemma_list_param (xs)
//
val p = addr@(A)
val p1 = ptr_add<a> (p, asz)
val () = $effmask_all(loop (p, p1, xs))
//
prval (
) = __assert (A) where
{
extern praxi __assert (A: &array(a?, n) >> array(a, n)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [array_initize_list]

(* ****** ****** *)

implement{a}
array_initize_rlist
  {n} (A, asz, xs) = let
//
typedef list0 = listGte (a, 0)
typedef list1 = listGte (a, 1)
//
fun loop
(
  p: ptr, p0: ptr, xs: list0
) : void = let
in
//
if p > p0 then let
  val xs =
    $UN.cast{list1}(xs)
  val+list_cons (x, xs) = xs
  val p = ptr_pred<a> (p)
  val () = $UN.ptr0_set<a> (p, x)
in
  loop (p, p0, xs)
end else () // end of [if]
//
end // end of [loop]
//
prval () = lemma_list_param (xs)
//
val p0 = addr@(A)
val p = ptr_add<a> (p0, asz)
val () = $effmask_all(loop (p, p0, xs))
//
prval (
) = __assert (A) where
{
extern
praxi __assert (A: &array(a?, n) >> array(a, n)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [array_initize_rlist]

(* ****** ****** *)

implement{a}
array_initize_list_vt
  {n} (A, asz, xs) = let
//
vtypedef list0 = listGte_vt (a, 0)
vtypedef list1 = listGte_vt (a, 1)
//
fun loop
(
  p: ptr, p1: ptr, xs: list0
) : void = let
in
//
if p < p1 then let
  val xs =
    $UN.castvwtp0{list1}(xs)
  val+~list_vt_cons (x, xs) = xs
  val () = $UN.ptr0_set<a> (p, x)
  val p = ptr_succ<a> (p)
in
  loop (p, p1, xs)
end else let
  prval () = $UN.cast2void (xs) in (*nothing*)
end // end of [if]
//
end // end of [loop]
//
prval () = lemma_list_vt_param (xs)
//
val p = addr@(A)
val p1 = ptr_add<a> (p, asz)
val () = $effmask_all(loop (p, p1, xs))
//
prval (
) = __assert (A) where
{
extern
praxi __assert (A: &array(a?, n) >> array(a, n)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [array_initize_list_vt]

(* ****** ****** *)

implement{a}
array_initize_rlist_vt
  {n} (A, asz, xs) = let
//
vtypedef list0 = listGte_vt (a, 0)
vtypedef list1 = listGte_vt (a, 1)
//
fun loop
(
  p: ptr, p0: ptr, xs: list0
) : void = let
in
//
if p > p0 then let
  val xs =
    $UN.castvwtp0{list1}(xs)
  val+~list_vt_cons (x, xs) = xs
  val p = ptr_pred<a> (p)
  val () = $UN.ptr0_set<a> (p, x)
in
  loop (p, p0, xs)
end else let
  prval () = $UN.cast2void (xs) in (*nothing*)
end // end of [if]
//
end // end of [loop]
//
prval () = lemma_list_vt_param (xs)
//
val p0 = addr@(A)
val p = ptr_add<a> (p0, asz)
val () = $effmask_all(loop (p, p0, xs))
//
prval (
) = __assert (A) where
{
extern
praxi __assert (A: &array(a?, n) >> array(a, n)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [array_initize_rlist_vt]

(* ****** ****** *)

implement{a}
array_uninitize
  (A, asz) = let
//
fun loop
  {l:addr}{n:nat} .<n>.
(
  pf: !array_v (a, l, n) >> array_v (a?, l, n) | p: ptr l, n: size_t n, i: size_t
) : void = let
in
//
if n > 0 then let
  prval (pf1, pf2) = array_v_uncons (pf)
  val () = array_uninitize$clear<a> (i, !p)
  val () = loop (pf2 | ptr_succ<a> (p), pred (n), succ (i))
  prval () = pf := array_v_cons (pf1, pf2)
in
  // nothing
end else let
  prval () = pf := array_v_unnil_nil {a,a?} (pf)
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
prval () = lemma_array_param (A)
//
prval pf = view@ (A)
val () = loop (pf | addr@ (A), asz, i2sz(0))
prval () = view@ (A) := pf
//
in
  // nothing  
end // end of [array_uninitize]

(* ****** ****** *)

implement
{a}{b}
array_mapto
  {n}(A, B, n) = let
//
val pa = addr@ (A)
val pa2 = ptr_add<a> (pa, n)
val pb = addr@ (B)
//
fun loop{la,lb:addr}
(
  pa: ptr la, pa2: ptr, pb: ptr lb
) : void =
(
if pa < pa2 then let
  val (pfa, fpfa | pa) = $UN.ptr_vtake{a}(pa)
  val (pfb, fpfb | pb) = $UN.ptr_vtake{b?}(pb)
  val () = array_mapto$fwork<a><b> (!pa, !pb)
  prval () = fpfa (pfa)
  prval () = fpfb ($UN.castview0{(b?)@lb}(pfb))
in
  loop (ptr_succ<a> (pa), pa2, ptr_succ<b> (pb))
end (* end of [if] *)
)
//
val () = loop (pa, pa2, pb)
prval [lb:addr] EQADDR () = ptr_get_index (pb)
prval () = view@(B) := $UN.castview0{array_v (b, lb, n)}(view@(B))
//
in
  // nothing
end (* end of [array_mapto] *)

(* ****** ****** *)

implement
{a,b}{c}
array_map2to
  {n}(A, B, C, n) = let
//
val pa = addr@ (A)
val pa2 = ptr_add<a> (pa, n)
val pb = addr@ (B)
val pc = addr@ (C)
//
fun loop{la,lb,lc:addr}
(
  pa: ptr la, pa2: ptr, pb: ptr lb, pc: ptr lc
) : void =
(
if pa < pa2 then let
  val (pfa, fpfa | pa) = $UN.ptr_vtake{a}(pa)
  val (pfb, fpfb | pb) = $UN.ptr_vtake{b}(pb)
  val (pfc, fpfc | pc) = $UN.ptr_vtake{c?}(pc)
  val () = array_map2to$fwork<a,b><c> (!pa, !pb, !pc)
  prval () = fpfa (pfa)
  prval () = fpfb (pfb)
  prval () = fpfc ($UN.castview0{(c?)@lc}(pfc))
in
  loop (ptr_succ<a> (pa), pa2, ptr_succ<b> (pb), ptr_succ<c> (pc))
end (* end of [if] *)
)
//
val () = loop (pa, pa2, pb, pc)
prval [lc:addr] EQADDR () = ptr_get_index (pc)
prval () = view@(C) := $UN.castview0{array_v (c, lc, n)}(view@(C))
//
in
  // nothing
end (* end of [array_map2to] *)

(* ****** ****** *)

(*
implement{a}
array_bsearch
  (A, n) = $effmask_all let
//
val itr =
  $IT.giter_make_array (view@(A) | addr@(A), n)
// end of [val]
implement
$IT.giter_bsearch$ford<a> (x) = array_bsearch$ford<a> (x)
val () = $IT.giter_bsearch (itr, n)
//
val ofs = $IT.giter_get_fofs (itr)
//
val (pf | ()) = $IT.giter_free_array (itr)
prval () = view@ (A) := pf
//
in
  ofs
end // end of [array_bsearch]
*)

(* ****** ****** *)

implement{a}
array_permute (A, asz) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat} .<n>.
(
  pf: !array_v (a, l, n) | p: ptr l, n: size_t n
) : void = let
in
//
if n >= 2 then let
  val i = array_permute$randint<> (n)
  prval (pf1, pf2) = array_v_uncons (pf)
  val () = if i > 0 then $UN.ptr0_exch<a> (ptr0_add_guint<a> (p, i), !p)
  val () = loop (pf2 | ptr1_succ<a> (p), pred (n))
  prval () = pf := array_v_cons (pf1, pf2)
in
  // nothing
end else () // end of [if]
//
end // end of [loop]
//
in
  loop (view@ (A) | addr@ (A), asz)
end // end of [array_permute]

(* ****** ****** *)

#include "./SHARE/array_bsearch.dats"
#include "./SHARE/array_quicksort.dats"

(* ****** ****** *)

(* end of [array.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/tostring.atxt
** Time of generation: Sat Oct 17 15:19:58 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxiATgmailDOTcom *)
(* Start time: April, 2015 *)

(* ****** ****** *)
//
staload
UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)

implement
{}(*tmp*)
tostring_int(i) = 
$effmask_wrt
(
  strptr2string(tostrptr_int(i))
)
implement
{}(*tmp*)
tostrptr_int(i) = let
//
#define BSZ 32
//
typedef
cstring = $extype"atstype_string"
//
var buf = @[byte][BSZ]()
val bufp = $UN.cast{cstring}(addr@buf)
//
val _(*int*) =
  $extfcall(ssize_t, "snprintf", bufp, BSZ, "%i", i)
//
in
  $UN.castvwtp0{Strptr1}(string0_copy($UN.cast{string}(bufp)))
end // end of [tostrptr_int]
//
implement
tostring_val<int> = tostring_int
implement
tostrptr_val<int> = tostrptr_int
//
(* ****** ****** *)

implement
{}(*tmp*)
tostring_uint(u) = 
$effmask_wrt
(
  strptr2string(tostrptr_uint(u))
)
implement
{}(*tmp*)
tostrptr_uint(u) = let
//
#define BSZ 32
//
typedef
cstring = $extype"atstype_string"
//
var buf = @[byte][BSZ]()
val bufp = $UN.cast{cstring}(addr@buf)
//
val _(*int*) =
  $extfcall(ssize_t, "snprintf", bufp, BSZ, "%u", u)
//
in
  $UN.castvwtp0{Strptr1}(string0_copy($UN.cast{string}(bufp)))
end // end of [tostrptr_uint]
//
implement
tostring_val<uint> = tostring_uint
implement
tostrptr_val<uint> = tostrptr_uint
//
(* ****** ****** *)
//
implement
{}(*tmp*)
tostring_bool(b) = bool2string(b)
implement
{}(*tmp*)
tostrptr_bool(b) = string0_copy(bool2string(b))
//
implement
tostring_val<bool> = tostring_bool
implement
tostrptr_val<bool> = tostrptr_bool
//
(* ****** ****** *)
//
implement
{}(*tmp*)
tostring_char(c) =
$effmask_wrt
(
  strptr2string(char2strptr(c))
)
//
implement
{}(*tmp*)
tostrptr_char(c) = char2strptr(c)
//
implement
tostring_val<char> = tostring_char
implement
tostrptr_val<char> = tostrptr_char
//
(* ****** ****** *)

implement
tostrptr_val<int> = g0int2string_int
implement
tostrptr_val<lint> = g0int2string_lint
implement
tostrptr_val<llint> = g0int2string_llint

(* ****** ****** *)

implement
{a}(*tmp*)
tostrptr_list(xs) = let
//
fun
loop
(
  i: int
, xs: List(a)
, res: List0_vt(Strptr1)
) : List0_vt(Strptr1) =
(
case+ xs of
| list_nil
    ((*void*)) => res
| list_cons
    (x, xs) => let
    val res1 = 
    (
      if i > 0
        then let
          val sep =
            tostrptr_list$sep<> ()
          // end of [val]
          val sep = string0_copy (sep)
        in
          list_vt_cons (sep, res)
        end // end of [then]
        else res // end of [else]
    ) : List0_vt(Strptr1)
    val xrep = tostrptr_val<a> (x)
    val res2 = list_vt_cons (xrep, res1)
  in
    loop (i+1, xs, res2)
  end // end of [list_cons]
)
//
val res = list_vt_nil ()
//
val _beg =
  tostrptr_list$beg<> ()
val _beg = string0_copy(_beg)
val res = list_vt_cons (_beg, res)
//
val res = loop (0, xs, res)
//
val _end =
  tostrptr_list$end<> ()
val _end = string0_copy(_end)      
val res = list_vt_cons (_end, res)
//
val res = list_vt_reverse<Strptr1> (res)
//
in
//
$UN.castvwtp0{Strptr1}(strptrlst_concat(res))
//
end // end of [tostrptr_list]

(* ****** ****** *)
//
implement{} tostrptr_list$beg() = ""
implement{} tostrptr_list$end() = ""
implement{} tostrptr_list$sep() = ""
//
(* ****** ****** *)
//
implement(a)
tostrptr_val<List(a)>
  (xs0) = $effmask_all (tostrptr_list<a> (xs0))
//
(* ****** ****** *)

implement
{a}(*tmp*)
tostrptr_array
  (A, n) = let
//
fun
loop{n:int}
(
  i: int
, p: ptr, n: size_t(n)
, res: List0_vt(Strptr1)
) : List0_vt(Strptr1) =
(
if
(n > 0)
then let
//
  val res1 = 
  (
    if i > 0
      then let
        val sep =
          tostrptr_array$sep<> ()
        // end of [val]
        val sep = string0_copy (sep)
      in
        list_vt_cons (sep, res)
      end // end of [then]
      else res // end of [else]
  ) : List0_vt(Strptr1)
//
  val
  (pf, fpf | p) =
    $UN.ptr_vtake{a}(p)
  // end of [val]
  val xrep = tostrptr_ref<a> (!p)
  prval ((*returned*)) = fpf (pf)
//
  val res2 = list_vt_cons (xrep, res1)
//
in
  loop (i+1, ptr_succ<a>(p), pred(n), res2)
end // end of [then]
else res // end of [else]
//
) (* end of [loop] *)
//
val res = list_vt_nil ()
//
val _beg =
  tostrptr_array$beg<> ()
val _beg = string0_copy(_beg)
val res = list_vt_cons (_beg, res)
//
val res = loop (0, addr@A, n, res)
//
val _end =
  tostrptr_array$end<> ()
val _end = string0_copy(_end)      
val res = list_vt_cons (_end, res)
//
val res = list_vt_reverse<Strptr1> (res)
//
in
//
$UN.castvwtp0{Strptr1}(strptrlst_concat(res))
//
end // end of [tostrptr_array]

(* ****** ****** *)
//
implement{} tostrptr_array$beg() = ""
implement{} tostrptr_array$end() = ""
implement{} tostrptr_array$sep() = ""
//
(* ****** ****** *)

implement
{a}(*tmp*)
tostrptr_arrayref
  (A, n) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr(A)
//
in
//
$effmask_ref(tostrptr_array<a> (!p, n))
//
end // end of [tostrptr_arrayref]

(* ****** ****** *)

implement
{a}(*tmp*)
tostrptr_arrszref
  (ASZ) = let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
//
in
  tostrptr_arrayref<a> (A, n)
end // end of [tostrptr_arrszref]

(* ****** ****** *)

(* end of [tostring.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/integer_ptr.atxt
** Time of generation: Sat Oct 17 15:19:53 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: February, 2014 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)
//
//
(* ****** ****** *)
//
staload UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)

implement
g0int2int<intknd,intptrknd> = g0int2int_int_intptr
implement
g0int2int<lintknd,intptrknd> = g0int2int_lint_intptr

(* ****** ****** *)

implement g0int_neg<intptrknd> = g0int_neg_intptr
implement g0int_abs<intptrknd> = g0int_abs_intptr
implement g0int_succ<intptrknd> = g0int_succ_intptr
implement g0int_pred<intptrknd> = g0int_pred_intptr
implement g0int_half<intptrknd> = g0int_half_intptr
implement g0int_add<intptrknd> = g0int_add_intptr
implement g0int_sub<intptrknd> = g0int_sub_intptr
implement g0int_mul<intptrknd> = g0int_mul_intptr
implement g0int_div<intptrknd> = g0int_div_intptr
implement g0int_mod<intptrknd> = g0int_mod_intptr
implement g0int_asl<intptrknd> = g0int_asl_intptr
implement g0int_asr<intptrknd> = g0int_asr_intptr
implement g0int_isltz<intptrknd> = g0int_isltz_intptr
implement g0int_isltez<intptrknd> = g0int_isltez_intptr
implement g0int_isgtz<intptrknd> = g0int_isgtz_intptr
implement g0int_isgtez<intptrknd> = g0int_isgtez_intptr
implement g0int_iseqz<intptrknd> = g0int_iseqz_intptr
implement g0int_isneqz<intptrknd> = g0int_isneqz_intptr
implement g0int_lt<intptrknd> = g0int_lt_intptr
implement g0int_lte<intptrknd> = g0int_lte_intptr
implement g0int_gt<intptrknd> = g0int_gt_intptr
implement g0int_gte<intptrknd> = g0int_gte_intptr
implement g0int_eq<intptrknd> = g0int_eq_intptr
implement g0int_neq<intptrknd> = g0int_neq_intptr
implement g0int_compare<intptrknd> = g0int_compare_intptr
implement g0int_max<intptrknd> = g0int_max_intptr
implement g0int_min<intptrknd> = g0int_min_intptr
//
implement fprint_val<intptr> (out, x) = fprint_intptr (out, x)
//
(* ****** ****** *)

implement
g0uint2uint<uintknd,uintptrknd> = g0uint2uint_uint_uintptr
implement
g0uint2uint<ulintknd,uintptrknd> = g0uint2uint_ulint_uintptr

(* ****** ****** *)

implement g0uint_succ<uintptrknd> = g0uint_succ_uintptr
implement g0uint_pred<uintptrknd> = g0uint_pred_uintptr
implement g0uint_half<uintptrknd> = g0uint_half_uintptr
implement g0uint_add<uintptrknd> = g0uint_add_uintptr
implement g0uint_sub<uintptrknd> = g0uint_sub_uintptr
implement g0uint_mul<uintptrknd> = g0uint_mul_uintptr
implement g0uint_div<uintptrknd> = g0uint_div_uintptr
implement g0uint_mod<uintptrknd> = g0uint_mod_uintptr
implement g0uint_lsl<uintptrknd> = g0uint_lsl_uintptr
implement g0uint_lsr<uintptrknd> = g0uint_lsr_uintptr
implement g0uint_lnot<uintptrknd> = g0uint_lnot_uintptr
implement g0uint_lor<uintptrknd> = g0uint_lor_uintptr
implement g0uint_lxor<uintptrknd> = g0uint_lxor_uintptr
implement g0uint_land<uintptrknd> = g0uint_land_uintptr
implement g0uint_isgtz<uintptrknd> = g0uint_isgtz_uintptr
implement g0uint_iseqz<uintptrknd> = g0uint_iseqz_uintptr
implement g0uint_isneqz<uintptrknd> = g0uint_isneqz_uintptr
implement g0uint_lt<uintptrknd> = g0uint_lt_uintptr
implement g0uint_lte<uintptrknd> = g0uint_lte_uintptr
implement g0uint_gt<uintptrknd> = g0uint_gt_uintptr
implement g0uint_gte<uintptrknd> = g0uint_gte_uintptr
implement g0uint_eq<uintptrknd> = g0uint_eq_uintptr
implement g0uint_neq<uintptrknd> = g0uint_neq_uintptr
implement g0uint_compare<uintptrknd> = g0uint_compare_uintptr
implement g0uint_max<uintptrknd> = g0uint_max_uintptr
implement g0uint_min<uintptrknd> = g0uint_min_uintptr
//
implement fprint_val<uintptr> (out, x) = fprint_uintptr (out, x)
//
(* ****** ****** *)

(* end of [integer_ptr.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/memory.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{}(*tmp*)
memory$free{l}
  (pfat, pfmf | p) = let
//
prval pfgc = $UN.castview0{mfree_gc_v(l)}(pfmf)
//
in
  mfree_gc (pfat, pfgc | p)
end // end of [memory$free]

(* ****** ****** *)

implement
{}(*tmp*)
memory$alloc
  {n} (bsz) = let
//
val [l:addr]
  (pfat, pfgc | p) = malloc_gc (bsz)
prval pfmf = $UN.castview0{memory$free_v(l)}(pfgc)
//
in
  (pfat, pfmf | p)
end // end of [memory$alloc]

(* ****** ****** *)

(* end of [memory.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gnumber_int.atxt
** Time of generation: Sat Oct 17 15:19:59 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gnumber_int<int> (x) = g0int2int_int_int (x)
implement
gnumber_int<lint> (x) = g0int2int_int_lint (x)
implement
gnumber_int<llint> (x) = g0int2int_int_llint (x)
implement
gnumber_int<ssize_t> (x) = g0int2int_int_ssize (x)

(* ****** ****** *)

implement
gneg_val<int> (x) = ~x
implement
gneg_val<lint> (x) = ~x
implement
gneg_val<llint> (x) = ~x

(* ****** ****** *)

implement
gsucc_val<int> (x) = succ (x)
implement
gsucc_val<lint> (x) = succ (x)
implement
gsucc_val<llint> (x) = succ (x)
implement
gsucc_val<ssize_t> (x) = succ (x)

(* ****** ****** *)

implement
gpred_val<int> (x) = pred (x)
implement
gpred_val<lint> (x) = pred (x)
implement
gpred_val<llint> (x) = pred (x)

(* ****** ****** *)

implement
gadd_val_val<int> (x, y) = x + y
implement
gadd_val_val<lint> (x, y) = x + y
implement
gadd_val_val<llint> (x, y) = x + y
implement
gadd_val_val<ssize_t> (x, y) = x + y

(* ****** ****** *)

implement
gsub_val_val<int> (x, y) = x - y
implement
gsub_val_val<lint> (x, y) = x - y
implement
gsub_val_val<llint> (x, y) = x - y

(* ****** ****** *)

implement
gmul_val_val<int> (x, y) = x * y
implement
gmul_val_val<lint> (x, y) = x * y
implement
gmul_val_val<llint> (x, y) = x * y
implement
gmul_val_val<ssize_t> (x, y) = x * y

(* ****** ****** *)

implement
gdiv_val_val<int> (x, y) = x / y
implement
gdiv_val_val<lint> (x, y) = x / y
implement
gdiv_val_val<llint> (x, y) = x / y
implement
gdiv_val_val<ssize_t> (x, y) = x / y

(* ****** ****** *)

implement
gmod_val_val<int> (x, y) = x mod y
implement
gmod_val_val<lint> (x, y) = x mod y
implement
gmod_val_val<llint> (x, y) = x mod y
implement
gmod_val_val<ssize_t> (x, y) = x mod y

(* ****** ****** *)

(*
implement
gconjugate_val<int> (x) = x
implement
gconjugate_val<lint> (x) = x
implement
gconjugate_val<llint> (x) = x
implement
gconjugate_val<ssize_t> (x) = x
*)

(* ****** ****** *)

(* end of [gnumber_int.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_uint.atxt
** Time of generation: Sat Oct 17 15:19:58 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)
//
implement
gcompare_val_val<uint> = g0uint_compare_uint
implement
gcompare_val_val<ulint> = g0uint_compare_ulint
implement
gcompare_val_val<ullint> = g0uint_compare_ullint
implement
gcompare_val_val<size_t> = g0uint_compare_size
//
(* ****** ****** *)

(* end of [gorder_uint.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_string.atxt
** Time of generation: Sat Oct 17 15:19:59 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gcompare_val_val<string> = compare_string_string

(* ****** ****** *)

(* end of [gorder_string.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_int.atxt
** Time of generation: Sat Oct 17 15:19:58 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)
//
implement
gcompare_val_val<int> = g0int_compare_int
implement
gcompare_val_val<lint> = g0int_compare_lint
implement
gcompare_val_val<llint> = g0int_compare_llint
implement
gcompare_val_val<ssize_t> = g0int_compare_ssize
//
(* ****** ****** *)

(* end of [gorder_int.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gnumber.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gnumber_int<float> (x) = g0int2float_int_float (x)
implement
gnumber_int<double> (x) = g0int2float_int_double (x)
(*
implement
gnumber_int<ldouble> (x) = g0int2float_int_ldouble (x)
*)

(* ****** ****** *)

implement
gnumber_double<float> (x) = g0float2float_double_float (x)
implement
gnumber_double<double> (x) = g0float2float_double_double (x)
(*
implement
gnumber_double<ldouble> (x) = g0float2float_double_ldouble (x)
*)
(* ****** ****** *)

implement
gneg_val<float> (x) = ~x
implement
gneg_val<double> (x) = ~x
implement
gneg_val<ldouble> (x) = ~x

(* ****** ****** *)

implement
gsucc_val<float> (x) = succ (x)
implement
gsucc_val<double> (x) = succ (x)
implement
gsucc_val<ldouble> (x) = succ (x)

(* ****** ****** *)

implement
gpred_val<float> (x) = pred (x)
implement
gpred_val<double> (x) = pred (x)
implement
gpred_val<ldouble> (x) = pred (x)

(* ****** ****** *)

implement
grecip_val<float> (x) = 1.0f / x
implement
grecip_val<double> (x) = 1.0 / x
implement
grecip_val<ldouble> (x) = 1.0l / x

(* ****** ****** *)

implement
gadd_val_val<float> (x, y) = x + y
implement
gadd_val_val<double> (x, y) = x + y
implement
gadd_val_val<ldouble> (x, y) = x + y

(* ****** ****** *)

implement
gsub_val_val<float> (x, y) = x - y
implement
gsub_val_val<double> (x, y) = x - y
implement
gsub_val_val<ldouble> (x, y) = x - y

(* ****** ****** *)

implement
gmul_val_val<float> (x, y) = x * y
implement
gmul_val_val<double> (x, y) = x * y
implement
gmul_val_val<ldouble> (x, y) = x * y

(* ****** ****** *)

implement
gdiv_val_val<float> (x, y) = x / y
implement
gdiv_val_val<double> (x, y) = x / y
implement
gdiv_val_val<ldouble> (x, y) = x / y

(* ****** ****** *)

implement
gmod_val_val<float> (x, y) = x mod y
implement
gmod_val_val<double> (x, y) = x mod y
implement
gmod_val_val<ldouble> (x, y) = x mod y

(* ****** ****** *)

(*
implement
gconjugate_val<float> (x) = x
implement
gconjugate_val<double> (x) = x
implement
gconjugate_val<ldouble> (x) = x
*)

(* ****** ****** *)

(* end of [gnumber_float.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list_vt_quicksort.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
list_vt_quicksort$cmp
  (x1, x2) =
(
  gcompare_ref_ref<a> (x1, x2)
) (* end of [list_vt_quicksort$cmp] *)

(* ****** ****** *)
(*
** HX-2012-05:
** (1) Copying a list into an array
** (2) Performing quicksort on the array
** (3) Copying it back into the list
*)
implement
{a}(*tmp*)
list_vt_quicksort
  {n} (xs) = let
//
fun copyout
  {n:nat} .<n>.
(
  xs: !list_vt (a, n), p: ptr
) :<!wrt> void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val (
    ) = $UN.ptr0_set<a> (p, $UN.ptr0_get<a> (addr@(x)))
    val () = copyout (xs1, ptr0_succ<a> (p))
  in
    fold@ (xs)
  end // end of [list_vt_cons]
| list_vt_nil ((*void*)) => ()
//
end // end of [copyout]
//
fun copyinto
  {n:nat} .<n>.
(
  xs: !list_vt (a, n), p: ptr
) :<!wrt> void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val (
    ) = $UN.ptr0_set<a> (addr@(x), $UN.ptr0_get<a> (p))
    val () = copyinto (xs1, ptr0_succ<a> (p))
  in
    fold@ (xs)
  end // end of [list_vt_cons]
| list_vt_nil ((*void*)) => ()
//
end // end of [copyinto]
//
implement
array_quicksort$cmp<a>
  (x1, x2) = list_vt_quicksort$cmp<a> (x1, x2)
// end of [array_quicksort$cmp]
//
prval () = lemma_list_vt_param (xs)
//
val n = list_vt_length (xs)
//
val [l:addr]
  (pfat, pfgc | p0) = array_ptr_alloc<a> (i2sz(n))
//
extern praxi
__out (pf: !array_v (a?, l, n) >> array_v (a, l, n)): void
extern praxi
__into (pf: !array_v (a, l, n) >> array_v (a?, l, n)): void
//
val () = copyout (xs, p0)
prval () = __out (pfat)
val () = array_quicksort<a> (!p0, i2sz(n))
prval () = __into (pfat)
val () = copyinto (xs, p0)
//
val () = array_ptr_free {a} (pfat, pfgc | p0)
//
in
  xs
end // end of [list_vt_quicksort]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_quicksort_fun
  (xs, cmp) = let
//
implement{a2}
list_vt_quicksort$cmp
  (x1, x2) = let
//
val cmp = $UN.cast{cmpref(a2)}(cmp) in cmp (x1, x2)
//
end (* end of [list_vt_quicksort$cmp] *)
//
in
  list_vt_quicksort<a> (xs)
end // end of [list_vt_quicksort_fun]

(* ****** ****** *)

(* end of [list_vt_quicksort.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2013 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
array_bsearch
  {n} (A, asz) = let
//
fun loop
  {l,r:nat | l <= r; r <= n} .<r-l>.
(
  A: &array (a, n), l: size_t l, r: size_t r
) :<> sizeLte (n) =
(
if l < r then let
  val m = l + half (r-l)
  val pm = addr@ (A.[m])
  val (
    pf, fpf | pm
  ) = $UN.ptr_vtake{a}(pm)
  val sgn = array_bsearch$ford<a> (!pm)
  prval () = fpf (pf)
in
  if sgn <= 0 then loop (A, l, m) else loop (A, succ(m), r)
end else l (* end of [if] *)
)
//
prval () = lemma_array_param (A)
//
in
  loop (A, g1i2u(0), asz)
end (* end of [array_bsearch] *)

(* ****** ****** *)

implement
{a}(*tmp*)
array_bsearch_fun
  (A, asz, key, cmp) = let
//
val p0 = addr@(key)
//
implement
array_bsearch$ford<a>
  (x) = sgn where
{
//
val
(
  pf, fpf | p0
) = $UN.ptr_vtake (p0)
val sgn = cmp (!p0, x)
prval ((*void*)) = fpf (pf)
//
} (* endimp *)
//
in
  array_bsearch<a> (A, asz)
end (* end of [array_bsearch_fun] *)

(* ****** ****** *)

(*
//
// HX: [qsort] is in libc/stdlib
//
void *bsearch
(
  const void *key
, const void *base
, size_t nmemb, size_t size
, int (*compar)(const void *, const void *)
) ; // end of [bsearch]
*)
implement{a}
array_bsearch_stdlib
  (A, asz, key, cmp) = let
in
//
$extfcall (
  Ptr0, "atspre_array_bsearch", addr@(key), addr@(A), asz, sizeof<a>, cmp
) // end of [$extfcall]
//
end // end of [array_bsearch_stdlib]

(* ****** ****** *)

(* end of [array_bsearch.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2013 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

(*
//
// HX-2013-04:
// Instead of employing advanced types, I happily
// ventured into the typeless territory of unsafe
// pointer arithmetic!
//
*)

(* ****** ****** *)

implement
{a}(*tmp*)
array_quicksort$cmp
  (x1, x2) =
(
  gcompare_ref_ref<a> (x1, x2)
) // end of [array_quicksort$cmp]

(* ****** ****** *)

implement
{a}(*tmp*)
array_quicksort
  (A, asz) = let
//
overload + with add_ptr0_bsz
overload - with sub_ptr0_bsz
//
(* ****** ****** *)
//
fun ptrcmp
(
  p1: ptr, p2: ptr
) : int = (sgn) where
{
//
val p1 = g1ofg0_ptr(p1)
val p2 = g1ofg0_ptr(p2)
//
val
(
  pf1, fpf1 | p1
) = $UN.ptr_vtake{a}(p1)
val
(
  pf2, fpf2 | p2
) = $UN.ptr_vtake{a}(p2)
//
val sgn = array_quicksort$cmp<a> (!p1, !p2)
//
prval () = fpf1 (pf1)
prval () = fpf2 (pf2)
//
} (* end of [ptrcmp] *)

(* ****** ****** *)
(*
//
// HX-2013-04:
// move min to the start
// HX-2013-04:
// this is not a safe approach
// in case [cmp] is not transitive!
//
fun auxmin
(
  pa: ptr, p: ptr, tsz: size_t
) : void = let
in
//
if pa < p then let
  val p1 = p - tsz
  val sgn = ptrcmp (p1, p)
  val () =
    if sgn > 0 then $UN.ptr0_intch<a> (p1, p)
  // end of [val]
in
  auxmin (pa, p1, tsz)
end (* end of [if] *)
//
end (* end of [auxmin] *)
*)
//
// HX: one round of insertion
//
fun auxins
(
  pa: ptr, p: ptr, tsz: size_t
) : void = let
in
//
if pa < p then let
  val p1 = p - tsz
  val sgn = ptrcmp (p1, p)
in
  if sgn > 0 then let
    val () = $UN.ptr0_intch<a> (p1, p) in auxins (pa, p1, tsz)
  end // end of [if]
end else () // end of [if]
//
end (* end of [auxins] *)
//
// HX: all rounds of insertion
//
fun auxinss
(
  pa: ptr, pz: ptr, p: ptr, tsz: size_t
) : void = let
in
//
if p < pz then let
  val () = auxins (pa, p, tsz)
in
  auxinss (pa, pz, p + tsz, tsz)
end // end of [if]
//
end (* end of [auxinss] *)

(* ****** ****** *)
//
// HX: insertion sorting
//
fun auxinsort
(
  pa: ptr, asz: size_t, tsz: size_t
) : void = let
  val pz = pa + asz * tsz
in
//
if pa < pz then let
  val () = auxinss (pa, pz, pa + tsz, tsz)
in
  (* nothing *)
end else () // end of [if]
//
end (* end of [auxinsort] *)

(* ****** ****** *)
//
// HX: locate the middle of 3
//
fun auxmid
(
  p1: ptr, p2: ptr, p3: ptr
) : ptr = let
  val sgn12 = ptrcmp (p1, p2)
in
//
if sgn12 <= 0 then (
  if ptrcmp (p2, p3) <= 0
    then p2 else (if ptrcmp (p1, p3) <= 0 then p3 else p1)
) else (
  if ptrcmp (p1, p3) <= 0
    then p1 else (if ptrcmp (p2, p3) <= 0 then p3 else p2)
) // end of [if]
end (* end of [auxmid] *)
//
// HX: pivot to the start
//
fun auxpivot
(
  pa: ptr, asz: size_t, tsz: size_t
) : void = let
//
val pm = auxmid
(
  pa, pa + half(asz) * tsz, pa + pred(asz) * tsz
) (* end of [val] *)
//
in
  $UN.ptr0_intch<a> (pa, pm)
end (* end of [auxpivot] *)

(* ****** ****** *)
//
// HX-2013-04:
// Invariants:
// 1. elements in [pa, pl) <= pivot
// 2. elements in (pr, pz) >= pivot
//
fun auxsplit_l
(
  pa: ptr, pl: ptr, pr: ptr, tsz: size_t
) : ptr =
(
if pl <= pr then let
  val sgn = ptrcmp (pl, pa)
in
//
if sgn <= 0 then auxsplit_l (pa, pl + tsz, pr, tsz) else pl
//
end else pl // end of [if]
) (* end of [auxsplit_l] *)

fun auxsplit_r
(
  pa: ptr, pl: ptr, pr: ptr, tsz: size_t
) : ptr =
(
if pl <= pr then let
  val sgn = ptrcmp (pa, pr)
in
//
if sgn <= 0 then auxsplit_r (pa, pl, pr - tsz, tsz) else pr
//
end else pr // end of [if]
) (* end of [auxsplit_r] *)

fun auxsplit_lr
(
  pa: ptr, pl: ptr, pr: ptr, tsz: size_t
) : ptr = let
  val pl = auxsplit_l (pa, pl, pr, tsz)
  val pr = auxsplit_r (pa, pl, pr, tsz)
in
//
if pl < pr then let
  val () = $UN.ptr0_intch<a> (pl, pr)
in
  auxsplit_lr (pa, pl + tsz, pr - tsz, tsz)
end else pl (* end of [if] *)
//
end (* end of [auxsplit_lr] *)

(* ****** ****** *)

#define CUTOFF 12

(* ****** ****** *)
//
// HX: quick-sorting
//
fun auxqsort
(
  pa: ptr, asz: size_t, tsz: size_t
) : void = let
in
//
if asz >= CUTOFF then let
  val () = auxpivot (pa, asz, tsz)
  val pz = pa + asz * tsz
  val pm = auxsplit_lr (pa, pa + tsz, pz - tsz, tsz)
  val pm1 = pm - tsz
  val () = $UN.ptr0_intch<a> (pa, pm1)
  val asz_f = $UN.cast2size(pm1-pa) / tsz
  val asz_r = pred (asz - asz_f)
in
  if asz_f <= asz_r then let
    val () = auxqsort (pa, asz_f, tsz)
    val () = auxqsort (pm, asz_r, tsz)
  in
    // nothing
  end else let
    val () = auxqsort (pm, asz_r, tsz)
    val () = auxqsort (pa, asz_f, tsz)
  in
    // nothing
  end (* end of [if] *)
end else
  auxinsort (pa, asz, tsz)
// end of [if]
//
end (* end of [auxqsort] *)

(* ****** ****** *)

in (* in of [let] *)
//
$effmask_all (auxqsort (addr@(A), asz, sizeof<a>))
//
end (* end of [array_quicksort] *)

(* ****** ****** *)

(*
//
// HX: [qsort] is in libc/stdlib
//
void qsort
(
  void *base, size_t nmemb, size_t size,
  int(*compar)(const void *, const void *)
) ; // end of [qsort]
*)
implement
{a}(*tmp*)
array_quicksort_stdlib
  (A, asz, cmp) = let
in
  $extfcall (void, "atspre_array_qsort", addr@(A), asz, sizeof<a>, cmp)
end (* end of [array_quicksort_stdlib] *)

(* ****** ****** *)

(* end of [array_quicksort.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list_vt_mergesort.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_mergesort$cmp
  (x1, x2) =
(
  gcompare_ref_ref<a> (x1, x2)
) // end of [list_vt_mergesort$cmp]

(* ****** ****** *)
//
extern
fun{
a:vt0p
} list_vt_insort
  {n:int}(xs: list_vt (a, n)):<!wrt> list_vt (a, n)
//
(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_insort
  (xs) = let
//
fun
insord
{l0,l1,l2:addr}{n:nat} .<n>.
(
  pf1: a @ l1
, pf2: list_vt (a, 0)? @ l2
| xs0: &list_vt (a, n) >> list_vt (a, n+1)
, nx0: list_vt_cons_unfold (l0, l1, l2), p1: ptr (l1), p2: ptr (l2)
) :<!wrt> void = let
in
//
case+ xs0 of
| @list_vt_cons
    (x0, xs1) => let
    val sgn = list_vt_mergesort$cmp<a> (x0, !p1)
  in
    if sgn <= 0
      then let
        val () = insord (pf1, pf2 | xs1, nx0, p1, p2)
        prval () = fold@ (xs0)
      in
        // nothing
      end // end of [then]
      else let
        prval () = fold@ (xs0)
        val () = (!p2 := xs0; xs0 := nx0)
        prval () = fold@ (xs0)
      in
        // nothing
      end // end of [else]
    // end of [if]
  end // end of [list_vt_cons]
| ~list_vt_nil () =>
  {
    val () = xs0 := nx0
    val () = !p2 := list_vt_nil ()
    prval () = fold@ (xs0)
  }
//
end (* end of [insord] *)
//
fun
loop{m,n:nat} .<m>.
(
  xs: list_vt (a, m)
, ys: &list_vt (a, n) >> list_vt (a, m+n)
) :<!wrt> void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val xs1_ = xs1
    val ((*void*)) =
      insord (view@x, view@xs1 | ys, xs, addr@x, addr@xs1)
    // end of [val]
  in
    loop (xs1_, ys)
  end // end of [list_vt_cons]
| ~list_vt_nil ((*void*)) => ()
//
end // end of [loop]
//
prval () =
lemma_list_vt_param (xs)
//
var ys = list_vt_nil{a}()
val ((*void*)) = loop (xs, ys)
//
in
  ys
end // end of [list_vt_insort]

(* ****** ****** *)

#define CUTOFF 12

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_mergesort
  {n} (xs) = let
//
fun
split
{n,n1:int |
 n >= n1; n1 >= 0} .<n1>.
(
  xs: &list_vt (a, n) >> list_vt (a, n1)
, n1: int n1, res: &List_vt a? >> list_vt (a, n-n1)
) :<!wrt> void = let
in
//
if n1 > 0 then let
  val+@list_vt_cons (_, xs1) = xs
  val () = split (xs1, n1-1, res)
in
  fold@ (xs)
end else let
  val () = res := xs
  val () = xs := list_vt_nil ()
in
  // nothing
end // end of [if]
//
end // end of [split]
//
fun
merge
{n1,n2:nat} .<n1+n2>.
(
  xs1: list_vt (a, n1)
, xs2: list_vt (a, n2)
, res: &List_vt a? >> list_vt (a, n1+n2)
) :<!wrt> void = let
in
//
case+ xs1 of
| @list_vt_cons
    (x1, xs11) => (
    case+ xs2 of
    | @list_vt_cons
        (x2, xs21) => let
        val sgn =
          list_vt_mergesort$cmp<a> (x1, x2)
        // end of [val]
      in
        if sgn <= 0 then let
          prval () = fold@{a}(xs2)
          val () = merge (xs11, xs2, xs11)
          prval () = fold@{a}(xs1)
        in
          res := xs1
        end else let
          prval () = fold@{a}(xs1)
          val () = merge (xs1, xs21, xs21)
          prval () = fold@{a}(xs2)
        in
          res := xs2
        end // end of [if]
      end // end of [list_vt_cons]
    | ~list_vt_nil () => (fold@ (xs1); res := xs1)
  ) // end of [list_vt_cons]
| ~list_vt_nil () => (res := xs2)
//
end // end of [merge]
//
fun
msort{n:nat} .<n>.
(
  xs: list_vt(a, n), n: int(n)
) :<!wrt> list_vt(a, n) =
(
if
n >= CUTOFF
then let
  val n1 = half(n+1)
  val+@list_vt_cons (_, xs1) = xs
  var res: List_vt a? // uninitialized
  val () = split (xs1, n1-1, res)
  prval () = fold@ (xs)
  val xs1 = msort (xs, n1)
  and xs2 = msort (res, n-n1)
  val () = merge (xs1, xs2, res)
in
  res
end // end of [then]
else list_vt_insort<a> (xs)
) (* end of [msort] *)
//
prval () = lemma_list_vt_param (xs)
//
in
  msort (xs, list_vt_length<a> (xs))
end // end of [list_vt_mergesort]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_mergesort_fun
  (xs, cmp) = let
//
implement{a2}
list_vt_mergesort$cmp
  (x1, x2) = let
//
val cmp = $UN.cast{cmpref(a2)}(cmp) in cmp (x1, x2)
//
end (* end of [list_vt_mergesort$cmp] *)
//
in
  list_vt_mergesort<a> (xs)
end // end of [list_vt_mergesort_fun]

(* ****** ****** *)

(* end of [list_vt_mergesort.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_char.atxt
** Time of generation: Sat Oct 17 15:19:59 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gcompare_val_val<char> = compare_char0_char0

(* ****** ****** *)

(* end of [gorder_char.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_bool.atxt
** Time of generation: Sat Oct 17 15:19:59 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gcompare_val_val<bool> = compare_bool0_bool0

(* end of [gorder_bool.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_float.atxt
** Time of generation: Sat Oct 17 15:19:59 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gcompare_val_val<float> = g0float_compare_float
implement
gcompare_val_val<double> = g0float_compare_double
implement
gcompare_val_val<ldouble> = g0float_compare_ldouble

(* end of [gorder_float.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gnumber_uint.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gnumber_int<uint> (x) = g0int2uint_int_uint (x)
implement
gnumber_int<ulint> (x) = g0int2uint_int_ulint (x)
implement
gnumber_int<ullint> (x) = g0int2uint_int_ullint (x)

(* ****** ****** *)

implement
gsucc_val<uint> (x) = succ (x)
implement
gsucc_val<ulint> (x) = succ (x)
implement
gsucc_val<ullint> (x) = succ (x)
implement
gsucc_val<size_t> (x) = succ (x)

(* ****** ****** *)

implement
gpred_val<uint> (x) = pred (x)
implement
gpred_val<ulint> (x) = pred (x)
implement
gpred_val<ullint> (x) = pred (x)
implement
gpred_val<size_t> (x) = pred (x)

(* ****** ****** *)

implement
gadd_val_val<uint> (x, y) = x + y
implement
gadd_val_val<ulint> (x, y) = x + y
implement
gadd_val_val<ullint> (x, y) = x + y
implement
gadd_val_val<size_t> (x, y) = x + y

(* ****** ****** *)

implement
gsub_val_val<uint> (x, y) = x - y
implement
gsub_val_val<ulint> (x, y) = x - y
implement
gsub_val_val<ullint> (x, y) = x - y
implement
gsub_val_val<size_t> (x, y) = x - y

(* ****** ****** *)

implement
gmul_val_val<uint> (x, y) = x * y
implement
gmul_val_val<ulint> (x, y) = x * y
implement
gmul_val_val<ullint> (x, y) = x * y
implement
gmul_val_val<size_t> (x, y) = x * y

(* ****** ****** *)

implement
gdiv_val_val<uint> (x, y) = x / y
implement
gdiv_val_val<ulint> (x, y) = x / y
implement
gdiv_val_val<ullint> (x, y) = x / y
implement
gdiv_val_val<size_t> (x, y) = x / y

(* ****** ****** *)

implement
gmod_val_val<uint> (x, y) = x mod y
implement
gmod_val_val<ulint> (x, y) = x mod y
implement
gmod_val_val<ullint> (x, y) = x mod y
implement
gmod_val_val<size_t> (x, y) = x mod y

(* ****** ****** *)

(*
implement
gconjugate_val<uint> (x) = x
implement
gconjugate_val<ulint> (x) = x
implement
gconjugate_val<ullint> (x) = x
implement
gconjugate_val<size_t> (x) = x
*)

(* ****** ****** *)

(* end of [gnumber_uint.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/list.atxt
** Time of generation: Sat Oct 17 15:19:48 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

#if(0)
//
// HX: these decls are available in [basic_dyn.sats]
//
datatype // t@ype+: covariant
list_t0ype_int_type (a:t@ype+, int) =
  | {n:int | n >= 0}
    list_cons (a, n+1) of (a, list_t0ype_int_type (a, n))
  | list_nil (a, 0) of ((*void*))
// end of [list_t0ype_int_type]
//
stadef list = list_t0ype_int_type
typedef
List (a:t0p) = [n:int] list (a, n)
typedef
List0 (a:t0p) = [n:int | n >= 0] list (a, n)
typedef
List1 (a:t0p) = [n:int | n >= 1] list (a, n)
typedef listLt
  (a:t0p, n:int) = [k:nat | k < n] list (a, k)
typedef listLte
  (a:t0p, n:int) = [k:nat | k <= n] list (a, k)
typedef listGt
  (a:t0p, n:int) = [k:int | k > n] list (a, k)
typedef listGte
  (a:t0p, n:int) = [k:int | k >= n] list (a, k)
typedef listBtw
  (a:t0p, m:int, n:int) = [k:int | m <= k; k < n] list (a, k)
typedef listBtwe
  (a:t0p, m:int, n:int) = [k:int | m <= k; k <= n] list (a, k)
//
#endif

(* ****** ****** *)

#define nil list_nil
#define cons list_cons

(* ****** ****** *)

exception
ListSubscriptExn of ()
(*
fun ListSubscriptExn ():<> exn = "mac#%ListSubscriptExn_make"
fun isListSubscriptExn (x: !exn):<> bool = "mac#%isListSubscriptExn"
macdef
ifListSubscriptExn
  {tres}(exn, body) =
(
let val x = ,(exn) in
(
if isListSubscriptExn(x)
  then
    let prval () = __vfree_exn (x) in ,(body) end
  else $raise (x)
) : tres // end of [if]
end (* end of [let] *)
) // end of [ifListSubscriptExn]
*)

(* ****** ****** *)

prfun
lemma_list_param
  {x:t0p}{n:int}
  (xs: list (INV(x), n)): [n >= 0] void
// end of [lemma_list_param]

(* ****** ****** *)

castfn
list_cast
  {x:t0p}{n:int}
  (xs: list (INV(x), n)):<> list (x, n)
// end of [list_cast]

(* ****** ****** *)
//
castfn
list_vt2t
  {x:t0p}{n:int}
  (xs: list_vt (INV(x), n)):<> list (x, n)
castfn
list_of_list_vt
  {x:t0p}{n:int}
  (xs: list_vt (INV(x), n)):<!wrt> list (x, n)
//
(* ****** ****** *)

#define list_sing(x)
  list_cons(x, list_nil())
#define list_pair(x1, x2)
  list_cons(x1, list_cons (x2, list_nil()))

(* ****** ****** *)

fun{x:t0p}
list_make_sing (x: x):<!wrt> list_vt (x, 1)
fun{x:t0p}
list_make_pair (x1: x, x2: x):<!wrt> list_vt (x, 2)

(* ****** ****** *)

fun{x:t0p}
list_make_elt
  {n:nat} (n: int n, x: x):<!wrt> list_vt (x, n)
// end of [list_make_elt]

(* ****** ****** *)

fun{
} list_make_intrange
  {l,r:int | l <= r}
  (l: int l, r: int r):<!wrt> list_vt (intBtw (l, r), r-l)
// end of [list_make_intrange]

(* ****** ****** *)

fun{a:vt0p}
list_make_array
  {n:int} (
  A: &(@[INV(a)][n]) >> @[a?!][n], n: size_t n
) :<!wrt> list_vt (a, n) // endfun

(* ****** ****** *)
//
symintr list
//
fun{a:vt0p}
list_make_arrpsz
  {n:int} (psz: arrpsz (INV(a), n)):<!wrt> list_vt (a, n)
overload list with list_make_arrpsz

(* ****** ****** *)
//
fun{x:t0p}
print_list (xs: List (INV(x))): void
fun{x:t0p}
prerr_list (xs: List (INV(x))): void
//
fun{x:t0p}
fprint_list (out: FILEref, xs: List (INV(x))): void
fun{x:t0p}
fprint_list_sep
  (out: FILEref, xs: List (INV(x)), sep: NSH(string)): void
// end of [fprint_list_sep]
//
fun{}
fprint_list$sep (out: FILEref): void
//
(* ****** ****** *)

fun{x:t0p}
fprint_listlist_sep
( out: FILEref
, xss: List (List (INV(x))), sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_listlist_sep]

(* ****** ****** *)

(*
//
// HX: for testing macdef
//
macdef
fprintlst_mac
  {T:t@ype}(f, out, xs, sep) = let
//
val out = ,(out)
val xs  = ,(xs)
val sep = ,(sep)
//
fun loop (
  xs: List(T), i: int
) : void =
  case+ xs of
  | list_cons
      (x, xs) => let
      val () = if i > 0 then fprint_string (out, sep)
      val () = ,(f) (out, x)
    in
      loop (xs, i+1)
    end
  | list_nil () => ()
//
in
  loop (xs, 0)
end // end of [fprintlst_mac]
*)

(* ****** ****** *)
//
fun{
} list_is_nil
  {x:t0p}{n:int} (xs: list (x, n)):<> bool(n==0)
fun{
} list_is_cons
  {x:t0p}{n:int} (xs: list (x, n)):<> bool(n > 0)
//
fun{x:t0p}
list_is_sing{n:int} (xs: list (INV(x), n)):<> bool(n==1)
fun{x:t0p}
list_is_pair{n:int} (xs: list (INV(x), n)):<> bool(n==2)
//
(* ****** ****** *)

fun{x:t0p}
list_head{n:pos} (xs: list (INV(x), n)):<> (x)
fun{x:t0p}
list_head_exn{n:int} (xs: list (INV(x), n)):<!exn> (x)

(* ****** ****** *)

fun{x:t0p}
list_tail{n:pos}
  (xs: SHR(list (INV(x), n))):<> list (x, n-1)
fun{x:t0p}
list_tail_exn{n:int}
  (xs: SHR(list (INV(x), n))):<!exn> list (x, n-1)

(* ****** ****** *)

fun{x:t0p}
list_last{n:pos} (xs: list (INV(x), n)):<> (x)
fun{x:t0p}
list_last_exn{n:int} (xs: list (INV(x), n)):<!exn> (x)

(* ****** ****** *)
//
fun{
x:t0p
} list_nth{n:int}
  (xs: list (INV(x), n), i: natLt (n)):<> (x)
fun{x:t0p}
list_nth_opt
  (xs: List (INV(x)), i: intGte (0)):<> Option_vt (x)
//
fun{x:t0p}
list_get_at{n:int}
  (xs: list (INV(x), n), i: natLt (n)):<> (x)
fun{x:t0p}
list_get_at_opt
  (xs: List (INV(x)), i: intGte (0)):<> Option_vt (x)
//
(* ****** ****** *)
//
fun{x:t0p}
list_set_at{n:nat}
  (xs: list (INV(x), n), i: natLt (n), x: x):<> list (x, n)
fun{x:t0p}
list_exch_at{n:nat}
  (xs: list (INV(x), n), i: natLt (n), x: x):<> (list (x, n), x)
//
(* ****** ****** *)

fun{x:t0p}
list_insert_at
  {n:int} (
  xs: SHR(list (INV(x), n)), i: natLte (n), x: x
) :<> list (x, n+1) // end of [list_insert_at]

fun{x:t0p}
list_remove_at
  {n:int} (
  xs: SHR(list (INV(x), n)), i: natLt (n)
) :<> list (x, n-1) // end of [list_remove_at]

fun{x:t0p}
list_takeout_at
  {n:int} (
  xs: SHR(list (INV(x), n)), i: natLt (n), x: &(x)? >> x
) :<!wrt> list (x, n-1) // end of [list_takeout_at]

(* ****** ****** *)

fun{x:t0p}
list_length
  {n:int} (xs: list (INV(x), n)):<> int (n)
// end of [list_length]

(* ****** ****** *)

fun{
x:t0p
} list_copy
  {n:int} (xs: list (INV(x), n)):<!wrt> list_vt (x, n)
// end of [list_copy]

(* ****** ****** *)
//
fun{a:t0p}
list_append
  {m,n:int}
(
  xs: NSH(list (INV(a), m)), ys: SHR(list (a, n))
) :<> list (a, m+n) // end of [list_append]
//
(* ****** ****** *)

fun{
a:t0p
} list_append1_vt
  {i,j:int} (
  xs: list_vt (INV(a), i), ys: SHR(list (a, j))
) :<!wrt> list (a, i+j) // endfun
fun{
a:t0p
} list_append2_vt
  {i,j:int} (
  xs: NSH(list (INV(a), i)), ys: list_vt (a, j)
) :<!wrt> list_vt (a, i+j) // endfun

(* ****** ****** *)

fun{
x:t0p
} list_extend{n:int}
  (xs: list (INV(x), n), x: x):<!wrt> list_vt (x, n+1)
// end of [list_extend]

macdef list_snoc (xs, x) = list_extend (,(xs), ,(x))

(* ****** ****** *)

fun{x:t0p}
list_reverse
  {n:int} (xs: list (INV(x), n)):<!wrt> list_vt (x, n)
// end of [list_reverse]

(* ****** ****** *)
//
fun{a:t0p}
list_reverse_append{m,n:int}
  (xs: NSH(list (INV(a), m)), ys: SHR(list (a, n))):<> list (a, m+n)
// end of [list_reverse_append]
//
fun{a:t0p}
list_reverse_append1_vt{m,n:int}
  (xs: list_vt (INV(a), m), ys: SHR(list (a, n))):<!wrt> list (a, m+n)
// end of [list_reverse_append1_vt]
fun{a:t0p}
list_reverse_append2_vt{m,n:int}
  (xs: NSH(list (INV(a), m)), ys: list_vt (a, n)):<!wrt> list_vt (a, m+n)
// end of [list_reverse_append2_vt]
//
macdef list_revapp = list_reverse_append
macdef list_revapp1_vt = list_reverse_append1_vt
macdef list_revapp2_vt = list_reverse_append2_vt
//
(* ****** ****** *)

fun{x:t0p}
list_concat (xss: List (List (INV(x)))):<!wrt> List0_vt (x)

(* ****** ****** *)
//
fun{
x:t0p
} list_take
  {n:int}{i:nat | i <= n}
  (xs: list (INV(x), n), i: int i):<!wrt> list_vt (x, i)
fun{
x:t0p
} list_take_exn
  {n:int}{i:nat} // it may raise [ListSubscriptException]
  (xs: list (INV(x), n), i: int i):<!exnwrt> [i <= n] list_vt (x, i)
//
(* ****** ****** *)
//
fun{
x:t0p
} list_drop
  {n:int}{i:nat | i <= n}
  (xs: SHR(list (INV(x), n)), i: int i):<> list (x, n-i)
fun{
x:t0p
} list_drop_exn
  {n:int}{i:nat} // it may raise [ListSubscriptException]
  (xs: SHR(list (INV(x), n)), i: int i):<!exn> [i <= n] list (x, n-i)
//
(* ****** ****** *)

fun{
x:t0p
} list_split_at
  {n:int}{i:nat | i <= n}
  (xs: SHR(list (INV(x), n)), i: int i):<!wrt> (list_vt (x, i), list (x, n-i))
// end of [list_split_at]

(* ****** ****** *)

fun{x:t0p}
list_exists (xs: List (INV(x))):<> bool
fun{x:t0p} list_exists$pred (x):<> bool

(* ****** ****** *)

fun{x:t0p}
list_forall (xs: List (INV(x))):<> bool
fun{x:t0p} list_forall$pred (x):<> bool

(* ****** ****** *)

fun{x:t0p}
list_equal$eqfn (x, x):<> bool
fun{x:t0p}
list_equal (xs1: List (INV(x)), xs2: List(x)):<> bool

(* ****** ****** *)
//
fun{
x:t0p
} list_find
  (List (INV(x)), x: &(x)? >> opt(x, b)):<> #[b:bool] bool(b)
//
fun{x:t0p} list_find$pred (x):<> bool
//
fun{x:t0p} list_find_exn (xs: List (INV(x))):<!exn> x
fun{x:t0p} list_find_opt (xs: List (INV(x))):<> Option_vt (x)
//
(* ****** ****** *)
//
fun{
key,itm:t0p
} list_assoc
(
  List @(INV(key), itm), key, x: &itm? >> opt(itm, b)
) :<> #[b:bool] bool(b) // end of [list_assoc]
//
fun{key:t0p}
list_assoc$eqfn (k1: key, k2: key):<> bool
//
fun{
key,itm:t0p
} list_assoc_exn
  (kxs: List @(INV(key), itm), k: key):<!exn> itm
fun{
key,itm:t0p
} list_assoc_opt
  (kxs: List @(INV(key), itm), k: key):<> Option_vt(itm)
//
(* ****** ****** *)
//
fun{
x:t0p
} list_filter{n:int}
  (xs: list (INV(x), n)): listLte_vt (x, n)
//
fun{x:t0p} list_filter$pred (x): bool
//
(*
fun{
x:t0p
} list_filter_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff}
(
  pfv: !v |
  xs: list (INV(x), n)
, f: (!v | x, !vt) -<fun,fe> bool, env: !vt
) :<fe,!wrt> listLte_vt (x, n) // end-of-function
*)
//
(* ****** ****** *)

fun{
x:t0p
} list_labelize{n:int}
  (xs: list (INV(x), n)):<!wrt> list_vt (@(int, x), n)
// end of [list_labelize]

(* ****** ****** *)
//
fun{x:t0p}
list_app (xs: List (INV(x))): void
//
fun{x:t0p} list_app$fwork (x): void
//
(* ****** ****** *)
//
fun{x:t0p}
list_app_fun
  (xs: List (INV(x)), fwork: (x) -<fun1> void): void
fun{x:t0p}
list_app_clo
  (xs: List (INV(x)), fwork: (x) -<clo1> void): void
fun{x:t0p}
list_app_cloref
  (xs: List (INV(x)), fwork: (x) -<cloref1> void): void
//
(* ****** ****** *)
//
(*
fun{
x:t0p
} list_app_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: list (INV(x), n)
, f: (!v | x, !vt) -<fun,fe> void, env: !vt
) :<fe> void // end of [list_app_funenv]
*)
//
(* ****** ****** *)
//
fun{
x:t0p}{y:vt0p
} list_map{n:int}
  (xs: list (INV(x), n)): list_vt (y, n)
// end of [list_map]
//
fun{x:t0p}{y:vt0p} list_map$fopr (x: x): (y)
//
(* ****** ****** *)

fun{
x:t0p}{y:vt0p
} list_map_fun{n:int}
  (xs: list (INV(x), n), f: (x) -<fun1> y): list_vt(y, n)

fun{
x:t0p}{y:vt0p
} list_map_clo{n:int}
  (xs: list (INV(x), n), f: &(x) -<clo1> y): list_vt(y, n)

fun{
x:t0p}{y:vt0p
} list_map_cloref{n:int}
  (xs: list (INV(x), n), f: (x) -<cloref1> y): list_vt(y, n)

(* ****** ****** *)

(*
fun{
x:t0p}{y:vt0p
} list_map_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: list (INV(x), n)
, f: (!v | x, !vt) -<fun,fe> y, env: !vt
) :<fe,!wrt> list_vt (y, n) // end of [list_map_funenv]
*)

(* ****** ****** *)
//
fun{
x:t0p}{y:vt0p
} list_imap{n:int}
  (xs: list (INV(x), n)): list_vt (y, n)
//
fun{
x:t0p}{y:vt0p
} list_imap$fopr (i: intGte(0), x: x): (y)
//
(* ****** ****** *)

fun{
x:t0p}{y:vt0p
} list_mapopt{n:int}
  (xs: list (INV(x), n)): listLte_vt (y, n)
//
fun{
x:t0p}{y:vt0p
} list_mapopt$fopr (x: x): Option_vt (y)
//
(*
fun{
x:t0p}{y:t0p
} list_mapopt_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: list (INV(x), n)
, f: (!v | x, !vt) -<fun,fe> Option_vt (y), env: !vt
) :<fe> listLte_vt (y, n) // end of [list_mapopt_funenv]
*)
//
(* ****** ****** *)

fun{
x1,x2:t0p}{y:vt0p
} list_map2{n1,n2:int}
(
  xs1: list (INV(x1), n1)
, xs2: list (INV(x2), n2)
) : list_vt (y, min(n1,n2)) // end of [list_map2]
//
fun{
x1,x2:t0p}{y:vt0p
} list_map2$fopr (x1: x1, x2: x2): (y)
//
(*
fun{
x1,x2:t0p}{y:t0p
} list_map2_funenv
  {v:view}{vt:viewtype}{n1,n2:int}{fe:eff}
(
  pfv: !v |
  xs1: list (INV(x1), n1)
, xs2: list (INV(x2), n2)
, f: (!v | x1, x2, !vt) -<fun,fe> y, env: !vt
) :<fe> list_vt (y, min(n1,n2)) // end of [list_map2_funenv]
*)
//
(* ****** ****** *)
//
fun{
a:vt0p
} list_tabulate{n:nat} (int n): list_vt (a, n)
//
fun{a:vt0p} list_tabulate$fopr (index: intGte(0)): (a)
//
(* ****** ****** *)

fun{
a:vt0p
} list_tabulate_fun{n:nat}
  (n: int n, f: natLt(n) -<fun1> a): list_vt (a, n)
fun{
a:vt0p
} list_tabulate_clo{n:nat}
  (n: int n, f: &(natLt(n)) -<clo1> a): list_vt (a, n)
fun{
a:vt0p
} list_tabulate_cloref{n:nat}
  (n: int n, f: natLt(n) -<cloref1> a): list_vt (a, n)

(* ****** ****** *)

fun{
x,y:t0p
} list_zip{m,n:int}
(
  xs: list (INV(x), m), ys: list (INV(y), n)
) :<!wrt> list_vt ((x, y), min(m,n)) // endfun

fun{
x,y:t0p}{xy:vt0p
} list_zipwith{m,n:int}
(
  xs: list (INV(x), m), ys: list (INV(y), n)
) : list_vt (xy, min(m,n)) // endfun
//
fun{
x,y:t0p}{xy:vt0p
} list_zipwith$fopr (x: x, y: y): (xy)
//
(* ****** ****** *)

fun{
x,y:t0p
} list_cross{m,n:int}
(
  xs: list (INV(x), m), ys: list (INV(y), n)
) :<!wrt> list_vt ((x, y), m*n) // endfun

fun{
x,y:t0p}{xy:vt0p
} list_crosswith{m,n:int}
(
  xs: list (INV(x), m), ys: list (INV(y), n)
) : list_vt (xy, m*n) // end of [list_crosswith]
//
fun{
x,y:t0p}{xy:vt0p
} list_crosswith$fopr (x: x, y: y): (xy)
//
(* ****** ****** *)

fun{
x:t0p
} list_foreach (xs: List (INV(x))): void
fun{
x:t0p}{env:vt0p
} list_foreach_env (xs: List (INV(x)), env: &(env) >> _): void
//
fun{
x:t0p}{env:vt0p
} list_foreach$cont (x: x, env: &env): bool
fun{
x:t0p}{env:vt0p
} list_foreach$fwork (x: x, env: &(env) >> _): void
//
(* ****** ****** *)

fun{x:t0p}
list_foreach_fun
  {fe:eff} (
  xs: List (INV(x)), f: (x) -<fun,fe> void
) :<fe> void // end of [list_foreach_fun]

fun{x:t0p}
list_foreach_clo
  {fe:eff} (
  xs: List (INV(x)), f: &(x) -<clo,fe> void
) :<fe> void // end of [list_foreach_clo]
fun{x:t0p}
list_foreach_vclo
  {v:view}{fe:eff} (
  pf: !v | xs: List (INV(x)), f: &(!v | x) -<clo,fe> void
) :<fe> void // end of [list_foreach_vclo]

fun{x:t0p}
list_foreach_cloptr
  {fe:eff} (
  xs: List (INV(x)), f: !(x) -<cloptr,fe> void
) :<fe> void // end of [list_foreach_cloptr]
fun{x:t0p}
list_foreach_vcloptr
  {v:view}{fe:eff} (
  pf: !v | xs: List (INV(x)), f: !(!v | x) -<cloptr,fe> void
) :<fe> void // end of [list_foreach_vcloptr]

fun{x:t0p}
list_foreach_cloref
  {fe:eff} (
  xs: List (INV(x)), f: (x) -<cloref,fe> void
) :<fe> void // end of [list_foreach_cloref]

fun{x:t0p}
list_foreach_funenv
  {v:view}{env:viewtype}{fe:eff} (
  pfv: !v
| xs: List (INV(x))
, f: (!v | x, !env) -<fun,fe> void
, env: !env
) :<fe> void // end of [list_foreach_funenv]

(* ****** ****** *)
//
fun{
x,y:t0p
} list_foreach2 (xs: List (INV(x)), ys: List (INV(y))): void
//
fun{
x,y:t0p}{env:vt0p
} list_foreach2_env (xs: List (INV(x)), ys: List (INV(y)), env: &(env) >> _): void
//
fun{
x,y:t0p}{env:vt0p
} list_foreach2$cont (x: x, y: y, env: &env): bool
fun{
x,y:t0p}{env:vt0p
} list_foreach2$fwork (x: x, y: y, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
x:t0p
} list_iforeach{n:int} (xs: list (INV(x), n)): natLte(n)

fun{
x:t0p}{env:vt0p
} list_iforeach_env{n:int} (xs: list (INV(x), n), env: &(env) >> _): natLte(n)
//
fun{
x:t0p}{env:vt0p
} list_iforeach$cont (i: intGte(0), x: x, env: &env): bool
fun{
x:t0p}{env:vt0p
} list_iforeach$fwork (i: intGte(0), x: x, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
x:t0p // type for elements
} list_iforeach_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: list (INV(x), n)
, f: (!v | natLt(n), x, !vt) -<fun,fe> void, env: !vt
) :<fe> int (n) // end of [list_iforeach_funenv]

(* ****** ****** *)

fun{
x,y:t0p
} list_iforeach2{m,n:int}
  (xs: list (INV(x), m), ys: list(INV(y), n)): natLte(min(m,n))

fun{
x,y:t0p}{env:vt0p
} list_iforeach2_env{m,n:int}
  (xs: list (INV(x), m), ys: list(INV(y), n), env: &(env) >> _): natLte(min(m,n))
//
fun{
x,y:t0p}{env:vt0p
} list_iforeach2$cont (i: intGte(0), x: x, y: y, env: &env): bool
fun{
x,y:t0p}{env:vt0p
} list_iforeach2$fwork (i: intGte(0), x: x, y: y, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
res:vt0p}{x:t0p
} list_foldleft
  (xs: List (INV(x)), ini: res): res
fun{
res:vt0p}{x:t0p
} list_foldleft$fopr (acc: res, x: x): res

(* ****** ****** *)

fun{
x:t0p}{res:vt0p
} list_foldright
  (xs: List (INV(x)), snk: res): res
fun{
x:t0p}{res:vt0p
} list_foldright$fopr (x: x, acc: res): res

(* ****** ****** *)

fun{
a:t0p
} list_mergesort{n:int}
  (xs: list (INV(a), n)) :<!wrt> list_vt (a, n)
//
fun{a:t0p}
list_mergesort$cmp (x1: a, x2: a):<> int (* sign *)
//
(* ****** ****** *)

fun{
a:t0p
} list_mergesort_fun
  {n:int} (
  xs: list (INV(a), n), cmp: cmpval (a)
) :<!wrt> list_vt (a, n) // end of [list_mergesort_fun]

fun{
a:t0p
} list_mergesort_cloref
  {n:int} (
  xs: list (INV(a), n), cmp: (a, a) -<cloref> int
) :<!wrt> list_vt (a, n) // end of [list_mergesort_cloref]

(* ****** ****** *)
//
fun{
a:t0p
} list_quicksort{n:int}
  (xs: list (INV(a), n)) :<!wrt> list_vt (a, n)
//
fun{a:t0p}
list_quicksort$cmp (x1: a, x2: a):<> int (* sign *)
//
(* ****** ****** *)

fun{
a:t0p
} list_quicksort_fun
  {n:int} (
  xs: list (INV(a), n), cmp: cmpval (a)
) :<!wrt> list_vt (a, n) // end of [list_quicksort_fun]

(* ****** ****** *)
//
// overloading for certain symbols
//
overload = with list_equal
//
overload + with list_append
//
overload [] with list_get_at
//
overload iseqz with list_is_nil
overload isneqz with list_is_cons
//
overload .head with list_head
overload .tail with list_tail
//
overload length with list_length
//
overload copy with list_copy
//
overload print with print_list
overload prerr with prerr_list
overload fprint with fprint_list
overload fprint with fprint_list_sep
//
(* ****** ****** *)

(* end of [list.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)
(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/intrange.atxt
** Time of generation: Sat Oct 17 15:19:47 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: June, 2012 *)

(* ****** ****** *)
//
// HX-2013-04:
// intrange (l, r) is for integers i satisfying l <= i < r
//
(* ****** ****** *)
//
fun{}
intrange_foreach (l: int, r: int): int
fun{env:vt0p}
intrange_foreach_env (l: int, r: int, env: &(env) >> _): int
//
fun{env:vt0p}
intrange_foreach$cont (i: int, env: &env): bool
fun{env:vt0p}
intrange_foreach$fwork (i: int, env: &(env) >> _): void
//
(* ****** ****** *)

fun{}
int_foreach_cloref
(
  n: int, fwork: (int) -<cloref1> void
) : int // end of [int_foreach_cloref]
fun{}
intrange_foreach_cloref
(
  l: int, r: int, fwork: (int) -<cloref1> void
) : int // end of [intrange_foreach_cloref]

(* ****** ****** *)
//
fun{}
intrange_rforeach (l: int, r: int): int
fun{env:vt0p}
intrange_rforeach_env (l: int, r: int, env: &(env) >> _): int
//
fun{env:vt0p}
intrange_rforeach$cont (i: int, env: &env): bool
fun{env:vt0p}
intrange_rforeach$fwork (i: int, env: &(env) >> _): void
//
(* ****** ****** *)

fun{}
int_rforeach_cloref
(
  n: int, fwork: (int) -<cloref1> void
) : int // end of [int_rforeach_cloref]
fun{}
intrange_rforeach_cloref
(
  l: int, r: int, fwork: (int) -<cloref1> void
) : int // end of [intrange_rforeach_cloref]

(* ****** ****** *)
//
fun{}
intrange2_foreach
  (l1: int, r1: int, l2: int, r2: int): void
//
fun{env:vt0p}
intrange2_foreach_env
  (l1: int, r1: int, l2: int, r2: int, env: &(env) >> _): void
//
fun{env:vt0p}
intrange2_foreach$fwork (i: int, j: int, env: &env >> _): void
//
(* ****** ****** *)

(* end of [intrange.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/option.atxt
** Time of generation: Sat Oct 17 15:19:48 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype

(* ****** ****** *)

#if(0)
//
// HX: these decls are available in [basic_dyn.sats]
//
stadef option = option_t0ype_bool_type
typedef Option (a:t0p) = [b:bool] option (a, b)
#endif

(* ****** ****** *)

exception NotSomeExn of ()
(*
fun NotSomeExn ():<> exn = "mac#%NotSomeExn_make"
fun isNotSomeExn (x: !exn):<> bool = "mac#%isNotSomeExn"
macdef
ifNotSomeExn
  {tres}(exn, body) =
(
let val x = ,(exn) in
(
if isNotSomeExn(x)
  then
    let prval () = __vfree_exn (x) in ,(body) end
  else $raise (x)
) : tres // end of [if]
end (* end of [let] *)
) // end of [ifNotSomeExn]
*)

(* ****** ****** *)
//
castfn
option_cast
  {a:t0p}{b:bool}
  (opt: option (INV(a), b)):<> option (a, b)
//
(* ****** ****** *)
//
castfn
option_vt2t
  {a:t0p}{b:bool}
  (opt: option_vt (INV(a), b)):<> option (a, b)
castfn
option_of_option_vt
  {a:t0p}{b:bool}
  (opt: option_vt (INV(a), b)):<> option (a, b)
//
(* ****** ****** *)

fun{a:t0p}
option_some (x: a):<> option (a, true)
fun{a:t0p}
option_none ((*void*)):<> option (a, false)

(* ****** ****** *)

fun{}
option_is_some{a:t0p}
  {b:bool} (opt: option (a, b)):<> bool (b)
// end of [option_is_some]

fun{}
option_is_none{a:t0p}
  {b:bool} (opt: option (a, b)):<> bool (~b)
// end of [option_is_none]

(* ****** ****** *)

fun{a:t0p}
option_unsome (opt: option (INV(a), true)):<> a

fun{a:t0p}
option_unsome_exn (opt: Option (INV(a))):<!exn> a

(* ****** ****** *)
//
fun{a:t0p}
option_equal$eqfn (a, a):<> bool
fun{a:t0p}
option_equal
  (opt1: Option(a), opt2: Option(a)):<> bool
//
(* ****** ****** *)
//
fun{a:t0p}
fprint_option
  (out: FILEref, opt: Option (INV(a))): void
//
overload fprint with fprint_option
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload = with option_equal

(* ****** ****** *)

overload iseqz with option_is_none
overload isneqz with option_is_some

(* ****** ****** *)

(* end of [option.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/matrixref.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2013 *)

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)
//
// matrixref:
// reference to a matrix
// with no dimension info attached
//
(* ****** ****** *)
//
abstype
matrixref_vt0ype_int_int_type
  (a:vt@ype(*inv*), nrow: int, ncol:int) = ptr
//
stadef matrixref = matrixref_vt0ype_int_int_type
//
(* ****** ****** *)

praxi
lemma_matrixref_param
  {a:vt0p}{m,n:int}
  (M: matrixref (a, m, n)): [m >= 0; n >= 0] void
// end of [lemma_matrixref_param]

(* ****** ****** *)
//
castfn
matrixref2ptr
  {a:vt0p}{m,n:int} (M: matrixref (a, m, n)):<> Ptr0
//
(* ****** ****** *)
//
castfn
matrixptr_refize
  {a:vt0p}{l:addr}{m,n:int}
  (matrixptr (INV(a), l, m, n)):<!wrt> matrixref (a, m, n)
//
castfn
matrixref_get_viewptr
  {a:vt0p}
  {m,n:int}
(
  M: matrixref (a, m, n)
) :<> [l:addr] (vbox (matrix_v (a, l, m, n)) | ptr l)
//
(* ****** ****** *)

castfn
arrayref2matrixref
  {a:vt0p}{m,n:nat} (A: arrayref (a, m*n)):<> matrixref (a, m, n)
// end of [arrayref2matrixref]

(* ****** ****** *)

fun{
a:t0p
} matrixref_make_elt
  {m,n:int}
  (m: size_t m, n: size_t n, x0: a):<!wrt> matrixref (a, m, n)
// end of [matrixref_make_elt]

(* ****** ****** *)

fun{a:t0p}
matrixref_get_at_int
  {m,n:int}
(
  M: matrixref (a, m, n), i: natLt(m), n: int(n), j: natLt(n)
) :<!ref> (a) // end of [matrixref_get_at_int]

fun{a:t0p}
matrixref_get_at_size
  {m,n:int}
(
  M: matrixref (a, m, n), i: sizeLt(m), n: size_t(n), j: sizeLt(n)
) :<!ref> (a) // end of [matrixref_get_at_size]
//
symintr matrixref_get_at
overload matrixref_get_at with matrixref_get_at_int of 0
overload matrixref_get_at with matrixref_get_at_size of 0
//
(* ****** ****** *)

fun{a:t0p}
matrixref_set_at_int
  {m,n:int}
(
  M: matrixref (a, m, n), i: natLt (m), n: int n, j: natLt (n), x: a
) :<!refwrt> void // end of [matrixref_set_at_int]

fun{a:t0p}
matrixref_set_at_size
  {m,n:int}
(
  M: matrixref (a, m, n), i: sizeLt (m), n: size_t n, j: sizeLt (n), x: a
) :<!refwrt> void // end of [matrixref_set_at_size]

symintr matrixref_set_at
overload matrixref_set_at with matrixref_set_at_int of 0
overload matrixref_set_at with matrixref_set_at_size of 0

(* ****** ****** *)

fun{a:vt0p}
matrixref_exch_at_int
  {m,n:int}
(
  M: matrixref (a, m, n)
, i: natLt (m), n: int n, j: natLt (n), x: &a >> _
) :<!refwrt> void // end of [matrixref_exch_at_int]

fun{a:vt0p}
matrixref_exch_at_size
  {m,n:int}
(
  M: matrixref (a, m, n)
, i: sizeLt (m), n: size_t n, j: sizeLt (n), x: &a >> _
) :<!refwrt> void // end of [matrixref_exch_at_size]

symintr matrixref_exch_at
overload matrixref_exch_at with matrixref_exch_at_int of 0
overload matrixref_exch_at with matrixref_exch_at_size of 0

(* ****** ****** *)

(*
fprint_matrix$sep1 // col separation
fprint_matrix$sep2 // row separation
*)
fun{a:vt0p}
fprint_matrixref{m,n:int}
(
  out: FILEref
, M: matrixref (a, m, n), m: size_t m, n: size_t n
) : void // end of [fprint_matrixref]

fun{a:vt0p}
fprint_matrixref_sep{m,n:int}
(
  out: FILEref
, M: matrixref (a, m, n), m: size_t (m), n: size_t (n)
, sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_matrixref_sep]

(* ****** ****** *)
//
fun{a:t0p}
matrixref_copy
  {m,n:int}
(
  M: matrixref (a, m, n), m: size_t(m), n: size_t(n)
) : matrixptr (a, m, n) // end-of-fun
//
(* ****** ****** *)

(*
fun{a:vt0p}
matrix_tabulate$fopr (i: size_t, j: size_t): (a)
*)
fun{a:vt0p}
matrixref_tabulate
  {m,n:int} (nrow: size_t m, ncol: size_t n): matrixref (a, m, n)
//
fun{a:vt0p}
matrixref_tabulate_cloref
  {m,n:int}
(
  nrow: size_t m, ncol: size_t n, f: (sizeLt(m), sizeLt(n)) -<cloref> a
) : matrixref (a, m, n) // end-of-fun
//
(* ****** ****** *)

(*
fun{
a:vt0p}{env:vt0p
} matrix_foreach$fwork
  (x: &a >> _, env: &(env) >> _): void
*)
//
fun{
a:vt0p
} matrixref_foreach{m,n:int}
(
  A: matrixref (a, m, n), m: size_t m, n: size_t n
) : void // end of [matrixref_foreach]
fun{
a:vt0p}{env:vt0p
} matrixref_foreach_env{m,n:int}
(
  A: matrixref (a, m, n), m: size_t m, n: size_t n, env: &(env) >> _
) : void // end of [matrixref_foreach_env]

(* ****** ****** *)
//
// mtrxszref: a reference to a matrix with size information attached
//
(* ****** ****** *)

abstype // in-variant
mtrxszref_vt0ype_type (a: vt@ype) = ptr
stadef mtrxszref = mtrxszref_vt0ype_type

(* ****** ****** *)

fun{}
mtrxszref_make_matrixref
  {a:vt0p}{m,n:int}
(
  M: matrixref (a, m, n), m: size_t m, n: size_t n
) :<!wrt> mtrxszref (a) // endfun

(* ****** ****** *)
//
fun{}
mtrxszref_get_ref{a:vt0p} (M: mtrxszref (a)):<> Ptr1
//
fun{}
mtrxszref_get_nrow{a:vt0p} (M: mtrxszref (a)):<> size_t
fun{}
mtrxszref_get_ncol{a:vt0p} (M: mtrxszref (a)):<> size_t
//
(* ****** ****** *)

symintr .ref
overload .ref with mtrxszref_get_ref

(* ****** ****** *)

fun{}
mtrxszref_get_refsize{a:vt0p}
(
  M: mtrxszref (a)
, nrol: &size_t? >> size_t m, ncol: &size_t? >> size_t (n)
) :<!wrt> #[m,n:nat] matrixref (a, m, n) // endfun

(* ****** ****** *)

fun{a:t0p}
mtrxszref_make_elt
  (nrow: size_t, ncol: size_t, init: a):<!wrt> mtrxszref (a)
// end of [mtrxszref_make_elt]

(* ****** ****** *)
//
fun{a:t0p}
mtrxszref_get_at_int
  (M: mtrxszref(a), i: int, j: int):<!exnref> (a)
fun{a:t0p}
mtrxszref_get_at_size
  (M: mtrxszref(a), i: size_t, j: size_t):<!exnref> (a)
//
symintr mtrxszref_get_at
overload mtrxszref_get_at with mtrxszref_get_at_int of 0
overload mtrxszref_get_at with mtrxszref_get_at_size of 0
//
(* ****** ****** *)
//
fun{a:t0p}
mtrxszref_set_at_int
  (M: mtrxszref(a), i: int, j: int, x: a):<!exnrefwrt> void
fun{a:t0p}
mtrxszref_set_at_size
  (M: mtrxszref(a), i: size_t, j: size_t, x: a):<!exnrefwrt> void
//
symintr mtrxszref_set_at
overload mtrxszref_set_at with mtrxszref_set_at_int of 0
overload mtrxszref_set_at with mtrxszref_set_at_size of 0
//
(* ****** ****** *)

(*
fprint_matrix$sep1 // col separation
fprint_matrix$sep2 // row separation
*)
fun{a:vt0p}
fprint_mtrxszref
(
  out: FILEref, M: mtrxszref(a)
) : void // end of [fprint_mtrxszref]

fun{a:vt0p}
fprint_mtrxszref_sep
(
  out: FILEref
, M: mtrxszref(a), sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_mtrxszref_sep]

(* ****** ****** *)
//
(*
fun{
a:vt0p}{env:vt0p
} matrix_foreach$fwork
  (x: &a >> _, env: &(env) >> _): void
*)
//
fun{
a:vt0p
} mtrxszref_foreach(mtrxszref (a)): void
fun{
a:vt0p}{env:vt0p
} mtrxszref_foreach_env(mtrxszref(a), &(env) >> _) : void
//
fun{
a:vt0p
} mtrxszref_foreach_cloref
  (A: mtrxszref(a), fwork: (&(a) >> _) -<cloref1> void ): void
//
(* ****** ****** *)
//
(*
fun{a:vt0p}
matrix_tabulate$fopr (i: size_t, j: size_t): (a)
*)
fun{a:vt0p}
mtrxszref_tabulate (nrow: size_t, ncol: size_t): mtrxszref (a)
//
fun{a:vt0p}
mtrxszref_tabulate_cloref
  {m,n:int}
(
  nrow: size_t m, ncol: size_t n, f: (sizeLt(m), sizeLt(n)) -<cloref> a
) : mtrxszref (a) // end-of-fun
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with matrixref_get_at_int of 0
overload [] with matrixref_get_at_size of 0
overload [] with matrixref_set_at_int of 0
overload [] with matrixref_set_at_size of 0

(* ****** ****** *)

overload [] with mtrxszref_get_at_int of 0
overload [] with mtrxszref_get_at_size of 0
overload [] with mtrxszref_set_at_int of 0
overload [] with mtrxszref_set_at_size of 0

(* ****** ****** *)

overload .nrow with mtrxszref_get_nrow
overload .ncol with mtrxszref_get_ncol

(* ****** ****** *)

overload fprint with fprint_matrixref
overload fprint with fprint_matrixref_sep
overload fprint with fprint_mtrxszref
overload fprint with fprint_mtrxszref_sep

(* ****** ****** *)

overload ptrcast with matrixref2ptr

(* ****** ****** *)

(* end of [matrixref.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/string.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)

(*
** HX: a string is a null-terminated arrayref of characters
*)

(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)
//
typedef
stringLt (n:int) = [k:nat | k < n] string (k)
typedef
stringLte (n:int) = [k:nat | k <= n] string (k)
//
typedef
stringGt (n:int) = [k:int | k > n] string (k)
typedef
stringGte (n:int) = [k:int | k >= n] string (k)
//
typedef
stringBtw
  (m:int, n:int) = [k:int | m <= k; k < n] string (k)
typedef
stringBtwe
  (m:int, n:int) = [k:int | m <= k; k <= n] string (k)
//
(* ****** ****** *)

typedef stringlst = List0 (string)
vtypedef stringlst_vt = List0_vt (string)

(* ****** ****** *)

dataprop
string_index_p
(
  n: int, int(*i*), int(*c*)
) =
  | string_index_p_eqz (n, n, 0)
  | {i:int | n > i}
    {c:int8 | c != 0}
    string_index_p_neqz (n, i, c)
// end of [string_index_p]

(* ****** ****** *)

exception StringSubscriptExn of ((*void*))

(* ****** ****** *)
//
praxi
lemma_string_param{n:int}(string n): [n >= 0] void
//
(* ****** ****** *)

castfn
string2ptr (x: string):<> Ptr1
overload ptrcast with string2ptr

(* ****** ****** *)
//
// HX: [string2string] = [string1_of_string0]
//
castfn g0ofg1_string (x: String):<> string
castfn g1ofg0_string (x: string):<> String0
//
overload g0ofg1 with g0ofg1_string // index-erasing
overload g1ofg0 with g1ofg0_string // index-inducing
//
(* ****** ****** *)

fun{}
string_sing (c: charNZ):<!wrt> strnptr (1)

(* ****** ****** *)
//
fun{
} string_is_empty{n:int} (str: string(n)):<> bool(n==0)
fun{
} string_isnot_empty{n:int} (str: string(n)):<> bool(n > 0)
//
(* ****** ****** *)
//
fun{}
string_is_atend_size
  {n:int}{i:nat | i <= n}
  (s: string (n), i: size_t (i)):<> bool (i==n)
fun{tk:tk}
string_is_atend_gint
  {n:int}{i:nat | i <= n}
  (s: string (n), i: g1int (tk, i)):<> bool (i==n)
fun{tk:tk}
string_is_atend_guint
  {n:int}{i:nat | i <= n}
  (s: string (n), i: g1uint (tk, i)):<> bool (i==n)
//
symintr string_is_atend
overload string_is_atend with string_is_atend_gint
overload string_is_atend with string_is_atend_guint
//
(* ****** ****** *)

macdef
string_isnot_atend
  (string, index) = ~string_is_atend (,(string), ,(index))
// end of [string_isnot_atend]

(* ****** ****** *)
//
fun{
} string_head{n:pos} (str: string(n)):<> charNZ
fun{
} string_tail{n:pos} (str: string(n)):<> string(n-1)
//
(* ****** ****** *)

fun{}
string_get_at_size
  {n:int}{i:nat | i < n}
  (s: string (n), i: size_t (i)):<> charNZ
fun{tk:tk}
string_get_at_gint
  {n:int}{i:nat | i < n}
  (s: string (n), i: g1int (tk, i)):<> charNZ
fun{tk:tk}
string_get_at_guint
  {n:int}{i:nat | i < n}
  (s: string (n), i: g1uint (tk, i)):<> charNZ
//
symintr string_get_at
overload string_get_at with string_get_at_size of 1
overload string_get_at with string_get_at_gint of 0
overload string_get_at with string_get_at_guint of 0
//
(* ****** ****** *)

fun{}
string_test_at_size
  {n:int}{i:nat | i <= n}
  (s: string (n), i: size_t (i)):<> [c:int] (string_index_p (n, i, c) | char (c))
fun{tk:tk}
string_test_at_gint
  {n:int}{i:nat | i <= n}
  (s: string (n), i: g1int (tk, i)):<> [c:int] (string_index_p (n, i, c) | char (c))
fun{tk:tk}
string_test_at_guint
  {n:int}{i:nat | i <= n}
  (s: string (n), i: g1uint (tk, i)):<> [c:int] (string_index_p (n, i, c) | char (c))
//
symintr string_test_at
overload string_test_at with string_test_at_size of 1
overload string_test_at with string_test_at_gint of 0
overload string_test_at with string_test_at_guint of 0
//
(* ****** ****** *)

fun lt_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload < with lt_string_string
fun lte_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload <= with lte_string_string

fun gt_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload > with gt_string_string
fun gte_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload >= with gte_string_string

fun eq_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload = with eq_string_string
fun neq_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload != with neq_string_string
overload <> with neq_string_string

fun compare_string_string
  (x1: string, x2: string):<> Sgn = "mac#%"
overload compare with compare_string_string

(* ****** ****** *)

fun{
} strcmp (x1: string, x2: string):<> int

fun{
} strintcmp
  {n1,n2:int | n2 >=0}
  (x1: string n1, n2: int n2):<> int(sgn(n1-n2))
// end of [strintcmp]

fun{
} strlencmp
  {n1,n2:int}
  (x1: string n1, x2: string n2):<> int(sgn(n1-n2))
// end of [strlencmp]

(* ****** ****** *)

fun{}
string_make_list
  {n:int} (cs: list(charNZ, n)):<!wrt> strnptr (n)
fun{}
string_make_listlen
  {n:int} (cs: list(charNZ, n), n: int n):<!wrt> strnptr (n)

(* ****** ****** *)

fun{
} string_make_rlist
  {n:int} (cs: list(charNZ, n)):<!wrt> strnptr (n)
// end of [string_make_rlist]

fun{
} string_make_rlistlen
  {n:int} (cs: list(charNZ, n), n: int n):<!wrt> strnptr (n)
// end of [string_make_rlistlen]

(* ****** ****** *)

fun{
} string_make_substring
  {n:int}{st,ln:nat | st+ln <= n}
  (str: string (n), st: size_t st, ln: size_t ln):<!wrt> strnptr (ln)
// end of [string_make_substring]

(* ****** ****** *)

fun print_string (x: string): void = "mac#%"
fun prerr_string (x: string): void = "mac#%"
fun fprint_string (out: FILEref, x: string): void = "mac#%"

(* ****** ****** *)
//
fun fprint_substring
  {n:int}{st,ln:nat | st+ln <= n}
(
  out: FILEref, str: string(n), st: size_t(st), ln: size_t(ln)
) : void = "mac#%" // end of [fprint_substring]
//
(* ****** ****** *)

fun{
} strchr{n:int}
  (str: string (n), c0: char):<> ssizeBtwe (~1, n)
// end of [strchr]

fun{
} strrchr{n:int}
  (str: string (n), c0: char):<> ssizeBtwe (~1, n)
// end of [strrchr]

fun{
} strstr{n:int}
  (haystack: string (n), needle: string):<> ssizeBtw (~1, n)
// end of [strstr]

(* ****** ****** *)

fun{
} strspn{n:int} // spanning
  (str: string (n), accept: string):<> sizeLte (n)
// end of [strspn]
fun{
} strcspn{n:int} // complement spanning
  (str: string (n), accept: string):<> sizeLte (n)
// end of [strcspn]

(* ****** ****** *)

fun{
} string_index{n:int}
  (str: string (n), c0: charNZ):<> ssizeBtw (~1, n)
// end of [string_index]

fun{
} string_rindex{n:int}
  (str: string (n), c0: charNZ):<> ssizeBtw (~1, n)
// end of [string_rindex]

(* ****** ****** *)
//
fun{
} string0_length
  (x: NSH(string)):<> size_t
fun{
} string1_length
  {n:int} (x: NSH(string(n))):<> size_t(n)
//
symintr strlen
symintr string_length
overload strlen with string0_length of 0
overload strlen with string1_length of 10
overload string_length with string0_length of 0
overload string_length with string1_length of 10
//
(* ****** ****** *)
//
fun{
} string0_nlength
  (x: NSH(string), n: size_t):<> size_t
fun{
} string1_nlength
  {n1,n2:int}
  (NSH(string(n1)), size_t(n2)):<> size_t(min(n1,n2))
//
symintr string_nlength
overload string_nlength with string0_nlength of 0
overload string_nlength with string1_nlength of 10
//
(* ****** ****** *)
//
fun{
} string0_copy
  (xs: NSH(string)):<!wrt> Strptr1
fun{
} string1_copy
  {n:int} (xs: NSH(string(n))):<!wrt> strnptr (n)
//
(* ****** ****** *)
//
fun{
} string0_append
(
  x1: NSH(string), x2: NSH(string)
) :<!wrt> Strptr1 // end-of-fun
fun{
} string1_append
  {n1,n2:int} (
  x1: NSH(string(n1)), x2: NSH(string(n2))
) :<!wrt> strnptr (n1+n2) // end of [string1_append]
//
symintr string_append
overload string_append with string0_append of 0
(*
overload string_append with string1_append of 20
*)
//
(* ****** ****** *)
//
fun{
} string0_append3
(
  x1: NSH(string), x2: NSH(string), x3: NSH(string)
) :<!wrt> Strptr1 // end-of-fun
fun{
} string0_append4
(
  x1: NSH(string), x2: NSH(string), x3: NSH(string), x4: NSH(string)
) :<!wrt> Strptr1 // end-of-fun
fun{
} string0_append5
(
  x1: NSH(string), x2: NSH(string), x3: NSH(string), x4: NSH(string), x5: NSH(string)
) :<!wrt> Strptr1 // end-of-fun
fun{
} string0_append6
(
  x1: NSH(string), x2: NSH(string), x3: NSH(string), x4: NSH(string), x5: NSH(string), x6: NSH(string)
) :<!wrt> Strptr1 // end-of-fun
//
overload string_append with string0_append3 of 0
overload string_append with string0_append4 of 0
overload string_append with string0_append5 of 0
overload string_append with string0_append6 of 0
//
(* ****** ****** *)

fun{
} stringarr_concat{n:int}
  (xs: arrayref(string, n), size_t n):<!wrt> Strptr1
fun{
} stringlst_concat (xs: List(string)):<!wrt> Strptr1

(* ****** ****** *)

fun{
} string_explode
  {n:int} (x: string(n)):<!wrt> list_vt (charNZ, n)
// end of [string_explode]

(* ****** ****** *)

fun{
} string_tabulate$fopr (size_t): charNZ
fun{
} string_tabulate{n:int} (n: size_t(n)): strnptr(n)

(* ****** ****** *)
//
fun{}
string_forall (str: string): bool
fun{}
string_forall$pred (c: char): bool
//
(* ****** ****** *)
//
fun{}
string_iforall (str: string): bool
fun{}
string_iforall$pred (i: int, c: char): bool
//
(* ****** ****** *)
//
fun{env:vt0p}
string_foreach$cont (c: char, env: &env): bool
fun{env:vt0p}
string_foreach$fwork (c: char, env: &(env) >> _): void
//
fun{
} string_foreach {n:int} (str: string(n)): sizeLte(n)
fun{
env:vt0p
} string_foreach_env
  {n:int} (str: string(n), env: &(env) >> _): sizeLte(n)
// end of [string_foreach_env]
//
(* ****** ****** *)
//
fun{env:vt0p}
string_rforeach$cont (c: char, env: &env): bool
fun{env:vt0p}
string_rforeach$fwork (c: char, env: &(env) >> _): void
//
fun{
} string_rforeach {n:int} (str: string(n)): sizeLte(n)
fun{
env:vt0p
} string_rforeach_env
  {n:int} (str: string(n), env: &(env) >> _): sizeLte(n)
// end of [string_rforeach_env]
//
(* ****** ****** *)

(*
** HX: [stropt_none] is just the null pointer
*)
fun stropt_none (): stropt (~1) = "mac#%"

(* ****** ****** *)
//
castfn stropt0_some (x: SHR(string)): Stropt1
castfn stropt1_some {n:int} (x: SHR(string n)): stropt (n)
//
symintr stropt_some
overload stropt_some with stropt0_some of 0
overload stropt_some with stropt1_some of 10
//
(* ****** ****** *)

fun{
} stropt_is_none{n:int} (stropt(n)):<> bool (n < 0)
fun{
} stropt_is_some{n:int} (stropt(n)):<> bool (n >= 0)

(* ****** ****** *)

castfn
stropt_unsome {n:nat} (x: stropt n):<> string (n)

(* ****** ****** *)

fun{
} stropt_length
  {n:int} (x: stropt (n)):<> ssize_t (n)
// end of [stropt_length]

(* ****** ****** *)

fun print_stropt (opt: Stropt0): void = "mac#%"
fun prerr_stropt (opt: Stropt0): void = "mac#%"
fun fprint_stropt (out: FILEref, opt: Stropt0): void = "mac#%"

(* ****** ****** *)
//
// overloading for certain symbols
//
overload
[] with string_get_at_size of 1
overload
[] with string_get_at_gint of 0
overload
[] with string_get_at_guint of 0
//
overload iseqz with string_is_empty
overload isneqz with string_isnot_empty
//
overload .head with string_head
overload .tail with string_tail
//
overload length with string_length
//
overload copy with string0_copy of 0
(*
//
// HX: too much of a surprise!
//
overload copy with string1_copy of 10
*)
//
overload print with print_string of 0
overload prerr with prerr_string of 0
overload fprint with fprint_string of 0
//
overload iseqz with stropt_is_none
overload isneqz with stropt_is_some
//
overload length with stropt_length
//
overload print with print_stropt of 0
overload prerr with prerr_stropt of 0
overload fprint with fprint_stropt of 0
//
(* ****** ****** *)

(* end of [string.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/option_vt.atxt
** Time of generation: Sat Oct 17 15:19:48 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

sortdef vt0p = viewt@ype

(* ****** ****** *)

#if(0)
//
// HX: these decls are available in [basic_dyn.sats]
//
stadef option_vt = option_vt0ype_bool_vtype
vtypedef Option_vt (a:vt0p) = [b:bool] option_vt (a, b)
//
#endif

(* ****** ****** *)

fun{a:vt0p}
option_vt_some (x: a):<!wrt> option_vt (a, true)
fun{a:vt0p}
option_vt_none ((*void*)):<!wrt> option_vt (a, false)

(* ****** ****** *)

fun{
a:vt0p
} option_vt_make_opt
  {b:bool} (
  b: bool b, x: &opt (INV(a), b) >> a?
) :<!wrt> option_vt (a, b) // endfun

(* ****** ****** *)

fun{}
option_vt_is_some{a:vt0p}
  {b:bool} (opt: !option_vt (INV(a), b)):<> bool (b)
// end of [option_vt_is_some]
fun{}
option_vt_is_none{a:vt0p}
  {b:bool} (opt: !option_vt (INV(a), b)):<> bool (~b)
// end of [option_vt_is_none]

(* ****** ****** *)

fun{a:vt0p}
option_vt_unsome (opt: option_vt (INV(a), true)):<!wrt> a
fun{a:vt0p}
option_vt_unnone (opt: option_vt (INV(a), false)):<!wrt> void

(* ****** ****** *)

fun{a:t0p}
option_vt_free (opt: Option_vt (INV(a))):<!wrt> void

(* ****** ****** *)

fun{a:vt0p}
fprint_option_vt{b:bool}
   (out: FILEref, opt: !option_vt (INV(a), b)): void
overload fprint with fprint_option_vt

(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload iseqz with option_vt_is_none
overload isneqz with option_vt_is_some

(* ****** ****** *)

(* end of [option_vt.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/memory.atxt
** Time of generation: Sat Oct 17 15:19:44 2015
*)

(* ****** ****** *)

typedef bytes (n:int) = @[byte][n]
typedef b0ytes (n:int) = @[byte?][n]

(* ****** ****** *)

viewdef bytes_v (l:addr, n:int) = bytes (n) @ l
viewdef b0ytes_v (l:addr, n:int) = b0ytes (n) @ l

(* ****** ****** *)

praxi
b0ytes2bytes
  {l:addr}{n:int} (&b0ytes(n) >> bytes(n)): void
// end of [b0ytes2bytes]
praxi
b0ytes2bytes_v
  {l:addr}{n:int} (pf: b0ytes_v (l, n)): bytes_v (l, n)
// end of [b0ytes2bytes_v]

(* ****** ****** *)

prfun
bytes_v_split
  {l:addr}
  {n:int}{i:nat | i <= n}
  (pf: bytes_v (l, n)): (bytes_v (l, i), bytes_v (l+i, n-i))
// end of [bytes_v_split]

prfun
bytes_v_split_at
  {l:addr}
  {n:int}{i:nat | i <= n}
  (pf: bytes_v (l, n) | i: size_t (i)): (bytes_v (l, i), bytes_v (l+i, n-i))
// end of [bytes_v_split_at]

(* ****** ****** *)

prfun
bytes_v_unsplit
  {l:addr}{n1,n2:int}
  (pf1: bytes_v (l, n1), pf2: bytes_v (l+n1, n2)): bytes_v (l, n1+n2)
// end of [bytes_v_unsplit]

(* ****** ****** *)
//
// HX-2013-08:
// for memory initialization
//
fun minit_gc (): void = "mac#%"
//
(* ****** ****** *)

fun
mfree_gc
  {l:addr}{n:int}
(
  pfat: b0ytes n @ l
, pfgc: mfree_gc_v (l) | ptr l
) :<!wrt> void = "mac#%"

fun
malloc_gc
  {n:int}
(
  bsz: size_t (n)
) :<!wrt>
  [l:agz]
(
  b0ytes n @ l, mfree_gc_v (l) | ptr l
) = "mac#%" // endfun

(* ****** ****** *)

absview memory$free_v (l:addr)

(* ****** ****** *)

fun{
} memory$free
  {l:addr}{n:int}
(
  pfat: b0ytes n @ l
, pfmf: memory$free_v (l) | ptr l
) :<!wrt> void // end-of-fun

fun{
} memory$alloc
  {n:int}
(
  bsz: size_t (n)
) :<!wrt>
  [l:agz]
(
  b0ytes n @ l, memory$free_v (l) | ptr l
) (* end of [memory$alloc] *)

(* ****** ****** *)

(* end of [memory.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/float.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)

stadef fltknd = float_kind
stadef dblknd = double_kind
stadef ldblknd = ldouble_kind

(* ****** ****** *)

fun{
tk1,tk2:tk
} g0int2float (x: g0int (tk1)):<> g0float (tk2)

fun g0int2float_int_float (x: int):<> float = "mac#%"
fun g0int2float_int_double (x: int):<> double = "mac#%"
fun g0int2float_lint_double (x: lint):<> double = "mac#%"

(* ****** ****** *)

fun{
tk1,tk2:tk
} g0float2int (x: g0float (tk1)):<> g0int (tk2)

fun g0float2int_float_int (x: float):<> int = "mac#%"
fun g0float2int_float_lint (x: float):<> lint = "mac#%"
fun g0float2int_double_int (x: double):<> int = "mac#%"
fun g0float2int_double_lint (x: double):<> lint = "mac#%"
fun g0float2int_double_llint (x: double):<> llint = "mac#%"

(* ****** ****** *)

fun{
tk1,tk2:tk
} g0float2float (x: g0float (tk1)):<> g0float (tk2)

fun g0float2float_float_float (x: float):<> float = "mac#%"
fun g0float2float_float_double (x: float):<> double = "mac#%"
fun g0float2float_double_float (x: double):<> float = "mac#%"
fun g0float2float_double_double (x: double):<> double = "mac#%"

(* ****** ****** *)
//
fun{tk:tk}
g0string2float (str: NSH(string)):<> g0float (tk)
//
fun g0string2float_double (x: NSH(string)):<> double = "mac#%"
//
(* ****** ****** *)
//
typedef
g0float_uop_type
  (tk:tk) = g0float (tk) -<fun0> g0float (tk)
//
(* ****** ****** *)

fun{tk:tk}
g0float_neg : g0float_uop_type (tk)
overload ~ with g0float_neg of 0 // ~ for uminus
overload neg with g0float_neg of 0

fun{tk:tk}
g0float_abs : g0float_uop_type (tk)
overload abs with g0float_abs of 0

(* ****** ****** *)

fun{tk:tk}
g0float_succ : g0float_uop_type (tk)
overload succ with g0float_succ of 0
fun{tk:tk}
g0float_pred : g0float_uop_type (tk)
overload pred with g0float_pred of 0

(* ****** ****** *)

typedef
g0float_aop_type (tk:tk) =
  (g0float (tk), g0float (tk)) -<fun0> g0float (tk)
// end of [g0float_aop_type]

fun
{tk:tk}
g0float_add : g0float_aop_type(tk)
overload + with g0float_add of 0
fun
{tk:tk}
g0float_sub : g0float_aop_type(tk)
overload - with g0float_sub of 0
fun
{tk:tk}
g0float_mul : g0float_aop_type(tk)
overload * with g0float_mul of 0
fun
{tk:tk}
g0float_div : g0float_aop_type(tk)
overload / with g0float_div of 0
fun
{tk:tk}
g0float_mod : g0float_aop_type(tk)
overload % with g0float_mod of 0
overload mod with g0float_mod of 0

(* ****** ****** *)

fun{tk:tk}
g0float_isltz (x: g0float (tk)):<> bool
overload isltz with g0float_isltz of 0
fun{tk:tk}
g0float_isltez (x: g0float (tk)):<> bool
overload isltez with g0float_isltez of 0
fun{tk:tk}
g0float_isgtz (x: g0float (tk)):<> bool
overload isgtz with g0float_isgtz of 0
fun{tk:tk}
g0float_isgtez (x: g0float (tk)):<> bool
overload isgtez with g0float_isgtez of 0
fun{tk:tk}
g0float_iseqz (x: g0float (tk)):<> bool
overload iseqz with g0float_iseqz of 0
fun{tk:tk}
g0float_isneqz (x: g0float (tk)):<> bool
overload isneqz with g0float_isneqz of 0

(* ****** ****** *)

typedef
g0float_cmp_type (tk:tk) =
  (g0float (tk), g0float (tk)) -<fun0> bool
// end of [g0float_cmp_type]

fun
{tk:tk}
g0float_lt : g0float_cmp_type(tk)
overload < with g0float_lt of 0
fun
{tk:tk}
g0float_lte : g0float_cmp_type(tk)
overload <= with g0float_lte of 0
fun
{tk:tk}
g0float_gt : g0float_cmp_type(tk)
overload > with g0float_gt of 0
fun
{tk:tk}
g0float_gte : g0float_cmp_type(tk)
overload >= with g0float_gte of 0
fun
{tk:tk}
g0float_eq : g0float_cmp_type(tk)
overload = with g0float_eq of 0
fun
{tk:tk}
g0float_neq : g0float_cmp_type(tk)
overload != with g0float_neq of 0
overload <> with g0float_neq of 0

(* ****** ****** *)

typedef
g0float_compare_type (tk:tk) =
  (g0float (tk), g0float (tk)) -<fun0> (int)
// end of [g0float_compare_type]

fun{tk:tk}
g0float_compare : g0float_compare_type (tk)
overload compare with g0float_compare of 0

(* ****** ****** *)

fun{tk:tk}
g0float_max : g0float_aop_type (tk)
overload max with g0float_max of 0
fun{tk:tk}
g0float_min : g0float_aop_type (tk)
overload min with g0float_min of 0

(* ****** ****** *)

fun g0float_neg_float
  : g0float_uop_type(fltknd) = "mac#%"
fun g0float_abs_float
  : g0float_uop_type(fltknd) = "mac#%"

fun g0float_succ_float
  : g0float_uop_type(fltknd) = "mac#%"
fun g0float_pred_float
  : g0float_uop_type(fltknd) = "mac#%"

fun g0float_add_float
  : g0float_aop_type(fltknd) = "mac#%"
fun g0float_sub_float
  : g0float_aop_type(fltknd) = "mac#%"
fun g0float_mul_float
  : g0float_aop_type(fltknd) = "mac#%"
fun g0float_div_float
  : g0float_aop_type(fltknd) = "mac#%"
fun g0float_mod_float
  : g0float_aop_type(fltknd) = "mac#%"

fun g0float_lt_float
  : g0float_cmp_type(fltknd) = "mac#%"
fun g0float_lte_float
  : g0float_cmp_type(fltknd) = "mac#%"
fun g0float_gt_float
  : g0float_cmp_type(fltknd) = "mac#%"
fun g0float_gte_float
  : g0float_cmp_type(fltknd) = "mac#%"
fun g0float_eq_float
  : g0float_cmp_type(fltknd) = "mac#%"
fun g0float_neq_float
  : g0float_cmp_type(fltknd) = "mac#%"

fun g0float_compare_float
  : g0float_compare_type(fltknd) = "mac#%"

fun g0float_max_float
  : g0float_aop_type(fltknd) = "mac#%"
fun g0float_min_float
  : g0float_aop_type(fltknd) = "mac#%"

(* ****** ****** *)

fun g0float_neg_double
  : g0float_uop_type(dblknd) = "mac#%"
fun g0float_abs_double
  : g0float_uop_type(dblknd) = "mac#%"

fun g0float_succ_double
  : g0float_uop_type(dblknd) = "mac#%"
fun g0float_pred_double
  : g0float_uop_type(dblknd) = "mac#%"

fun g0float_add_double
  : g0float_aop_type(dblknd) = "mac#%"
fun g0float_sub_double
  : g0float_aop_type(dblknd) = "mac#%"
fun g0float_mul_double
  : g0float_aop_type(dblknd) = "mac#%"
fun g0float_div_double
  : g0float_aop_type(dblknd) = "mac#%"
fun g0float_mod_double
  : g0float_aop_type(dblknd) = "mac#%"

fun g0float_lt_double
  : g0float_cmp_type(dblknd) = "mac#%"
fun g0float_lte_double
  : g0float_cmp_type(dblknd) = "mac#%"
fun g0float_gt_double
  : g0float_cmp_type(dblknd) = "mac#%"
fun g0float_gte_double
  : g0float_cmp_type(dblknd) = "mac#%"
fun g0float_eq_double
  : g0float_cmp_type(dblknd) = "mac#%"
fun g0float_neq_double
  : g0float_cmp_type(dblknd) = "mac#%"

fun g0float_compare_double
  : g0float_compare_type(dblknd) = "mac#%"

fun g0float_max_double
  : g0float_aop_type(dblknd) = "mac#%"
fun g0float_min_double
  : g0float_aop_type(dblknd) = "mac#%"

(* ****** ****** *)

fun g0float_neg_ldouble
  : g0float_uop_type(ldblknd) = "mac#%"
fun g0float_abs_ldouble
  : g0float_uop_type(ldblknd) = "mac#%"

fun g0float_succ_ldouble
  : g0float_uop_type(ldblknd) = "mac#%"
fun g0float_pred_ldouble
  : g0float_uop_type(ldblknd) = "mac#%"

fun g0float_add_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"
fun g0float_sub_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"
fun g0float_mul_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"
fun g0float_div_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"
fun g0float_mod_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"

fun g0float_lt_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"
fun g0float_lte_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"
fun g0float_gt_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"
fun g0float_gte_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"
fun g0float_eq_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"
fun g0float_neq_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"

fun g0float_compare_ldouble
  : g0float_compare_type(ldblknd) = "mac#%"

fun g0float_max_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"
fun g0float_min_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"

(* ****** ****** *)
//
fun fprint_float
  : fprint_type (float) = "mac#%"
overload fprint with fprint_float
fun print_float (x: float): void = "mac#%"
fun prerr_float (x: float): void = "mac#%"
overload print with print_float
overload prerr with prerr_float
//
fun fprint_double
  : fprint_type (double) = "mac#%"
overload fprint with fprint_double
fun print_double (x: double): void = "mac#%"
fun prerr_double (x: double): void = "mac#%"
overload print with print_double
overload prerr with prerr_double
//
fun fprint_ldouble
  : fprint_type (ldouble) = "mac#%"
overload fprint with fprint_ldouble
fun print_ldouble (x: ldouble): void = "mac#%"
fun prerr_ldouble (x: ldouble): void = "mac#%"
overload print with print_ldouble
overload prerr with prerr_ldouble
//
(* ****** ****** *)
//
fun
add_int_float
  (x: int, y: float): float = "mac#%"
fun
add_float_int
  (x: float, y: int): float = "mac#%"
overload + with add_int_float of 0
overload + with add_float_int of 0
//
fun
add_int_double
  (x: int, y: double): double = "mac#%"
fun
add_double_int
  (x: double, y: int): double = "mac#%"
overload + with add_int_double of 0
overload + with add_double_int of 0
//
(* ****** ****** *)
//
fun
sub_int_float
  (x: int, y: float): float = "mac#%"
fun
sub_float_int
  (x: float, y: int): float = "mac#%"
overload - with sub_int_float of 0
overload - with sub_float_int of 0
//
fun
sub_int_double
  (x: int, y: double): double = "mac#%"
fun
sub_double_int
  (x: double, y: int): double = "mac#%"
overload - with sub_int_double of 0
overload - with sub_double_int of 0
//
(* ****** ****** *)
//
fun
mul_int_float
  (x: int, y: float): float = "mac#%"
fun
mul_float_int
  (x: float, y: int): float = "mac#%"
overload * with mul_int_float of 0
overload * with mul_float_int of 0
//
fun
mul_int_double
  (x: int, y: double): double = "mac#%"
fun
mul_double_int
  (x: double, y: int): double = "mac#%"
overload * with mul_int_double of 0
overload * with mul_double_int of 0
//
(* ****** ****** *)
//
fun
div_int_float
  (x: int, y: float): float = "mac#%"
fun
div_float_int
  (x: float, y: int): float = "mac#%"
overload / with div_int_float of 0
overload / with div_float_int of 0
//
fun
div_int_double
  (x: int, y: double): double = "mac#%"
fun
div_double_int
  (x: double, y: int): double = "mac#%"
overload / with div_int_double of 0
overload / with div_double_int of 0
//
(* ****** ****** *)
//
fun
{tk:tk}
g0float_npow
  (x: g0float(tk), n: intGte(0)): g0float(tk)
//
overload ** with g0float_npow of 0
//
(* ****** ****** *)

macdef g0i2f (x) = g0int2float (,(x))
macdef g0f2i (x) = g0float2int (,(x))
macdef g0f2f (x) = g0float2float (,(x))

(* ****** ****** *)

(* end of [float.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/stream.atxt
** Time of generation: Sun Oct 18 14:27:08 2015
*)

(* ****** ****** *)

sortdef t0p = t@ype

(* ****** ****** *)
//
// HX: lazy streams
//
datatype
stream_con (a:t@ype+) =
  | stream_nil of ((*void*)) | stream_cons of (a, stream(a))
where stream (a:t@ype) = lazy (stream_con(a))
//
(* ****** ****** *)
//
exception StreamSubscriptExn of ((*void*))
//
(*
fun StreamSubscriptExn ():<> exn = "mac#StreamSubscriptExn_make"
fun isStreamSubscriptExn (x: !exn):<> bool = "mac#isStreamSubscriptExn"
*)
//
(* ****** ****** *)
//
fun{a:t0p}
stream_sing(x: a):<> stream_con(a)
//
(* ****** ****** *)

fun{a:t0p}
stream2list
  (xs: stream(INV(a))):<!laz> List0_vt(a)
// end of [stream2list]

(* ****** ****** *)

fun{a:t0p}
stream_nth_exn
  (xs: stream(INV(a)), n: intGte(0)):<!laz> (a)
// end of [stream_nth_exn]
fun{a:t0p}
stream_nth_opt
  (xs: stream(INV(a)), n: intGte(0)):<!laz> Option_vt(a)
// end of [stream_nth_opt]

(* ****** ****** *)

fun{a:t0p}
stream_take_exn{n:nat}
  (xs: stream(INV(a)), n: int n):<!laz> list_vt(a, n)
// end of [stream_take_lte]

(* ****** ****** *)

fun{a:t0p}
stream_drop_exn
  (xs: stream(INV(a)), n: intGte(0)):<!laz> stream(a)
// end of [stream_drop_exn]

(* ****** ****** *)
//
fun{a:t0p}
stream_append
  (xs: stream(INV(a)), ys: stream(a)):<!laz> stream(a)
//
fun{a:t0p}
stream_concat(xss: stream(stream(INV(a)))):<!laz> stream(a)
//
(* ****** ****** *)
//
fun{a:t0p}
stream_filter
  (xs: stream(INV(a))):<!laz> stream(a)
//
fun{a:t0p} stream_filter$pred (x: a):<> bool
//
fun{a:t0p}
stream_filter_fun
(
  xs: stream(INV(a)), pred: (a) -<fun> bool
) :<!laz> stream(a) // end-of-function
fun{a:t0p}
stream_filter_cloref
(
  xs: stream(INV(a)), pred: (a) -<cloref> bool
) :<!laz> stream(a) // end-of-function
//
(* ****** ****** *)

fun{
a:t0p}{b:t0p
} stream_map
  (xs: stream(INV(a))):<!laz> stream(b)
fun{
a:t0p}{b:t0p
} stream_map$fopr (x: a):<(*none*)> (b)
//
fun{
a:t0p}{b:t0p
} stream_map_fun
  (xs: stream(INV(a)), f: (a) -<fun> b):<!laz> stream(b)
fun{
a:t0p}{b:t0p
} stream_map_cloref
  (xs: stream(INV(a)), f: (a) -<cloref> b):<!laz> stream(b)
//
(* ****** ****** *)
//
fun{
a:t0p}{b:t0p
} stream_imap{n:int}
  (xs: stream(INV(a))):<!laz> stream(b)
//
fun{
a:t0p}{b:t0p
} stream_imap$fopr (i: intGte(0), x: a):<> (b)
//
fun{
a:t0p}{b:t0p
} stream_imap_fun
(
  xs: stream(INV(a)), f: (intGte(0), a) -<fun> b
) :<!laz> stream(b) // end-of-fun
fun{
a:t0p}{b:t0p
} stream_imap_cloref
(
  xs: stream(INV(a)), f: (intGte(0), a) -<cloref> b
) :<!laz> stream(b) // end-of-fun
//
(* ****** ****** *)
//
fun{
a1,a2:t0p}{b:t0p
} stream_map2
(
  xs1: stream(INV(a1))
, xs2: stream(INV(a2))
) :<!laz> stream(b) // end-of-fun
fun{
a1,a2:t0p}{b:t0p
} stream_map2$fopr (x1: a1, x2: a2):<> b
//
fun{
a1,a2:t0p}{b:t0p
} stream_map2_fun
(
  xs1: stream(INV(a1))
, xs2: stream(INV(a2)), f: (a1, a2) -<fun> b
) :<!laz> stream(b) // end-of-fun
fun{
a1,a2:t0p}{b:t0p
} stream_map2_cloref
(
  xs1: stream(INV(a1))
, xs2: stream(INV(a2)), f: (a1, a2) -<cloref> b
) :<!laz> stream(b) // end-of-fun
//
(* ****** ****** *)

//
fun{
res:t0p}{x:t0p
} stream_scan
  (stream(INV(x)), ini: res):<!laz> stream(res)
//
fun{
res:t0p}{x:t0p
} stream_scan$fopr(res: res, x: x):<(*none*)> res
//
fun{
res:t0p}{x:t0p
} stream_scan_fun
(
  stream(INV(x)), ini: res, (res, x) -<fun> res
) :<!laz> stream(res) // end-of-function
//
fun{
res:t0p}{x:t0p
} stream_scan_cloref
(
  stream(INV(x)), ini: res, (res, x) -<cloref> res
) :<!laz> stream(res) // end-of-function
//
(* ****** ****** *)
//
fun{a:t0p}
stream_merge
  (stream(INV(a)), stream(a)) :<!laz> stream(a)
//
fun{a:t0p} stream_merge$cmp (x1: a, x2: a):<> int
//
fun{a:t0p}
stream_merge_fun
(
  xs1: stream(INV(a)), xs2: stream(a), (a, a) -<fun> int
) :<!laz> stream(a) // end of [stream_merge_fun]
fun{a:t0p}
stream_merge_cloref
(
  xs1: stream(INV(a)), xs2: stream(a), (a, a) -<cloref> int
) :<!laz> stream(a) // end of [stream_merge_cloref]

(* ****** ****** *)
//
fun{a:t0p}
stream_mergeq
  (stream(INV(a)), stream(a)):<!laz> stream(a)
//
fun{a:t0p} stream_mergeq$cmp (x1: a, x2: a):<> int
//
fun{a:t0p}
stream_mergeq_fun
(
  xs1: stream(INV(a)), xs2: stream(a), (a, a) -<fun> int
) :<!laz> stream(a) // end of [stream_mergeq_fun]
fun{a:t0p}
stream_mergeq_cloref
(
  xs1: stream(INV(a)), xs2: stream(a), (a, a) -<cloref> int
) :<!laz> stream(a) // end of [stream_mergeq_cloref]
//
(* ****** ****** *)
//
fun{
a:t0p
} stream_tabulate (): stream(a)
fun{
a:t0p
} stream_tabulate$fopr (i: intGte(0)): (a)
//
fun{
a:t0p
} stream_tabulate_fun (f: intGte(0) -> a): stream(a)
fun{
a:t0p
} stream_tabulate_cloref (f: intGte(0) -> a): stream(a)
//
(* ****** ****** *)
//
fun{a:t0p}
stream_foreach (xs: stream(a)): void
fun{
a:t0p}{env:vt0p
} stream_foreach_env (xs: stream(a), &env >> _): void
//
fun{
a:t0p}{env:vt0p
} stream_foreach$cont (x: a, env: &env): bool
fun{
a:t0p}{env:vt0p
} stream_foreach$fwork (x: a, env: &env): void
//
(* ****** ****** *)
//
fun{}
fprint_stream$sep (out: FILEref): void
fun{a:t0p}
fprint_stream
  (out: FILEref, xs: stream(INV(a)), n: int): void
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with stream_nth_exn

(* ****** ****** *)

(* end of [stream.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/fcontainer.atxt
** Time of generation: Sat Oct 17 15:19:50 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

(*
**
** HX-2012-02:
**
** The basic idea is to implement "everything" else in terms of
** "foreach" so that they become available for a container-type
** whenever "foreach" is made available for that type,
**
*)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

fun{x:t0p} foreach$fwork (x: x): void
fun{xs:t0p}{x:t0p} foreach (xs: xs): void

fun{
xs:t0p}{x:t0p
} foreach_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v | xs: xs, f: (!v | x, !vt) -<fun,fe> void, env: !vt
) :<fe> void // end of [foreach_funenv]

fun{
xs:t0p}{x:t0p
} foreach_fun {fe:eff}
  (xs: xs, f: (x) -<fun,fe> void):<fe> void
// end of [foreach_fun]

fun{
xs:t0p}{x:t0p
} foreach_clo {fe:eff}
  (xs: xs, f: &(x) -<clo,fe> void):<fe> void
// end of [foreach_clo]
fun{
xs:t0p}{x:t0p
} foreach_vclo
  {v:view}{fe:eff}
  (pfv: !v | xs: xs, f: &(!v | x) -<clo,fe> void):<fe> void
// end of [foreach_vclo]

fun{
xs:t0p}{x:t0p
} foreach_cloptr {fe:eff}
  (xs: xs, f: !(x) -<cloptr,fe> void):<fe> void
fun{
xs:t0p}{x:t0p
} foreach_vcloptr
  {v:view}{fe:eff}
  (pfv: !v | xs: xs, f: !(!v | x) -<cloptr,fe> void):<fe> void
// end of [foreach_vcloptr]

fun{
xs:t0p}{x:t0p
} foreach_cloref {fe:eff}
  (xs: xs, f: (x) -<cloref,fe> void):<fe> void
// end of [foreach_cloref]

(* ****** ****** *)

fun{x:t0p}
iforeach$fwork (i: size_t, x: x): void
fun{xs:t0p}{x:t0p} iforeach (xs: xs): void

fun{
xs:t0p}{x:t0p
} iforeach_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v | xs: xs, f: (!v | int, x, !vt) -<fun,fe> void, env: !vt
) :<fe> int // end of [iforeach_funenv]

fun{
xs:t0p}{x:t0p
} iforeach_clo {fe:eff}
  (xs: xs, f: &(int, x) -<clo,fe> void):<fe> int
// end of [iforeach_clo]
fun{
xs:t0p}{x:t0p
} iforeach_vclo
  {v:view}{fe:eff}
  (pfv: !v | xs: xs, f: &(!v | int, x) -<clo,fe> void):<fe> int
// end of [iforeach_vclo]

fun{
xs:t0p}{x:t0p
} iforeach_cloptr {fe:eff}
  (xs: xs, f: !(int, x) -<cloptr,fe> void):<fe> int
fun{
xs:t0p}{x:t0p
} iforeach_vcloptr
  {v:view}{fe:eff}
  (pfv: !v | xs: xs, f: !(!v | int, x) -<cloptr,fe> void):<fe> int
// end of [iforeach_vcloptr]

fun{
xs:t0p}{x:t0p
} iforeach_cloref {fe:eff}
  (xs: xs, f: (int, x) -<cloref,fe> void):<fe> int
// end of [iforeach_cloref]

(* ****** ****** *)

fun{
x:t0p}{res:vt0p
} foldleft$fwork
  (res: res, x: x): res
fun{
xs:t0p}{x:t0p}{res:vt0p
} foldleft (xs: xs, ini: res): res

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldleft_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v
| xs: xs, ini: res
, f: (!v | res, x, !vt) -<fun,fe> res, env: !vt
) :<fe> res // end of [foldleft_funenv]

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldleft_clo {fe:eff} (
  xs: xs, ini: res, f: &(res, x) -<clo,fe> res
) :<fe> res // end of [foldleft_clo]
fun{
xs:t0p}{x:t0p}{res:vt0p
} foldleft_vclo {v:view}{fe:eff} (
  pfv: !v
| xs: xs, ini: res, f: &(!v | res, x) -<clo,fe> res
) :<fe> res // end of [foldleft_vclo]

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldleft_cloref {fe:eff} (
  xs: xs, ini: res, f: &(res, x) -<cloref,fe> res
) :<fe> res // end of [foldleft_cloref]

(* ****** ****** *)

fun{
x:t0p}{res:vt0p
} foldright$fwork
  (x: x, res: res): res
fun{
xs:t0p}{x:t0p}{res:vt0p
} foldright (xs: xs, snk: res): res

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldright_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v
| xs: xs, f: (!v | x, res, !vt) -<fun,fe> res, snk: res, env: !vt
) :<fe> res // end of [foldright_funenv]

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldright_clo {fe:eff} (
  xs: xs, f: &(x, res) -<clo,fe> res, snk: res
) :<fe> res // end of [foldright_clo]
fun{
xs:t0p}{x:t0p}{res:vt0p
} foldright_vclo {v:view}{fe:eff} (
  pfv: !v
| xs: xs, f: &(!v | x, res) -<clo,fe> res, snk: res
) :<fe> res // end of [foldright_vclo]

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldright_cloref {fe:eff} (
  xs: xs, f: (x, res) -<cloref,fe> res, snk: res
) :<fe> res // end of [foldright_cloref]

(* ****** ****** *)

fun{x:t0p} exists$pred (x: x): bool
fun{xs:t0p}{x:t0p} exists (xs: xs): bool

fun{
xs:t0p}{x:t0p
} exists_funenv
  {v:view}{vt:viewtype}{pe:eff} (
  pf: !v | xs: xs, p: (!v | x, !vt) -<fun,pe> bool, env: !vt
) :<pe> bool // end of [exists_funenv]

fun{
xs:t0p}{x:t0p
} exists_clo {fe:eff}
  (xs: xs, f: &(x) -<clo,fe> void):<fe> bool
// end of [exists_clo]
fun{
xs:t0p}{x:t0p
} exists_vclo
  {v:view}{fe:eff}
  (pfv: !v | xs: xs, f: &(!v | x) -<clo,fe> void):<fe> bool
// end of [exists_vclo]

(* ****** ****** *)

fun{x:t0p} forall$pred (x: x): bool
fun{xs:t0p}{x:t0p} forall (xs: xs): bool

fun{
xs:t0p}{x:t0p
} forall_funenv
  {v:view}{vt:viewtype}{pe:eff} (
  pf: !v | xs: xs, p: (!v | x, !vt) -<fun,pe> bool, env: !vt
) :<pe> bool // end of [forall_funenv]

(* ****** ****** *)

fun{
xs:t0p}{x:t0p
} ismember_fun {fe:eff}
  (xs: xs, x0: x, eq: (x, x) -<fun,fe> void):<fe> bool
// end of [ismember_fun]

(* ****** ****** *)

fun{
xs:t0p}{x:t0p
} listize (xs: xs):<> List0_vt (x)
fun{
xs:t0p}{x:t0p}{y:vt0p
} listize_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v | xs: xs, f: (!v | x, !vt) -<fun,fe> y, env: !vt
) :<fe> List0_vt (y)

(* ****** ****** *)

fun{
xs:t0p}{x:t0p
} rlistize (xs: xs):<> List0_vt (x)
fun{
xs:t0p}{x:t0p}{y:vt0p
} rlistize_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v | xs: xs, f: (!v | x, !vt) -<fun,fe> y, env: !vt
) :<fe> List0_vt (y)

(* ****** ****** *)

fun{
xs:t0p}{x:t0p
} streamize (xs: xs):<> stream (x)
fun{
xs:t0p}{x:t0p
} streamize_vt (xs: xs):<> stream_vt (x)

(* ****** ****** *)

(* end of [fcontainer.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/pointer.atxt
** Time of generation: Sat Oct 17 15:19:44 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2012 *)

(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)
//
sortdef
t0p = t@ype and vt0p = viewt@ype
//
(* ****** ****** *)

stadef ptrknd = ptr_kind

(* ****** ****** *)

absprop is_word_aligned_p (l:addr)

(* ****** ****** *)
//
castfn
g0ofg1_ptr (p: Ptr):<> ptr
castfn
g1ofg0_ptr (p: ptr):<> Ptr0
//
overload g0ofg1 with g0ofg1_ptr
overload g1ofg0 with g1ofg0_ptr
//
(* ****** ****** *)
//
prfun
lemma_ptr_param
  {l:addr} (p: ptr l): [l >= null] void
//
(* ****** ****** *)

prfun
ptr_get_index
  {l1:addr} (p: ptr l1): [l2:addr] EQADDR(l1, l2)
// end of [ptr_get_index]

(* ****** ****** *)
//
symintr ptr_is_null
symintr ptr_isnot_null
//
(* ****** ****** *)
//
symintr add_ptr_bsz
symintr sub_ptr_bsz
//
// add_ptr_bsz (p, ofs) = p + ofs
// sub_ptr_bsz (p, ofs) = p - ofs
//
(* ****** ****** *)
//
symintr ptr_succ
symintr ptr_pred
//
// ptr_succ<a>(p) = p + sizeof<a>
// ptr_pred<a>(p) = p - sizeof<a>
//
(* ****** ****** *)
//
symintr ptr_add ptr_sub
//
// ptr_add<a> (p, ofs) = p + ofs*sizeof<a>
// ptr_sub<a> (p, ofs) = p - ofs*sizeof<a>
//
(* ****** ****** *)

fun ptr0_is_null (p: ptr):<> bool = "mac#%"
overload ptr_is_null with ptr0_is_null of 0
fun ptr0_isnot_null (p: ptr):<> bool = "mac#%"
overload ptr_isnot_null with ptr0_isnot_null of 0

(* ****** ****** *)
//
fun add_ptr0_bsz
  (p: ptr, ofs: size_t):<> ptr = "mac#%"
fun sub_ptr0_bsz
  (p: ptr, ofs: size_t):<> ptr = "mac#%"
//
overload add_ptr_bsz with add_ptr0_bsz of 0
overload sub_ptr_bsz with sub_ptr0_bsz of 0
//
(* ****** ****** *)

fun sub_ptr0_ptr0
  (p1: ptr, p2: ptr):<> ssize_t = "mac#%"
overload - with sub_ptr0_ptr0 of 0

(* ****** ****** *)
//
fun{a:vt0p} ptr0_succ (p: ptr):<> ptr
fun{a:vt0p} ptr0_pred (p: ptr):<> ptr
//
overload ptr_succ with ptr0_succ of 0
overload ptr_pred with ptr0_pred of 0
//
(* ****** ****** *)
//
fun{
a:vt0p}{tk:tk
} ptr0_add_gint (p: ptr, ofs: g0int (tk)):<> ptr
fun{
a:vt0p}{tk:tk
} ptr0_add_guint (p: ptr, ofs: g0uint (tk)):<> ptr
//
overload ptr_add with ptr0_add_gint of 0
overload ptr_add with ptr0_add_guint of 0
//
fun{
a:vt0p}{tk:tk
} ptr0_sub_gint (p: ptr, ofs: g0int (tk)):<> ptr
fun{
a:vt0p}{tk:tk
} ptr0_sub_guint (p: ptr, ofs: g0uint (tk)):<> ptr
//
overload ptr_sub with ptr0_sub_gint of 0
overload ptr_sub with ptr0_sub_guint of 0
//
(* ****** ****** *)

fun lt_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload < with lt_ptr0_ptr0 of 0
fun lte_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload <= with lte_ptr0_ptr0 of 0
fun gt_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload > with gt_ptr0_ptr0 of 0
fun gte_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload >= with gte_ptr0_ptr0 of 0
fun eq_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload = with eq_ptr0_ptr0 of 0
fun neq_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload != with neq_ptr0_ptr0 of 0
overload <> with neq_ptr0_ptr0 of 0

fun compare_ptr0_ptr0
  (p1: ptr, p2: ptr):<> int = "mac#%"
overload compare with compare_ptr0_ptr0 of 0

(* ****** ****** *)

fun gt_ptr0_intz
  (p: ptr, i: int(0)):<> bool = "mac#%"
overload > with gt_ptr0_intz of 0
fun eq_ptr0_intz
  (p: ptr, i: int(0)):<> bool = "mac#%"
overload = with eq_ptr0_intz of 0
fun neq_ptr0_intz
  (p: ptr, i: int(0)):<> bool = "mac#%"
overload != with neq_ptr0_intz of 0
overload <> with neq_ptr0_intz of 0

(* ****** ****** *)

(*
fun{a:vt0p}
ptr0_add_int (p: ptr, i: int): ptr
fun{a:vt0p}
ptr0_add_lint (p: ptr, i: lint): ptr
fun{a:vt0p}
ptr0_add_ssize (p: ptr, i: ssize): ptr
fun{a:vt0p}
ptr0_add_uint (p: ptr, u: uint): ptr
fun{a:vt0p}
ptr0_add_ulint (p: ptr, u: ulint): ptr
fun{a:vt0p}
ptr0_add_size (p: ptr, u: size): ptr
*)

(*
fun{a:vt0p}
ptr0_sub_int (p: ptr, i: int): ptr
fun{a:vt0p}
ptr0_sub_lint (p: ptr, i: lint): ptr
fun{a:vt0p}
ptr0_sub_ssize (p: ptr, i: ssize): ptr
fun{a:vt0p}
ptr0_sub_uint (p: ptr, u: uint): ptr
fun{a:vt0p}
ptr0_sub_ulint (p: ptr, u: ulint): ptr
fun{a:vt0p}
ptr0_sub_size (p: ptr, u: size): ptr
*)

(* ****** ****** *)
//
fun
print_ptr (p: ptr): void = "mac#%"
fun
prerr_ptr (p: ptr): void = "mac#%"
fun
fprint_ptr : fprint_type (ptr) = "mac#%"
//
overload print with print_ptr
overload prerr with prerr_ptr
overload fprint with fprint_ptr
//
(* ****** ****** *)
//
praxi
ptr1_is_gtez
  {l:addr}(p: ptr l): [l >= null] void
//
(* ****** ****** *)
//
fun
ptr1_is_null
  {l:addr}(p: ptr l):<> bool (l==null) = "mac#%"
fun
ptr1_isnot_null
  {l:addr}(p: ptr l):<> bool (l > null) = "mac#%"
//
overload ptr_is_null with ptr1_is_null of 10
overload ptr_isnot_null with ptr1_isnot_null of 10
//
(* ****** ****** *)
//
fun
add_ptr1_bsz{l:addr}{i:int}
  (p: ptr l, ofs: size_t (i)):<> ptr (l+i) = "mac#%"
fun
sub_ptr1_bsz{l:addr}{i:int}
  (p: ptr l, ofs: size_t (i)):<> ptr (l-i) = "mac#%"
//
overload add_ptr_bsz with add_ptr1_bsz of 20
overload sub_ptr_bsz with sub_ptr1_bsz of 20
//
(* ****** ****** *)
//
fun
sub_ptr1_ptr1{l1,l2:addr}
  (p1: ptr l1, p2: ptr l2):<> ssize_t (l1-l2) = "mac#%"
//
overload - with sub_ptr1_ptr1 of 20
//
(* ****** ****** *)
//
fun{
a:vt0p
} ptr1_succ{l:addr} (p: ptr l):<> ptr (l+sizeof(a))
fun{
a:vt0p
} ptr1_pred{l:addr} (p: ptr l):<> ptr (l-sizeof(a))
//
overload ptr_succ with ptr1_succ of 10
overload ptr_pred with ptr1_pred of 10
//
(* ****** ****** *)
//
fun{
a:vt0p}{tk:tk
} ptr1_add_gint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1int (tk, i)):<> ptr(l+i*sizeof(a))
fun{
a:vt0p}{tk:tk
} ptr1_add_guint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1uint (tk, i)):<> ptr(l+i*sizeof(a))
//
overload ptr_add with ptr1_add_gint of 20
overload ptr_add with ptr1_add_guint of 20
//
(* ****** ****** *)
//
fun{
a:vt0p}{tk:tk
} ptr1_sub_gint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1int (tk, i)):<> ptr(l-i*sizeof(a))
fun{
a:vt0p}{tk:tk
} ptr1_sub_guint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1uint (tk, i)):<> ptr(l-i*sizeof(a))
//
overload ptr_sub with ptr1_sub_gint of 20
overload ptr_sub with ptr1_sub_guint of 20
//
(* ****** ****** *)

fun lt_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 < l2) = "mac#%"
overload < with lt_ptr1_ptr1 of 20
fun lte_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 <= l2) = "mac#%"
overload <= with lte_ptr1_ptr1 of 20
fun gt_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 > l2) = "mac#%"
overload > with gt_ptr1_ptr1 of 20
fun gte_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 >= l2) = "mac#%"
overload >= with gte_ptr1_ptr1 of 20
fun eq_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 == l2) = "mac#%"
overload = with eq_ptr1_ptr1 of 20
fun neq_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 != l2) = "mac#%"
overload != with neq_ptr1_ptr1 of 20
overload <> with neq_ptr1_ptr1 of 20

fun compare_ptr1_ptr1
  {l1,l2:addr} (p1: ptr l1, p2: ptr l2) :<> int = "mac#%"
overload compare with compare_ptr1_ptr1 of 20

(* ****** ****** *)

fun gt_ptr1_intz {l:addr}
  (p: ptr l, i: int(0)):<> bool(l > null) = "mac#%"
overload > with gt_ptr1_intz of 10
fun eq_ptr1_intz {l:addr}
  (p: ptr l, i: int(0)):<> bool(l == null) = "mac#%"
overload = with eq_ptr1_intz of 10
fun neq_ptr1_intz {l:addr}
  (p: ptr l, i: int(0)):<> bool(l > null) = "mac#%"
overload != with neq_ptr1_intz of 10
overload <> with neq_ptr1_intz of 10

(* ****** ****** *)
//
// HX: implemented in [prelude/DATS/pointer.dats]
//
fun{a:vt0p}
ptr_get{l:addr}
  (pf: !INV(a) @ l >> a?! @ l | p: ptr l):<> a
// end of [ptr_get]

fun{a:vt0p}
ptr_set{l:addr}
  (pf: !a? @ l >> a @ l | p: ptr l, x: INV(a)):<!wrt> void
// end of [ptr_set]

fun{a:vt0p}
ptr_exch{l:addr}
  (pf: !INV(a) @ l | p: ptr l, x: &a >> a):<!wrt> void
// end of [ptr_exch]

(* ****** ****** *)
//
abstype
cptr_vt0ype_addr_type
  (a:vt@ype+, addr) = ptr // HX: for simulating C pointers
//
stadef cptr = cptr_vt0ype_addr_type
stadef cPtr0 (a:vt0p) = [l:addr] cptr (a, l)
stadef cPtr1 (a:vt0p) = [l:addr | l > null] cptr (a, l)
//
castfn
cptr2ptr{a:vt0p}{l:addr} (p: cptr (a, l)):<> ptr (l)
//
(* ****** ****** *)
//
fun cptr_null{a:vt0p} ():<> cptr (a, null) = "mac#%"
//
castfn cptr_rvar{a:vt0p} (x: &INV(a)):<> cPtr1 (a) // read
castfn cptr_wvar{a:vt0p} (x: &a? >> a):<> cPtr1 (a) // write
//
(* ****** ****** *)
//
fun cptr_succ
  {a:vt0p}{l:addr} (p: cptr (a, l)):<> cptr (a, l+sizeof(a))
fun cptr_pred
  {a:vt0p}{l:addr} (p: cptr (a, l)):<> cptr (a, l-sizeof(a))
//
(* ****** ****** *)
//
fun cptr_is_null
  {a:vt0p}{l:addr} (p: cptr (a, l)):<> bool (l==null) = "mac#%"
fun cptr_isnot_null
  {a:vt0p}{l:addr} (p: cptr (a, l)):<> bool (l > null) = "mac#%"
//
(* ****** ****** *)

typedef voidptr (l:addr) = cptr (void, l)
typedef voidptr0 = [l:addr] voidptr (l)
typedef voidptr1 = [l:addr | l > null] voidptr (l)

typedef charptr (l:addr) = cptr (char, l)
typedef charptr0 = [l:addr] charptr (l)
typedef charptr1 = [l:addr | l > null] charptr (l)

typedef constcharptr (l:addr) = charptr (l) // HX: commenting
typedef constcharptr0 = charptr0 // HX: for commenting purpose
typedef constcharptr1 = charptr1 // HX: for commenting purpose

(* ****** ****** *)
//
absprop
is_nullable (a: vt@ype+) // covariant
//
fun{a:vt0p}
ptr_nullize
  (pf: is_nullable (a) | x: &a? >> a):<!wrt> void
fun
ptr_nullize_tsz
  {a:vt0p} (
  pf: is_nullable (a) | x: &a? >> a, tsz: sizeof_t (a)
) :<!wrt> void = "mac#%" // end of [ptr_nullize_tsz]
//
(* ****** ****** *)

fun{
a:vt0p
} ptr_alloc ()
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l)
// end of [ptr_alloc]

fun ptr_alloc_tsz
  {a:vt0p} (tsz: sizeof_t a)
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l) = "mac#%"
// end of [ptr_alloc_tsz]

fun ptr_free
  {a:t@ype}{l:addr}
  (pfgc: mfree_gc_v (l), pfat: a @ l | p: ptr l):<> void = "mac#%"
// end of [ptr_free]

(* ****** ****** *)
//
absvtype ptrlin (l:addr) = ptr
//
praxi ptrlin_free{l:addr} (p: ptrlin (l)): void
//
castfn ptr2ptrlin{l:addr} (p: ptr l):<> ptrlin (l)
castfn ptrlin2ptr{l:addr} (p: ptrlin l):<> ptr (l)
//
(* ****** ****** *)
//
// HX-2015-03-24:
// singleton linear arrayptr
//
absvtype
aptr_vt0ype_addr_type
  (a:vt@ype+, addr) = ptr // HX: for safe ATS pointers
//
stadef aptr = aptr_vt0ype_addr_type
stadef aPtr0 (a:vt0p) = [l:addr] aptr (a, l)
stadef aPtr1 (a:vt0p) = [l:addr | l > null] aptr (a, l)
//
castfn
aptr2ptr{a:vt0p}{l:addr} (ap: !aptr (a, l)):<> ptr (l)
//
(* ****** ****** *)
//
fun
{a:vt0p}
aptr_make_elt(x: a):<!wrt> aPtr1(a)
fun
{a:vt0p}
aptr_getfree_elt{l:agz}(aptr(a, l)):<!wrt> (a)
//
fun
{a:t0p}
aptr_get_elt{l:agz}(ap: !aptr(INV(a), l)):<!wrt> a
fun
{a:t0p}
aptr_set_elt{l:agz}(ap: !aptr(INV(a), l) >> _, x: a):<!wrt> void
fun
{a:t0p}
aptr_exch_elt{l:agz}(ap: !aptr(INV(a), l) >> _, x: &(a)>>_):<!wrt> void
//
overload [] with aptr_get_elt
overload [] with aptr_set_elt
//
(* ****** ****** *)
//
// HX-2014-05-16:
// A hack to stop buggy compilation
//
fun ptr_as_volatile (p: ptr): void
//
(* ****** ****** *)
//
// overloading for certain symbols
//
overload succ with ptr0_succ
overload succ with ptr1_succ
overload succ with cptr_succ
//
overload pred with ptr0_pred
overload pred with ptr1_pred
overload pred with cptr_pred
//
overload iseqz with ptr0_is_null of 0
overload isneqz with ptr0_isnot_null of 0
//
overload iseqz with ptr1_is_null of 10
overload isneqz with ptr1_isnot_null of 10
//
overload iseqz with cptr_is_null of 10
overload isneqz with cptr_isnot_null of 10
//
(* ****** ****** *)

(* end of [pointer.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/grandom.atxt
** Time of generation: Sat Oct 17 15:19:47 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: June, 2015 *)

(* ****** ****** *)
//
fun{a:vt0p}
grandom_val (): a // for randval generation
//
fun{a:vt0p} // for random value
grandom_ref (x: &(a?) >> a): void // initialization
//
(* ****** ****** *)
//
fun{} grandom_int(): int
fun{} grandom_uint(): uint
//
fun{} grandom_bool(): bool
//
fun{} grandom_float(): float
fun{} grandom_double(): double
//
(* ****** ****** *)
//
fun{a:t0p}
grandom_list
  {n:nat}(n: int(n)): list(a, n)
//
fun{a:vt0p}
grandom_list_vt
  {n:nat}(n: int(n)): list_vt(a, n)
//
(* ****** ****** *)
//
fun{a:vt0p}
grandom_arrayptr
  {n:int}(asz: size_t(n)): arrayptr(a, n)
fun{a:vt0p}
grandom_arrayref
  {n:int}(asz: size_t(n)): arrayref(a, n)
//
fun{a:vt0p}
grandom_arrszref(asz: size_t): arrszref(a)
//
(* ****** ****** *)

(* end of [grandom.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)
(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/char.atxt
** Time of generation: Sat Oct 17 15:19:44 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)
//
praxi
lemma_char_size
(
// argumentless
) : [sizeof(char)==sizeof(byte)] void
praxi
lemma_schar_size
(
// argumentless
) : [sizeof(schar)==sizeof(byte)] void
praxi
lemma_uchar_size
(
// argumentless
) : [sizeof(uchar)==sizeof(byte)] void
//
(* ****** ****** *)
//
castfn char2schar0 (c: char):<> schar
castfn schar2char0 (c: schar):<> char
//
castfn char2uchar0 (c: char):<> uchar
castfn uchar2char0 (c: uchar):<> char
//
(* ****** ****** *)
//
fun int2char0 (i: int):<> char = "mac#%"
fun int2schar0 (i: int):<> schar = "mac#%"
fun int2uchar0 (i: int):<> uchar = "mac#%"
//
fun uint2uchar0 (u: uint):<> uchar = "mac#%"
//
(* ****** ****** *)

fun char2int0 (c: char):<> int = "mac#%"
fun schar2int0 (c: schar):<> int = "mac#%"
fun uchar2int0 (c: uchar):<> int = "mac#%"

(* ****** ****** *)

fun char2uint0 (c: char):<> uint = "mac#%"
fun schar2uint0 (c: schar):<> uint = "mac#%"
fun uchar2uint0 (c: uchar):<> uint = "mac#%"

(* ****** ****** *)

fun char2u2int0 (c: char):<> int = "mac#%"
fun char2u2uint0 (c: char):<> uint = "mac#%"

(* ****** ****** *)
//
fun char0_iseqz (c: char):<> bool = "mac#%"
fun char0_isneqz (c: char):<> bool = "mac#%"
//
overload iseqz with char0_iseqz of 0
overload isneqz with char0_isneqz of 0
//
(* ****** ****** *)
//
fun add_char0_int0
  (c: char, i: int):<> char = "mac#%"
fun sub_char0_int0
  (c: char, i: int):<> char = "mac#%"
fun sub_char0_char0
  (c1: char, c2: char):<> int = "mac#%"
//
overload + with add_char0_int0 of 0
overload - with sub_char0_int0 of 0
overload - with sub_char0_char0 of 0
//
(* ****** ****** *)

fun lt_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload < with lt_char0_char0 of 0
fun lte_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload <= with lte_char0_char0 of 0

fun gt_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload > with gt_char0_char0 of 0
fun gte_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload >= with gte_char0_char0 of 0

fun eq_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload = with eq_char0_char0 of 0
fun neq_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload != with neq_char0_char0 of 0
overload <> with neq_char0_char0 of 0

fun compare_char0_char0
  (c1: char, c2: char):<> int = "mac#%"
overload compare with compare_char0_char0 of 0

(* ****** ****** *)
//
castfn g0ofg1_char (c: Char):<> char
castfn g1ofg0_char (c: char):<> Char
//
overload g0ofg1 with g0ofg1_char // index-erasing
overload g1ofg0 with g1ofg0_char // index-inducing
//
(* ****** ****** *)
//
castfn
char2schar1 {c:int} (c: char (c)):<> schar (c)
castfn
schar2char1 {c:int} (c: schar (c)):<> char (c)
//
castfn
char2uchar1 {c:int} (c: char (c)):<> uchar (i2u8(c))
castfn
uchar2char1 {c:int} (c: uchar (c)):<> char (u2i8(c))
//
(* ****** ****** *)
//
fun char1_iseqz
  {c:int}(c: char(c)):<> bool(c == 0) = "mac#%"
fun char1_isneqz
  {c:int}(c: char(c)):<> bool(c != 0) = "mac#%"
//
overload iseqz with char1_iseqz of 10
overload isneqz with char1_isneqz of 10
//
(* ****** ****** *)

fun
lt_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 < c2) = "mac#%"
overload < with lt_char1_char1 of 20
fun
lte_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 <= c2) = "mac#%"
overload <= with lte_char1_char1 of 20

fun
gt_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 > c2) = "mac#%"
overload > with gt_char1_char1 of 20
fun
gte_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 >= c2) = "mac#%"
overload >= with gte_char1_char1 of 20

fun
eq_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 == c2) = "mac#%"
overload = with eq_char1_char1 of 20
fun
neq_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 != c2) = "mac#%"
overload != with neq_char1_char1 of 20
overload <> with neq_char1_char1 of 20

fun compare_char1_char1
  {c1,c2:int}
  (c1: char c1, c2: char c2) :<> int (c1-c2) = "mac#%"
overload compare with compare_char1_char1 of 20

(* ****** ****** *)
//
fun eq_char0_int0 : (char, int) -<fun0> bool = "mac#%"
fun eq_int0_char0 : (int, char) -<fun0> bool = "mac#%"
overload = with eq_char0_int0 of 0
overload = with eq_int0_char0 of 0
fun neq_char0_int0 : (char, int) -<fun0> bool = "mac#%"
fun neq_int0_char0 : (int, char) -<fun0> bool = "mac#%"
overload != with neq_char0_int0 of 0
overload <> with neq_char0_int0 of 0
overload != with neq_int0_char0 of 0
overload <> with neq_int0_char0 of 0
//
fun compare_char0_int0 : (char, int) -<fun0> int = "mac#%"
fun compare_int0_char0 : (int, char) -<fun0> int = "mac#%"
overload compare with compare_char0_int0
overload compare with compare_int0_char0
//
(* ****** ****** *)
//
// unsigned characters
//
(* ****** ****** *)

fun lt_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload < with lt_uchar0_uchar0 of 0
fun lte_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload <= with lte_uchar0_uchar0 of 0

fun gt_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload > with gt_uchar0_uchar0 of 0
fun gte_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload >= with gte_uchar0_uchar0 of 0

fun eq_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload = with eq_uchar0_uchar0 of 0
fun neq_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload != with neq_uchar0_uchar0 of 0
overload <> with neq_uchar0_uchar0 of 0

fun compare_uchar0_uchar0
  (c1: uchar, c2: uchar):<> int = "mac#%"
overload compare with compare_uchar0_uchar0 of 0

(* ****** ****** *)

fun
lt_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 < c2) = "mac#%"
overload < with lt_uchar1_uchar1 of 20
fun
lte_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 <= c2) = "mac#%"
overload <= with lte_uchar1_uchar1 of 20

fun
gt_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 > c2) = "mac#%"
overload > with gt_uchar1_uchar1 of 20
fun
gte_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 >= c2) = "mac#%"
overload >= with gte_uchar1_uchar1 of 20

fun
eq_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 == c2) = "mac#%"
overload = with eq_uchar1_uchar1 of 20
fun
neq_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 != c2) = "mac#%"
overload != with neq_uchar1_uchar1 of 20
overload <> with neq_uchar1_uchar1 of 20

fun compare_uchar1_uchar1
  {c1,c2:int}
  (c1: uchar c1, c2: uchar c2) :<> int (c1-c2) = "mac#%"
overload compare with compare_uchar1_uchar1 of 20

(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

fun{tk:tk}
g0int_of_char (c: char):<> g0int (tk)
fun{tk:tk}
g0int_of_schar (c: schar):<> g0int (tk)
fun{tk:tk}
g0int_of_uchar (c: uchar):<> g0int (tk)

fun{tk:tk}
g0uint_of_uchar (c: uchar):<> g0uint (tk)

(* ****** ****** *)

fun{tk:tk}
g1int_of_char1 // c:int8
  {c:int} (c: char (c)):<> g1int (tk, c)
// end of [g1int_of_char1]
fun{tk:tk}
g1int_of_schar1 // c:int8
  {c:int} (c: schar (c)):<> g1int (tk, c)
// end of [g1int_of_schar1]
fun{tk:tk}
g1int_of_uchar1 // c:uint8
  {c:int} (c: uchar (c)):<> g1int (tk, c)
// end of [g1int_of_uchar1]

(*
** HX: g1uint_of_schar1: schar -> int -> uint
*)
fun{tk:tk}
g1uint_of_uchar1
  {c:int} (c: uchar (c)):<> g1uint (tk, c)
// end of [g1uint_of_uchar1]

(* ****** ****** *)
//
// HX:
// return is dynamically allocated
//
fun{}
char2string(c: char):<> string
fun{}
char2strptr(c: char):<!wrt> Strptr1
//
(* ****** ****** *)

fun print_char (x: char): void = "mac#%"
fun prerr_char (x: char): void = "mac#%"
overload print with print_char
overload prerr with prerr_char
fun fprint_char : fprint_type (char) = "mac#%"
overload fprint with fprint_char
fun print_schar (x: schar): void = "mac#%"
fun prerr_schar (x: schar): void = "mac#%"
overload print with print_schar
overload prerr with prerr_schar
fun fprint_schar : fprint_type (schar) = "mac#%"
overload fprint with fprint_schar
fun print_uchar (x: uchar): void = "mac#%"
fun prerr_uchar (x: uchar): void = "mac#%"
overload print with print_uchar
overload prerr with prerr_uchar
fun fprint_uchar : fprint_type (uchar) = "mac#%"
overload fprint with fprint_uchar

(* ****** ****** *)

symintr isalpha
fun isalpha_int (c: int):<> bool = "mac#%"
overload isalpha with isalpha_int of 0
fun isalpha_char (c: char):<> bool = "mac#%"
overload isalpha with isalpha_char of 0
symintr isalnum
fun isalnum_int (c: int):<> bool = "mac#%"
overload isalnum with isalnum_int of 0
fun isalnum_char (c: char):<> bool = "mac#%"
overload isalnum with isalnum_char of 0

symintr isascii
fun isascii_int (c: int):<> bool = "mac#%"
overload isascii with isascii_int of 0
fun isascii_char (c: char):<> bool = "mac#%"
overload isascii with isascii_char of 0

symintr isblank
fun isblank_int (c: int):<> bool = "mac#%"
overload isblank with isblank_int of 0
fun isblank_char (c: char):<> bool = "mac#%"
overload isblank with isblank_char of 0
symintr isspace
fun isspace_int (c: int):<> bool = "mac#%"
overload isspace with isspace_int of 0
fun isspace_char (c: char):<> bool = "mac#%"
overload isspace with isspace_char of 0

symintr iscntrl
fun iscntrl_int (c: int):<> bool = "mac#%"
overload iscntrl with iscntrl_int of 0
fun iscntrl_char (c: char):<> bool = "mac#%"
overload iscntrl with iscntrl_char of 0

symintr isdigit
fun isdigit_int (c: int):<> bool = "mac#%"
overload isdigit with isdigit_int of 0
fun isdigit_char (c: char):<> bool = "mac#%"
overload isdigit with isdigit_char of 0
symintr isxdigit
fun isxdigit_int (c: int):<> bool = "mac#%"
overload isxdigit with isxdigit_int of 0
fun isxdigit_char (c: char):<> bool = "mac#%"
overload isxdigit with isxdigit_char of 0

symintr isgraph
fun isgraph_int (c: int):<> bool = "mac#%"
overload isgraph with isgraph_int of 0
fun isgraph_char (c: char):<> bool = "mac#%"
overload isgraph with isgraph_char of 0
symintr isprint
fun isprint_int (c: int):<> bool = "mac#%"
overload isprint with isprint_int of 0
fun isprint_char (c: char):<> bool = "mac#%"
overload isprint with isprint_char of 0
symintr ispunct
fun ispunct_int (c: int):<> bool = "mac#%"
overload ispunct with ispunct_int of 0
fun ispunct_char (c: char):<> bool = "mac#%"
overload ispunct with ispunct_char of 0

symintr islower
fun islower_int (c: int):<> bool = "mac#%"
overload islower with islower_int of 0
fun islower_char (c: char):<> bool = "mac#%"
overload islower with islower_char of 0
symintr isupper
fun isupper_int (c: int):<> bool = "mac#%"
overload isupper with isupper_int of 0
fun isupper_char (c: char):<> bool = "mac#%"
overload isupper with isupper_char of 0

(* ****** ****** *)

fun toascii (c: int):<> int = "mac#%"

(* ****** ****** *)

symintr tolower
fun tolower_int (c: int):<> int = "mac#%"
fun tolower_char (c: char):<> char = "mac#%"
overload tolower with tolower_int
overload tolower with tolower_char

symintr toupper
fun toupper_int (c: int):<> int = "mac#%"
fun toupper_char (c: char):<> char = "mac#%"
overload toupper with toupper_int
overload toupper with toupper_char

(* ****** ****** *)

fun int2digit (i: intBtw(0, 10)): char = "mac#%"
fun int2xdigit (i: intBtw(0, 16)): char = "mac#%"
fun int2xxdigit (i: intBtw(0, 16)): char = "mac#%"

(* ****** ****** *)

symintr c2uc
overload c2uc with char2uchar0 of 0
overload c2uc with char2uchar1 of 10
symintr uc2c
overload uc2c with uchar2char0 of 0
overload uc2c with uchar2char1 of 10

(* ****** ****** *)

symintr char2i
overload char2i with char2int0 of 0
symintr char2ui
overload char2ui with char2uint0 of 0
symintr uchar2i
overload uchar2i with uchar2int0 of 0
symintr uchar2ui
overload uchar2ui with uchar2uint0 of 0

(* ****** ****** *)

symintr char2u2i
overload char2u2i with char2u2int0 of 0
symintr char2u2ui
overload char2u2ui with char2u2uint0 of 0

(* ****** ****** *)
//
fun int2byte0 (i: int): byte = "mac#%"
fun byte2int0 (b: byte):<> int = "mac#%"
//
fun uint2byte0 (u: uint): byte = "mac#%"
fun byte2uint0 (b: byte):<> uint = "mac#%"
//
symintr byte2i
overload byte2i with byte2int0 of 0
symintr i2byte
overload i2byte with int2byte0 of 0
//
symintr byte2ui
overload byte2i with byte2uint0 of 0
symintr ui2byte
overload i2byte with uint2byte0 of 0
//
(* ****** ****** *)

(* end of [char.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/unsafe.atxt
** Time of generation: Sat Oct 17 15:19:46 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.prelude.unsafe"

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)
//
praxi
prop_assert{b:bool}((*void*)): [b] void
//
praxi
eqint_assert{i1,i2:int}((*void*)): EQINT(i1,i2)
praxi
eqaddr_assert{l1,l2:addr}((*void*)): EQADDR(l1,l2)
praxi
eqbool_assert{b1,b2:bool}((*void*)): EQBOOL(b1,b2)
//
(* ****** ****** *)
//
castfn
cast{to:t0p}{from:t0p} (x: INV(from)):<> to
//
(* ****** ****** *)
//
castfn
castvwtp0
  {to:vt0p}{from:vt0p} (x: INV(from)):<> to
//
// HX:
// [castvwtp1] is mostly used in a situation
// where a linear value is passed as a read-only value;
// for instance, casting [strptr] to [string] is often
// done for treating a linear string as a nonlinear one
// temporarily.
//
castfn
castvwtp1
  {to:vt0p}{from:vt0p} (x: !INV(from)>>from):<> to
//
(* ****** ****** *)
//
castfn cast2ptr {a:type} (x: INV(a)):<> ptr
castfn cast2Ptr0 {a:type} (x: INV(a)):<> Ptr0
castfn cast2Ptr1 {a:type} (x: INV(a)):<> Ptr1
//
castfn cast2int {a:t0p} (x: INV(a)):<> int
castfn cast2uint {a:t0p} (x: INV(a)):<> uint
//
castfn cast2lint {a:t0p} (x: INV(a)):<> lint
castfn cast2ulint {a:t0p} (x: INV(a)):<> ulint
//
castfn cast2llint {a:t0p} (x: INV(a)):<> llint
castfn cast2ullint {a:t0p} (x: INV(a)):<> ullint
//
castfn cast2size {a:t0p} (x: INV(a)):<> size_t
castfn cast2ssize {a:t0p} (x: INV(a)):<> ssize_t
//
castfn cast2sint {a:t0p} (x: INV(a)):<> sint
castfn cast2usint {a:t0p} (x: INV(a)):<> usint
//
castfn cast2intptr {a:t0p} (x: INV(a)):<> intptr
castfn cast2uintptr {a:t0p} (x: INV(a)):<> uintptr
//
(* ****** ****** *)

praxi cast2void {a:vt0p} (x: INV(a)):<prf> void

(* ****** ****** *)
//
praxi castview0 {to:view}{from:view} (pf: from):<prf> to
praxi castview1 {to:view}{from:view} (pf: !INV(from)):<prf> to
//
praxi castview2void {to:view}{from:view} (x: !INV(from) >> to):<prf> void
//
praxi castvwtp2void {to:vt0p}{from:vt0p} (x: !INV(from) >> to):<prf> void
//
(* ****** ****** *)

fun{} int2ptr (i: int): ptr and ptr2int (p: ptr): int

(* ****** ****** *)
//
// HX: these are popular ones:
//
castfn list_vt2t
  {a:t0p}{n:int} (xs: !list_vt (INV(a), n)):<> list (a, n)
// end of [list_vt2t]

castfn arrayptr2ref
  {a:vt0p}{n:int} (x: !arrayptr (INV(a), n)):<> arrayref (a, n)
// end of [arrayptr2ref]

castfn strptr2string {l:agz} (x: !strptr l):<> String0
castfn strptr2stropt {l:addr} (x: !strptr l):<> Stropt0
castfn strnptr2string {l:addr}{n:nat} (x: !strnptr (l, n)):<> string (n)

(* ****** ****** *)
//
// HX: only if you know what you are doing ...
//
symintr ptr_vtake

castfn ptr0_vtake
  {a:vt0p} (ptr):<> [l:addr] (a@l, a@l -<lin,prf> void | ptr l)
overload ptr_vtake with ptr0_vtake of 0

castfn ptr1_vtake
  {a:vt0p}{l:addr} (ptr l):<> (a@l, a@l -<lin,prf> void | ptr l) 
overload ptr_vtake with ptr1_vtake of 10

(* ****** ****** *)

castfn
ref_vtake{a:vt0p}
  {l:addr} (r: ref (a)):<> [l:addr] (a@l, a@l -<lin,prf> void | ptr l)
// end of [ref_vtake]

(* ****** ****** *)

praxi
vtakeout_void {v:view} (pf: !v): vtakeout0 (v)
castfn
vttakeout_void {a:vt0p} (x: !a):<> vttakeout0 (a)

(* ****** ****** *)
//
// HX: only if you know what you are doing ...
//
fun{a:vt0p} ptr0_get (p: ptr):<> a
fun{a:vt0p} ptr1_get (p: Ptr1):<> a
//
fun{a:vt0p} ptr0_set (p: ptr, x: INV(a)):<!wrt> void
fun{a:vt0p} ptr1_set (p: Ptr1, x: INV(a)):<!wrt> void
//
fun{a:vt0p} ptr0_exch (p: ptr, x: &INV(a) >> a):<!wrt> void
fun{a:vt0p} ptr1_exch (p: Ptr1, x: &INV(a) >> a):<!wrt> void
//
fun{a:vt0p} ptr0_intch (p1: ptr, p2: ptr):<!wrt> void
fun{a:vt0p} ptr1_intch (p1: Ptr1, p2: Ptr1):<!wrt> void
//
(* ****** ****** *)
//
fun{a:vt0p}
ptr0_get_at_int (p: ptr, i: int):<> a
fun{a:vt0p}
ptr0_set_at_int (p: ptr, i: int, x: a):<!wrt> void
fun{a:vt0p}
ptr0_get_at_size (p: ptr, i: size_t):<> a
fun{a:vt0p}
ptr0_set_at_size (p: ptr, i: size_t, x: a):<!wrt> void
//
symintr ptr0_get_at
symintr ptr0_set_at
//
overload ptr0_get_at with ptr0_get_at_int
overload ptr0_get_at with ptr0_get_at_size
overload ptr0_set_at with ptr0_set_at_int
overload ptr0_set_at with ptr0_set_at_size
//
(* ****** ****** *)
//
// HX-2012-06:
// generic ops on numbers: +=, -=, *=, /=, %=
//
fun{a:t0p} ptr0_addby (p: ptr, x: a):<!wrt> void // !p += x
fun{a:t0p} ptr1_addby (p: Ptr1, x: a):<!wrt> void // !p += x
//
fun{a:t0p} ptr0_subby (p: ptr, x: a):<!wrt> void // !p -= x
fun{a:t0p} ptr1_subby (p: Ptr1, x: a):<!wrt> void // !p -= x
//
fun{a:t0p} ptr0_mulby (p: ptr, x: a):<!wrt> void // !p *= x
fun{a:t0p} ptr1_mulby (p: Ptr1, x: a):<!wrt> void // !p *= x
//
fun{a:t0p} ptr0_divby (p: ptr, x: a):<!exnwrt> void // !p /= x
fun{a:t0p} ptr1_divby (p: Ptr1, x: a):<!exnwrt> void // !p /= x
//
fun{a:t0p} ptr0_modby (p: ptr, x: a):<!exnwrt> void // !p %= x
fun{a:t0p} ptr1_modby (p: Ptr1, x: a):<!exnwrt> void // !p %= x
//
(* ****** ****** *)

fun{a:vt0p} ptr1_list_next (p: Ptr1): Ptr0 // HX: &(p->next)

(* ****** ****** *)
//
// HX: only if you know what you are doing ...
//
castfn
ptr2cptr{a:vt0p}{l:addr} (p: ptr(l)):<> cptr (a, l)
//
(* ****** ****** *)
//
castfn
cptr_vtake
  {a:vt0p}{l:agz}
  (p: cptr (INV(a), l)):<> (a@l, a@l -<lin,prf> void | ptr l)
// end of [cptr_vtake]
//
fun{a:vt0p} cptr_get (p: cPtr1 (INV(a))):<> a
fun{a:vt0p} cptr_set (p: cPtr1 (INV(a)), x: a):<!wrt> void
fun{a:vt0p} cptr_exch (p: cPtr1 (INV(a)), x: &a >> a):<!wrt> void
//
(* ****** ****** *)

(* end of [unsafe.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/tostring.atxt
** Time of generation: Sat Oct 17 15:19:50 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2012 *)

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef t0p = t@ype
sortdef vt0p = vt@ype

(* ****** ****** *)

fun{}
tostring_int(int):<> string
fun{}
tostrptr_int(int):<!wrt> Strptr1

(* ****** ****** *)

fun{}
tostring_uint(uint):<> string
fun{}
tostrptr_uint(uint):<!wrt> Strptr1

(* ****** ****** *)

fun{}
tostring_bool(bool):<> string
fun{}
tostrptr_bool(bool):<!wrt> Strptr1

(* ****** ****** *)

fun{}
tostring_char(char):<> string
fun{}
tostrptr_char(char):<!wrt> Strptr1

(* ****** ****** *)
//
fun
{a:t0p}
tostrptr_list
  (xs0: List(INV(a))): Strptr1
//
fun{}
tostrptr_list$beg((*void*)): String
fun{}
tostrptr_list$end((*void*)): String
fun{}
tostrptr_list$sep((*void*)): String
//
(* ****** ****** *)
//
fun
{a:vt0p}
tostrptr_array
  {n:int}
(
  &array(INV(a), n), size_t(n)
) : Strptr1 // end-of-function
//
fun{}
tostrptr_array$beg((*void*)): String
fun{}
tostrptr_array$end((*void*)): String
fun{}
tostrptr_array$sep((*void*)): String
//
(* ****** ****** *)
//
fun
{a:vt0p}
tostrptr_arrayref
  {n:int}
  (arrayref(a,n), size_t(n)): Strptr1
//
fun
{a:vt0p}
tostrptr_arrszref(arrszref(a)): Strptr1
//
(* ****** ****** *)

(* end of [tostring.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/integer.atxt
** Time of generation: Sat Oct 17 15:19:43 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)
//
// HX: for unindexed integer types
//
(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

typedef SHR(a:t@ype) = a // for commenting purpose
typedef NSH(a:t@ype) = a // for commenting purpose

(* ****** ****** *)
//
stadef intknd = int_kind
stadef lintknd = lint_kind
stadef llintknd = llint_kind
stadef ssizeknd = ssize_kind
//
stadef uintknd = uint_kind
stadef ulintknd = ulint_kind
stadef ullintknd = ullint_kind
stadef sizeknd = size_kind
//
(* ****** ****** *)
//
fun{
k1,k2:tk
} g0int2int (x: g0int (k1)):<> g0int (k2)
//
fun g0int2int_int_int (x: int):<> int = "mac#%"
fun g0int2int_int_lint (x: int):<> lint = "mac#%"
fun g0int2int_int_llint (x: int):<> llint = "mac#%"
fun g0int2int_int_ssize (x: int):<> ssize_t = "mac#%"
//
fun g0int2int_lint_int (x: int):<> int = "mac#%"
fun g0int2int_lint_lint (x: int):<> lint = "mac#%"
fun g0int2int_lint_llint (x: int):<> llint = "mac#%"
fun g0int2int_lint_ssize (x: int):<> ssize_t = "mac#%"
//
fun g0int2int_ssize_int (x: int):<> int = "mac#%"
fun g0int2int_ssize_lint (x: int):<> lint = "mac#%"
fun g0int2int_ssize_llint (x: int):<> llint = "mac#%"
fun g0int2int_ssize_ssize (x: int):<> ssize_t = "mac#%"
//
fun g0int2int_sint_int (x: sint):<> int = "mac#%"
//
(* ****** ****** *)
//
// HX-2015-09-20:
// These functions are implemented in prelude/string.cats:
//
fun{tk:tk}
g0int2string (x: g0int (tk)):<!wrt> Strptr1
//
fun g0int2string_int (x: int):<!wrt> Strptr1 = "mac#%"
fun g0int2string_lint (x: lint):<!wrt> Strptr1 = "mac#%"
fun g0int2string_llint (x: llint):<!wrt> Strptr1 = "mac#%"
(*
fun g0int2string_ssize (x: ssize_t):<!wrt> Strptr1 = "mac#%"
*)
//
(* ****** ****** *)
//
fun{tk:tk}
g0string2int (str: NSH(string)):<> g0int (tk)
//
fun g0string2int_int (x: NSH(string)):<> int = "mac#%"
fun g0string2int_lint (x: NSH(string)):<> lint = "mac#%"
fun g0string2int_llint (x: NSH(string)):<> llint = "mac#%"
fun g0string2int_ssize (x: NSH(string)):<> ssize_t = "mac#%"
//
(* ****** ****** *)

typedef
g0int_uop_type
  (tk: tkind) = (g0int (tk)) -<fun0> g0int (tk)
// end of [g0int_uop_type]

(* ****** ****** *)

fun
{tk:tk}
g0int_neg : g0int_uop_type(tk)
overload ~ with g0int_neg of 0 // ~ for uminus
overload neg with g0int_neg of 0

fun
{tk:tk}
g0int_abs : g0int_uop_type(tk)
overload abs with g0int_abs of 0

(* ****** ****** *)

fun
{tk:tk}
g0int_succ : g0int_uop_type(tk)
overload succ with g0int_succ of 0

fun
{tk:tk}
g0int_pred : g0int_uop_type(tk)
overload pred with g0int_pred of 0

(* ****** ****** *)

fun
{tk:tk}
g0int_half : g0int_uop_type(tk)
overload half with g0int_half of 0

(*
fun
{tk:tk}
g0int_double : g0int_uop_type(tk)
overload double with g0int_double of 0
*)

(* ****** ****** *)

typedef
g0int_aop_type (tk: tkind) =
   (g0int (tk), g0int (tk)) -<fun0> g0int (tk)
// end of [g0int_aop_type]

fun
{tk:tk}
g0int_add : g0int_aop_type(tk)
overload + with g0int_add of 0
fun
{tk:tk}
g0int_sub : g0int_aop_type(tk)
overload - with g0int_sub of 0
fun
{tk:tk}
g0int_mul : g0int_aop_type(tk)
overload * with g0int_mul of 0
fun
{tk:tk}
g0int_div : g0int_aop_type(tk)
overload / with g0int_div of 0
fun
{tk:tk}
g0int_mod : g0int_aop_type(tk)
overload % with g0int_mod of 0
overload mod with g0int_mod of 0

(* ****** ****** *)

fun{}
mul_int1_size0 {i:nat} (int(i), size_t):<> size_t
fun{}
mul_size0_int1 {j:nat} (size_t, int(j)):<> size_t

(* ****** ****** *)

overload * with mul_int1_size0 of 11
overload * with mul_size0_int1 of 11

(* ****** ****** *)
//
fun
{tk:tk}
g0int_asl
  (x: g0int(tk), n: intGte(0)):<> g0int(tk)
fun
{tk:tk}
g0int_asr
  (x: g0int(tk), n: intGte(0)):<> g0int(tk)
//
overload << with g0int_asl of 0
overload >> with g0int_asr of 0
//
(* ****** ****** *)
//
fun
{tk:tk}
g0int_npow
  (x: g0int(tk), n: intGte(0)):<> g0int(tk)
//
overload ** with g0int_npow of 0
//
(* ****** ****** *)
//
fun{tk:tk}
g0int_isltz (x: g0int (tk)):<> bool
fun{tk:tk}
g0int_isltez (x: g0int (tk)):<> bool
//
fun{tk:tk}
g0int_isgtz (x: g0int (tk)):<> bool
fun{tk:tk}
g0int_isgtez (x: g0int (tk)):<> bool
//
fun{tk:tk}
g0int_iseqz (x: g0int (tk)):<> bool
fun{tk:tk}
g0int_isneqz (x: g0int (tk)):<> bool
//
overload isltz with g0int_isltz of 0
overload isltez with g0int_isltez of 0
overload isgtz with g0int_isgtz of 0
overload isgtez with g0int_isgtez of 0
overload iseqz with g0int_iseqz of 0
overload isneqz with g0int_isneqz of 0
//
(* ****** ****** *)

typedef
g0int_cmp_type (tk:tk) =
  (g0int (tk), g0int (tk)) -<fun0> bool
// end of [g0int_cmp_type]

fun
{tk:tk}
g0int_lt : g0int_cmp_type(tk)
overload < with g0int_lt of 0
fun
{tk:tk}
g0int_lte : g0int_cmp_type(tk)
overload <= with g0int_lte of 0

fun
{tk:tk}
g0int_gt : g0int_cmp_type(tk)
overload > with g0int_gt of 0
fun
{tk:tk}
g0int_gte : g0int_cmp_type(tk)
overload >= with g0int_gte of 0

fun
{tk:tk}
g0int_eq : g0int_cmp_type(tk)
overload = with g0int_eq of 0
fun
{tk:tk}
g0int_neq : g0int_cmp_type(tk)
overload != with g0int_neq of 0
overload <> with g0int_neq of 0

(* ****** ****** *)

fun{tk:tk}
g0int_compare
  (x: g0int (tk), y: g0int (tk)):<> int
overload compare with g0int_compare of 0

(* ****** ****** *)

fun
{tk:tk}
g0int_max : g0int_aop_type(tk)
overload max with g0int_max of 0
fun
{tk:tk}
g0int_min : g0int_aop_type(tk)
overload min with g0int_min of 0

(* ****** ****** *)

fun{tk:tk}
lt_g0int_int (x: g0int (tk), y: int):<> bool
overload < with lt_g0int_int of 11
fun{tk:tk}
lte_g0int_int (x: g0int (tk), y: int):<> bool
overload <= with lte_g0int_int of 11
//
fun{tk:tk}
gt_g0int_int (x: g0int (tk), y: int):<> bool
overload > with gt_g0int_int of 11
fun{tk:tk}
gte_g0int_int (x: g0int (tk), y: int):<> bool
overload >= with gte_g0int_int of 11
//
fun{tk:tk}
eq_g0int_int (x: g0int (tk), y: int):<> bool
overload = with eq_g0int_int of 11
fun{tk:tk}
neq_g0int_int (x: g0int (tk), y: int):<> bool
overload != with neq_g0int_int of 11
overload <> with neq_g0int_int of 11
//
fun{tk:tk}
compare_g0int_int (x: g0int (tk), y: int):<> int
overload compare with compare_g0int_int of 11

(* ****** ****** *)
//
// HX: for indexed integer types
//
castfn
g0ofg1_int {tk:tk} (x: g1int tk):<> g0int (tk)
castfn
g1ofg0_int {tk:tk} (x: g0int tk):<> g1int (tk)
overload g0ofg1 with g0ofg1_int // index-erasing
overload g1ofg0 with g1ofg0_int // index-inducing
//
(* ****** ****** *)
//
fun{
k1,k2:tk
} g1int2int // i2i
  {i:int} (x: g1int (k1, i)):<> g1int (k2, i)
//
fun g1int2int_int_int {i:int} (x: int i):<> int (i) = "mac#%"
fun g1int2int_int_lint {i:int} (x: int i):<> lint (i) = "mac#%"
fun g1int2int_int_llint {i:int} (x: int i):<> llint (i) = "mac#%"
fun g1int2int_int_ssize {i:int} (x: int i):<> ssize_t (i) = "mac#%"
//
(* ****** ****** *)

fun{tk:tk}
g1string2int (str: NSH(string)):<> g1int (tk)

(* ****** ****** *)

prfun
g1int_get_index
  {tk:tk}{i1:int}
  (x: g1int (tk, i1)): [i2:int] EQINT (i1, i2)
// end of [g1int_get_index]

(* ****** ****** *)

typedef
g1int_neg_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, ~i)
fun
{tk:tk}
g1int_neg : g1int_neg_type(tk)
overload ~ with g1int_neg of 10 // ~ for uminus
overload neg with g1int_neg of 10

typedef
g1int_abs_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, abs(i))
fun
{tk:tk}
g1int_abs : g1int_abs_type(tk)
overload abs with g1int_abs of 10

(* ****** ****** *)

typedef
g1int_succ_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, i+1)
fun{tk:tk}
g1int_succ : g1int_succ_type(tk)
overload succ with g1int_succ of 10

typedef
g1int_pred_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, i-1)
fun{tk:tk}
g1int_pred : g1int_pred_type(tk)
overload pred with g1int_pred of 10

typedef
g1int_half_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, i/2)
fun{tk:tk}
g1int_half : g1int_half_type(tk)
overload half with g1int_half of 10

(*
typedef
g1int_double_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, 2*i)
fun{tk:tk}
g1int_double : g1int_double_type(tk)
overload double with g1int_double of 10
*)

(* ****** ****** *)
//
typedef
g1int_add_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk,i), g1int (tk,j)) -<fun0> g1int (tk, i+j)
//
fun
{tk:tk}
g1int_add : g1int_add_type(tk)
//
fun{}
add_size1_int1
  {i,j:int | i+j >= 0} (x: size_t (i), j: int (j)):<> size_t (i+j)
fun{}
add_int1_size1
  {i,j:int | i+j >= 0} (x: int (i), j: size_t (j)):<> size_t (i+j)
//
(* ****** ****** *)

overload + with g1int_add of 20
overload + with add_size1_int1 of 22
overload + with add_int1_size1 of 22

(* ****** ****** *)
//
typedef
g1int_sub_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk,i), g1int (tk,j)) -<fun0> g1int (tk, i-j)
//
fun
{tk:tk}
g1int_sub : g1int_sub_type(tk)
//
fun{}
sub_size1_int1
  {i,j:int | i-j >= 0} (x: size_t (i), j: int (j)):<> size_t (i-j)
//
(* ****** ****** *)

overload - with g1int_sub of 20
overload - with sub_size1_int1 of 22

(* ****** ****** *)
//
typedef
g1int_mul_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk,i), g1int (tk,j)) -<fun0> g1int (tk, i*j)
//
fun
{tk:tk}
g1int_mul : g1int_mul_type(tk)
//
fun
{tk:tk}
g1int_mul2
  {i,j:int}
(
  x: g1int (tk, i)
, y: g1int (tk, j)
) :<> [ij:int]
  (MUL (i, j, ij) | g1int (tk, ij))
// end of [g1int_mul2]
//
fun{}
mul_int1_size1
  {i,j:int | i >= 0} (x: int (i), j: size_t (j)):<> size_t (i*j)
fun{}
mul_size1_int1
  {i,j:int | j >= 0} (x: size_t (i), j: int (j)):<> size_t (i*j)
//
(* ****** ****** *)

overload * with g1int_mul of 20
overload * with mul_int1_size1 of 22
overload * with mul_size1_int1 of 22

(* ****** ****** *)
//
typedef
g1int_div_type
  (tk:tk) =
  {i,j:int | j != 0}
  (g1int (tk, i), g1int (tk, j)) -<fun0> g1int (tk)
//
fun
{tk:tk}
g1int_div : g1int_div_type(tk)
//
(* ****** ****** *)
//
typedef
g1int_ndiv_type
  (tk:tk) =
  {i,j:int | i >= 0; j > 0}
  (g1int (tk, i), g1int (tk, j)) -<fun0> g1int (tk, ndiv_int_int(i,j))
//
fun{tk:tk}
g1int_ndiv : g1int_ndiv_type(tk)

(* ****** ****** *)

fun{tk:tk}
g1int_ndiv2
  {i,j:int | i >= 0; j > 0}
(
  x: g1int (tk, i), y: g1int (tk, j)
) :<>
[
  q,r:int | 0 <= r; r < j
] (
  DIVMOD (i, j, q, r) | g1int (tk, q)
) (* end of [g1int_ndiv2] *)

(* ****** ****** *)

overload / with g1int_div of 20
overload ndiv with g1int_ndiv of 20

(* ****** ****** *)

(*
** HX: [g1int_mod] is intentionally skipped
*)

(* ****** ****** *)

typedef
g1int_nmod_type
  (tk:tk) =
  {i,j:int | i >= 0; j > 0}
  (g1int (tk, i), g1int (tk, j)) -<fun0> g1int (tk, nmod_int_int(i, j))
// end of [g1int_nmod_type]

fun{tk:tk}
g1int_nmod : g1int_nmod_type(tk)

(* ****** ****** *)

fun{tk:tk}
g1int_nmod2
  {i,j:int | i >= 0; j > 0}
(
  x: g1int (tk, i), y: g1int (tk, j)
) :<> [q,r:nat | r < j]
(
  DIVMOD (i, j, q, r) | g1int (tk, r)
) (* end of [g1int_nmod2] *)

(* ****** ****** *)
//
fun{tk:tk}
nmod_g1int_int1
  {i,j:int | i >= 0; j > 0}
  (x: g1int (tk, i), y: int (j)):<> int(i%j)
//
fun{tk:tk}
nmod2_g1int_int1
  {i,j:int | i >= 0; j > 0}
(
  x: g1int (tk, i), y: int (j)
) :<> [q,r:nat | r < j] (DIVMOD (i, j, q, r) | int (r))
//
(* ****** ****** *)

overload nmod with g1int_nmod of 20
overload nmod with nmod_g1int_int1 of 21

(* ****** ****** *)

typedef
g1int_ngcd_type
  (tk:tk) =
  {i,j:int | i >= 0; j >= 0}
  (g1int (tk, i), g1int (tk, j)) -<fun0> [r:nat] g1int (tk, r)
// end of [g1int_ngcd_type]

fun{tk:tk}
g1int_ngcd : g1int_ngcd_type(tk)
(*
overload ngcd with g1int_ngcd of 20 // HX: [ngcd] is no longer pre-declared
*)

(* ****** ****** *)

typedef
g1int_isltz_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i < 0)
typedef
g1int_isltez_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i <= 0)
fun{tk:tk}
g1int_isltz : g1int_isltz_type(tk)
overload isltz with g1int_isltz of 10
fun{tk:tk}
g1int_isltez : g1int_isltez_type(tk)
overload isltez with g1int_isltez of 10

(* ****** ****** *)

typedef
g1int_isgtz_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i > 0)
typedef
g1int_isgtez_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i >= 0)
fun{tk:tk}
g1int_isgtz : g1int_isgtz_type(tk)
overload isgtz with g1int_isgtz of 10
fun{tk:tk}
g1int_isgtez : g1int_isgtez_type(tk)
overload isgtez with g1int_isgtez of 10

(* ****** ****** *)

typedef
g1int_iseqz_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i > 0)
typedef
g1int_isneqz_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i >= 0)
fun{tk:tk}
g1int_iseqz : g1int_iseqz_type(tk)
overload iseqz with g1int_iseqz of 10
fun{tk:tk}
g1int_isneqz : g1int_isneqz_type(tk)
overload isneqz with g1int_isneqz of 10

(* ****** ****** *)
//
typedef
g1int_lt_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i < j)
typedef
g1int_lte_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i <= j)
//
fun{tk:tk}
g1int_lt : g1int_lt_type(tk)
overload < with g1int_lt of 20
fun{tk:tk}
g1int_lte : g1int_lte_type(tk)
overload <= with g1int_lte of 20
//
(* ****** ****** *)
//
typedef
g1int_gt_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i > j)
typedef
g1int_gte_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i >= j)
//
fun
{tk:tk}
g1int_gt : g1int_gt_type(tk)
overload > with g1int_gt of 20
fun
{tk:tk}
g1int_gte : g1int_gte_type(tk)
overload >= with g1int_gte of 20
//
(* ****** ****** *)
//
typedef
g1int_eq_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i == j)
typedef
g1int_neq_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i != j)
//
fun
{tk:tk}
g1int_eq : g1int_eq_type(tk)
overload = with g1int_eq of 20
fun
{tk:tk}
g1int_neq : g1int_neq_type(tk)
overload != with g1int_neq of 20
overload <> with g1int_neq of 20
//
(* ****** ****** *)
//
typedef
g1int_compare_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> int (sgn(i-j))
//
fun{tk:tk}
g1int_compare : g1int_compare_type(tk)
overload compare with g1int_compare of 20
//
(* ****** ****** *)
//
typedef
g1int_max_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> g1int (tk, max(i, j))
//
fun
{tk:tk}
g1int_max : g1int_max_type(tk)
overload max with g1int_max of 20
//
typedef
g1int_min_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> g1int (tk, min(i, j))
//
fun
{tk:tk}
g1int_min : g1int_min_type(tk)
overload min with g1int_min of 20
//
(* ****** ****** *)

fun{tk:tk}
lt_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i < j)
overload < with lt_g1int_int of 21
fun{tk:tk}
lte_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i <= j)
overload <= with lte_g1int_int of 21
//
fun{tk:tk}
gt_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i > j)
overload > with gt_g1int_int of 21
fun{tk:tk}
gte_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i >= j)
overload >= with gte_g1int_int of 21
//
fun{tk:tk}
eq_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i == j)
overload = with eq_g1int_int of 21
fun{tk:tk}
neq_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i != j)
overload != with neq_g1int_int of 21
overload <> with neq_g1int_int of 21
//
fun{tk:tk}
compare_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> int (sgn(i-j))
overload compare with compare_g1int_int of 21
//
(* ****** ****** *)

fun
{tk:tk}
g1int_sgn {i:int} (x: g1int (tk, i)):<> int(sgn(i))

(* ****** ****** *)
//
// HX: for unsigned unindexed integer types
//
(* ****** ****** *)

fun{
k1,k2:tk
} g0int2uint (x: g0int (k1)):<> g0uint (k2)
//
fun g0int2uint_int_uint (x: int):<> uint = "mac#%"
fun g0int2uint_int_ulint (x: int):<> ulint = "mac#%"
fun g0int2uint_int_ullint (x: int):<> ullint = "mac#%"
fun g0int2uint_int_size (x: int):<> size_t = "mac#%"
//
fun g0int2uint_lint_ulint (x: lint):<> ulint = "mac#%"
fun g0int2uint_lint_ullint (x: lint):<> ullint = "mac#%"
fun g0int2uint_lint_size (x: lint):<> size_t = "mac#%"
//
fun g0int2uint_llint_ullint (x: llint):<> ullint = "mac#%"
//
fun g0int2uint_ssize_size (x: ssize_t):<> size_t = "mac#%"
//
(* ****** ****** *)

fun{
k1,k2:tk
} g0uint2int (x: g0uint (k1)):<> g0int (k2)
//
fun g0uint2int_uint_int (x: uint):<> int = "mac#%"
fun g0uint2int_uint_lint (x: uint):<> lint = "mac#%"
fun g0uint2int_uint_llint (x: uint):<> llint = "mac#%"
fun g0uint2int_uint_ssize (x: uint):<> ssize_t = "mac#%"
//
fun g0uint2int_size_int (x: size_t):<> int = "mac#%"
fun g0uint2int_size_lint (x: size_t):<> lint = "mac#%"
fun g0uint2int_size_llint (x: size_t):<> llint = "mac#%"
fun g0uint2int_size_ssize (x: size_t):<> ssize_t = "mac#%"
//
(* ****** ****** *)

fun{
k1,k2:tk
} g0uint2uint (x: g0uint (k1)):<> g0uint (k2)
//
fun g0uint2uint_uint_uint (x: uint):<> uint = "mac#%"
fun g0uint2uint_uint_ulint (x: uint):<> ulint = "mac#%"
fun g0uint2uint_uint_ullint (x: uint):<> ullint = "mac#%"
fun g0uint2uint_uint_size (x: uint):<> size_t = "mac#%"
//
fun g0uint2uint_ulint_uint (x: ulint):<> uint = "mac#%"
fun g0uint2uint_ulint_ulint (x: ulint):<> ulint = "mac#%"
fun g0uint2uint_ulint_ullint (x: ulint):<> ullint = "mac#%"
fun g0uint2uint_ulint_size (x: ulint):<> size_t = "mac#%"
//
fun g0uint2uint_size_uint (x: size_t):<> uint = "mac#%"
fun g0uint2uint_size_ulint (x: size_t):<> ulint = "mac#%"
fun g0uint2uint_size_ullint (x: size_t):<> ullint = "mac#%"
fun g0uint2uint_size_size (x: size_t):<> size_t = "mac#%"
//
fun g0uint2uint_usint_uint (x: usint):<> uint = "mac#%"
//
(* ****** ****** *)

fun{tk:tk}
g0string2uint (str: NSH(string)):<> g0uint (tk)
//
fun g0string2uint_uint (x: NSH(string)):<> uint = "mac#%"
fun g0string2uint_ulint (x: NSH(string)):<> ulint = "mac#%"
fun g0string2uint_ullint (x: NSH(string)):<> ullint = "mac#%"
fun g0string2uint_size (x: NSH(string)):<> size_t = "mac#%"
//
(* ****** ****** *)

fun{tk:tk}
g0uint_succ (x: g0uint (tk)):<> g0uint (tk)
overload succ with g0uint_succ of 0
fun{tk:tk}
g0uint_pred (x: g0uint (tk)):<> g0uint (tk)
overload pred with g0uint_pred of 0

fun{tk:tk}
g0uint_half (x: g0uint (tk)):<> g0uint (tk)
overload half with g0uint_half of 0

(*
fun{tk:tk}
g0uint_double (x: g0uint (tk)):<> g0uint (tk)
overload double with g0uint_double of 0
*)

(* ****** ****** *)

fun{
tk:tk
} g0uint_add
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload + with g0uint_add of 0
fun{
tk:tk
} g0uint_sub
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload - with g0uint_sub of 0
fun{
tk:tk
} g0uint_mul
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload * with g0uint_mul of 0
fun{
tk:tk
} g0uint_div
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload / with g0uint_div of 0
fun{
tk:tk
} g0uint_mod
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload % with g0uint_mod of 0
overload mod with g0uint_mod of 0

(* ****** ****** *)

fun
{tk:tk}
g0uint_lsl (x: g0uint (tk), n: intGte(0)):<> g0uint (tk)
overload << with g0uint_lsl
fun
{tk:tk}
g0uint_lsr (x: g0uint (tk), n: intGte(0)):<> g0uint (tk)
overload >> with g0uint_lsr

(* ****** ****** *)

fun
{tk:tk}
g0uint_lnot (x: g0uint (tk)):<> g0uint (tk)
overload ~ with g0uint_lnot
overload lnot with g0uint_lnot
fun
{tk:tk}
g0uint_lor (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload lor with g0uint_lor
fun
{tk:tk}
g0uint_lxor (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload lxor with g0uint_lxor
fun
{tk:tk}
g0uint_land (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload land with g0uint_land

(* ****** ****** *)

fun{tk:tk}
g0uint_isgtz (x: g0uint (tk)):<> bool
overload isgtz with g0uint_isgtz of 0
fun{tk:tk}
g0uint_iseqz (x: g0uint (tk)):<> bool
overload iseqz with g0uint_iseqz of 0
fun{tk:tk}
g0uint_isneqz (x: g0uint (tk)):<> bool
overload isneqz with g0uint_isneqz of 0

(* ****** ****** *)

fun{
tk:tk
} g0uint_lt
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload < with g0uint_lt of 0
fun{
tk:tk
} g0uint_lte
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload <= with g0uint_lte of 0

fun{
tk:tk
} g0uint_gt
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload > with g0uint_gt of 0
fun{
tk:tk
} g0uint_gte
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload >= with g0uint_gte of 0

fun{
tk:tk
} g0uint_eq
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload = with g0uint_eq of 0
fun{
tk:tk
} g0uint_neq
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload != with g0uint_neq of 0
overload <> with g0uint_neq of 0

fun{tk:tk}
g0uint_compare (x: g0uint (tk), y: g0uint (tk)):<> int
overload compare with g0uint_compare of 0

(* ****** ****** *)

fun
{tk:tk}
g0uint_max
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload max with g0uint_max of 0

fun
{tk:tk}
g0uint_min
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload min with g0uint_min of 0

(* ****** ****** *)

fun{tk:tk}
lt_g0uint_int (x: g0uint (tk), y: int):<> bool
overload < with lt_g0uint_int of 11
fun{tk:tk}
lte_g0uint_int (x: g0uint (tk), y: int):<> bool
overload <= with lte_g0uint_int of 11

fun{tk:tk}
gt_g0uint_int (x: g0uint (tk), y: int):<> bool
overload > with gt_g0uint_int of 11
fun{tk:tk}
gte_g0uint_int (x: g0uint (tk), y: int):<> bool
overload >= with gte_g0uint_int of 11

fun{tk:tk}
eq_g0uint_int (x: g0uint (tk), y: int):<> bool
overload = with eq_g0uint_int of 11
fun{tk:tk}
neq_g0uint_int (x: g0uint (tk), y: int):<> bool
overload != with neq_g0uint_int of 11
overload <> with neq_g0uint_int of 11

(* ****** ****** *)
//
// HX: for unsigned indexed integer types
//
praxi
lemma_g1uint_param
  {tk:tk} {i:int} (x: g1uint (tk, i)):<> [i >= 0] void
// end of [lemma_g1uint_param]

(* ****** ****** *)

castfn
size_of_int {i:nat} (x: int i):<> size_t (i)
castfn
ssize_of_int {i:int} (x: int i):<> ssize_t (i)

(* ****** ****** *)
//
castfn
g0ofg1_uint {tk:tk} (x: g1uint tk):<> g0uint (tk)
castfn
g1ofg0_uint {tk:tk} (x: g0uint tk):<> g1uint0 (tk)
//
overload g0ofg1 with g0ofg1_uint // index-erasing
overload g1ofg0 with g1ofg0_uint // index-inducing
//
(* ****** ****** *)
//
fun{
k1,k2:tk
} g1int2uint // i2u
  {i:nat} (x: g1int (k1, i)):<> g1uint (k2, i)
//
fun g1int2uint_int_uint{i:nat} (x: int i):<> uint (i) = "mac#%"
fun g1int2uint_int_ulint{i:nat} (x: int i):<> ulint (i) = "mac#%"
fun g1int2uint_int_ullint{i:nat} (x: int i):<> ullint (i) = "mac#%"
fun g1int2uint_int_size{i:nat} (x: int i):<> size_t (i) = "mac#%"
//
fun g1int2uint_ssize_size{i:nat} (x: ssize_t(i)):<> size_t(i) = "mac#%"
//
(* ****** ****** *)

typedef
g1uint2int_type
  (k1:tk, k2:tk) = 
  {u:int} (g1uint (k1, u)) -<fun0> [u>=0] g1int (k2, u)
//
fun{
k1,k2:tk
} g1uint2int : g1uint2int_type (k1, k2)
//
fun g1uint2int_uint_int : g1uint2int_type (uintknd, intknd) = "mac#%"
fun g1uint2int_uint_lint : g1uint2int_type (uintknd, lintknd) = "mac#%"
fun g1uint2int_uint_llint : g1uint2int_type (uintknd, llintknd) = "mac#%"
fun g1uint2int_uint_ssize : g1uint2int_type (uintknd, ssizeknd) = "mac#%"
//
fun g1uint2int_size_int : g1uint2int_type (sizeknd, intknd) = "mac#%"
fun g1uint2int_size_lint : g1uint2int_type (sizeknd, lintknd) = "mac#%"
fun g1uint2int_size_llint : g1uint2int_type (sizeknd, llintknd) = "mac#%"
fun g1uint2int_size_ssize : g1uint2int_type (sizeknd, ssizeknd) = "mac#%"
//
(* ****** ****** *)
//
typedef
g1uint2uint_type
  (k1:tk, k2:tk) =
  {u:int} (g1uint (k1, u)) -<fun0> g1uint (k2, u)
//
fun{
k1,k2:tk
} g1uint2uint : g1uint2uint_type (k1, k2)
//
fun g1uint2uint_uint_uint : g1uint2uint_type (uintknd, uintknd) = "mac#%"
fun g1uint2uint_uint_ulint : g1uint2uint_type (uintknd, ulintknd) = "mac#%"
fun g1uint2uint_uint_ullint : g1uint2uint_type (uintknd, ullintknd) = "mac#%"
fun g1uint2uint_uint_size : g1uint2uint_type (uintknd, sizeknd) = "mac#%"
//
fun g1uint2uint_ulint_uint : g1uint2uint_type (uintknd, uintknd) = "mac#%"
fun g1uint2uint_ulint_ulint : g1uint2uint_type (uintknd, ulintknd) = "mac#%"
fun g1uint2uint_ulint_ullint : g1uint2uint_type (uintknd, ullintknd) = "mac#%"
fun g1uint2uint_ulint_size : g1uint2uint_type (uintknd, sizeknd) = "mac#%"
//
fun g1uint2uint_size_uint : g1uint2uint_type (sizeknd, uintknd) = "mac#%"
fun g1uint2uint_size_ulint : g1uint2uint_type (sizeknd, ulintknd) = "mac#%"
fun g1uint2uint_size_ullint : g1uint2uint_type (sizeknd, ullintknd) = "mac#%"
fun g1uint2uint_size_size : g1uint2uint_type (sizeknd, sizeknd) = "mac#%"
//
(* ****** ****** *)

fun{tk:tk}
g1string2uint (str: NSH(string)):<> g1uint (tk)

(* ****** ****** *)

prfun
g1uint_get_index
  {tk:tk}{i1:int}
  (x: g1uint (tk, i1)): [i2:int] EQINT (i1, i2)
// end of [g1uint_get_index]

(* ****** ****** *)
//
typedef
g1uint_succ_type
  (tk:tk) =
  {i:int}
  (g1uint (tk, i)) -<fun0> g1uint (tk, i+1)
typedef
g1uint_pred_type
  (tk:tk) =
  {i:int | i > 0}
  (g1uint (tk, i)) -<fun0> g1uint (tk, i-1)
//
fun{tk:tk}
g1uint_succ : g1uint_succ_type(tk)
overload succ with g1uint_succ of 10
fun{tk:tk}
g1uint_pred : g1uint_pred_type(tk)
overload pred with g1uint_pred of 10
//
(* ****** ****** *)

typedef
g1uint_half_type (tk:tk) =
  {i:int} (g1uint (tk, i)) -<fun0> g1uint (tk, i/2)
fun{tk:tk}
g1uint_half : g1uint_half_type(tk)
overload half with g1uint_half of 10

(*
typedef
g1uint_double_type (tk:tk) =
  {i:int} (g1uint (tk, i)) -<fun0> g1uint (tk, 2*i)
fun{tk:tk}
g1uint_double : g1uint_double_type(tk)
overload double with g1uint_double of 10
*)

(* ****** ****** *)

typedef
g1uint_add_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk, i+j)
fun
{tk:tk}
g1uint_add : g1uint_add_type(tk)
overload + with g1uint_add of 20

typedef
g1uint_sub_type
  (tk:tk) =
  {i,j:int | i >= j}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk, i-j)
fun
{tk:tk}
g1uint_sub : g1uint_sub_type(tk)
overload - with g1uint_sub of 20

(* ****** ****** *)

typedef
g1uint_mul_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk, i*j)
fun
{tk:tk}
g1uint_mul : g1uint_mul_type(tk)
overload * with g1uint_mul of 20

fun
{tk:tk}
g1uint_mul2 {i,j:int}
(
  x: g1uint (tk, i), y: g1uint (tk, j)
) :<> [ij:int] (MUL (i, j, ij) | g1uint (tk, ij))

(* ****** ****** *)

typedef
g1uint_div_type
  (tk:tk) =
  {i,j:int | j > 0}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk)
// end of [g1uint_div_type]

fun
{tk:tk}
g1uint_div : g1uint_div_type(tk)
overload / with g1uint_div of 20

fun
{tk:tk}
g1uint_div2 {i,j:int | j > 0}
(
  x: g1uint (tk, i), y: g1uint (tk, j)
) :<> [q,r:int | 0 <= r; r < j] (DIVMOD (i, j, q, r) | g1uint (tk, q))

(* ****** ****** *)

typedef
g1uint_mod_type
  (tk:tk) =
  {i,j:int | j > 0}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> [r:nat | r < j] g1uint (tk, r)
// end of [g1uint_mod_type]

fun
{tk:tk}
g1uint_mod : g1uint_mod_type(tk)
overload mod with g1uint_mod of 20

fun
{tk:tk}
g1uint_mod2
  {i,j:int | j > 0}
(
  x: g1uint (tk, i), y: g1uint (tk, j)
) :<>
[
  q,r:int | 0 <= r; r < j
] (
  DIVMOD (i, j, q, r) | g1uint (tk, r)
) // end of [g1uint_mod2]

(* ****** ****** *)

typedef
g1uint_isgtz_type (tk:tk) =
  {i:int} (g1uint (tk, i)) -<fun0> bool (i > 0)
fun{tk:tk}
g1uint_isgtz : g1uint_isgtz_type(tk)
overload isgtz with g1uint_isgtz of 10

(* ****** ****** *)

typedef
g1uint_iseqz_type (tk:tk) =
  {i:int} (g1uint (tk, i)) -<fun0> bool (i > 0)
typedef
g1uint_isneqz_type (tk:tk) =
  {i:int} (g1uint (tk, i)) -<fun0> bool (i >= 0)
fun{tk:tk}
g1uint_iseqz : g1uint_iseqz_type(tk)
overload iseqz with g1uint_iseqz of 10
fun{tk:tk}
g1uint_isneqz : g1uint_isneqz_type(tk)
overload isneqz with g1uint_isneqz of 10

(* ****** ****** *)

typedef
g1uint_lt_type (tk:tk) =
  {i,j:int} (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i < j)
fun{tk:tk}
g1uint_lt : g1uint_lt_type(tk)
overload < with g1uint_lt of 20
typedef
g1uint_lte_type (tk:tk) =
  {i,j:int} (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i <= j)
fun{tk:tk}
g1uint_lte : g1uint_lte_type(tk)
overload <= with g1uint_lte of 20

(* ****** ****** *)

typedef
g1uint_gt_type (tk:tk) =
  {i,j:int} (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i > j)
fun
{tk:tk}
g1uint_gt : g1uint_gt_type(tk)
overload > with g1uint_gt of 20
typedef
g1uint_gte_type (tk:tk) =
  {i,j:int} (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i >= j)
fun
{tk:tk}
g1uint_gte : g1uint_gte_type(tk)
overload >= with g1uint_gte of 20

(* ****** ****** *)
//
typedef
g1uint_eq_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i == j)
typedef
g1uint_neq_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i != j)
//
fun
{tk:tk}
g1uint_eq : g1uint_eq_type(tk)
overload = with g1uint_eq of 20
fun
{tk:tk}
g1uint_neq : g1uint_neq_type(tk)
overload != with g1uint_neq of 20
overload <> with g1uint_neq of 20
//
(* ****** ****** *)

typedef
g1uint_compare_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> int (sgn(i-j))
fun{tk:tk}
g1uint_compare : g1uint_compare_type(tk)
overload compare with g1uint_compare of 20

(* ****** ****** *)

typedef
g1uint_max_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk, max(i, j))
fun
{tk:tk}
g1uint_max : g1uint_max_type(tk)
overload max with g1uint_max of 20

typedef
g1uint_min_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk, min(i, j))
fun
{tk:tk}
g1uint_min : g1uint_min_type(tk)
overload min with g1uint_min of 20

(* ****** ****** *)
//
fun{tk:tk}
lt_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i < j)
overload < with lt_g1uint_int of 21
fun{tk:tk}
lte_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i <= j)
overload <= with lte_g1uint_int of 21
//
fun{tk:tk}
gt_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i > j)
overload > with gt_g1uint_int of 21
fun{tk:tk}
gte_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i >= j)
overload >= with gte_g1uint_int of 21
//
fun{tk:tk}
eq_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i == j)
overload = with eq_g1uint_int of 21
fun{tk:tk}
neq_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i != j)
overload != with neq_g1uint_int of 21
//
(* ****** ****** *)
//
fun g0int_neg_int (x: int):<> int = "mac#%"
fun g0int_abs_int (x: int):<> int = "mac#%"
fun g0int_succ_int (x: int):<> int = "mac#%"
fun g0int_pred_int (x: int):<> int = "mac#%"
fun g0int_half_int (x: int):<> int = "mac#%"
fun g0int_asl_int (x: int, n: intGte(0)):<> int = "mac#%"
fun g0int_asr_int (x: int, n: intGte(0)):<> int = "mac#%"
fun g0int_add_int (x: int, y: int):<> int = "mac#%"
fun g0int_sub_int (x: int, y: int):<> int = "mac#%"
fun g0int_mul_int (x: int, y: int):<> int = "mac#%"
fun g0int_div_int (x: int, y: int):<> int = "mac#%"
fun g0int_mod_int (x: int, y: int):<> int = "mac#%"
fun g0int_isltz_int (x: int):<> bool = "mac#%"
fun g0int_isltez_int (x: int):<> bool = "mac#%"
fun g0int_isgtz_int (x: int):<> bool = "mac#%"
fun g0int_isgtez_int (x: int):<> bool = "mac#%"
fun g0int_iseqz_int (x: int):<> bool = "mac#%"
fun g0int_isneqz_int (x: int):<> bool = "mac#%"
fun g0int_lt_int (x: int, y: int):<> bool = "mac#%"
fun g0int_lte_int (x: int, y: int):<> bool = "mac#%"
fun g0int_gt_int (x: int, y: int):<> bool = "mac#%"
fun g0int_gte_int (x: int, y: int):<> bool = "mac#%"
fun g0int_eq_int (x: int, y: int):<> bool = "mac#%"
fun g0int_neq_int (x: int, y: int):<> bool = "mac#%"
fun g0int_compare_int (x: int, y: int):<> int = "mac#%"
fun g0int_max_int (x: int, y: int):<> int = "mac#%"
fun g0int_min_int (x: int, y: int):<> int = "mac#%"
//
fun g0int_neg_lint (x: lint):<> lint = "mac#%"
fun g0int_abs_lint (x: lint):<> lint = "mac#%"
fun g0int_succ_lint (x: lint):<> lint = "mac#%"
fun g0int_pred_lint (x: lint):<> lint = "mac#%"
fun g0int_half_lint (x: lint):<> lint = "mac#%"
fun g0int_asl_lint (x: lint, n: intGte(0)):<> lint = "mac#%"
fun g0int_asr_lint (x: lint, n: intGte(0)):<> lint = "mac#%"
fun g0int_add_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_sub_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_mul_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_div_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_mod_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_isltz_lint (x: lint):<> bool = "mac#%"
fun g0int_isltez_lint (x: lint):<> bool = "mac#%"
fun g0int_isgtz_lint (x: lint):<> bool = "mac#%"
fun g0int_isgtez_lint (x: lint):<> bool = "mac#%"
fun g0int_iseqz_lint (x: lint):<> bool = "mac#%"
fun g0int_isneqz_lint (x: lint):<> bool = "mac#%"
fun g0int_lt_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_lte_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_gt_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_gte_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_eq_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_neq_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_compare_lint (x: lint, y: lint):<> int = "mac#%"
fun g0int_max_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_min_lint (x: lint, y: lint):<> lint = "mac#%"
//
fun g0int_neg_llint (x: llint):<> llint = "mac#%"
fun g0int_abs_llint (x: llint):<> llint = "mac#%"
fun g0int_succ_llint (x: llint):<> llint = "mac#%"
fun g0int_pred_llint (x: llint):<> llint = "mac#%"
fun g0int_half_llint (x: llint):<> llint = "mac#%"
fun g0int_asl_llint (x: llint, n: intGte(0)):<> llint = "mac#%"
fun g0int_asr_llint (x: llint, n: intGte(0)):<> llint = "mac#%"
fun g0int_add_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_sub_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_mul_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_div_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_mod_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_isltz_llint (x: llint):<> bool = "mac#%"
fun g0int_isltez_llint (x: llint):<> bool = "mac#%"
fun g0int_isgtz_llint (x: llint):<> bool = "mac#%"
fun g0int_isgtez_llint (x: llint):<> bool = "mac#%"
fun g0int_iseqz_llint (x: llint):<> bool = "mac#%"
fun g0int_isneqz_llint (x: llint):<> bool = "mac#%"
fun g0int_lt_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_lte_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_gt_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_gte_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_eq_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_neq_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_compare_llint (x: llint, y: llint):<> int = "mac#%"
fun g0int_max_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_min_llint (x: llint, y: llint):<> llint = "mac#%"
//
fun g0int_neg_ssize (x: ssize_t):<> ssize_t = "mac#%"
fun g0int_abs_ssize (x: ssize_t):<> ssize_t = "mac#%"
fun g0int_succ_ssize (x: ssize_t):<> ssize_t = "mac#%"
fun g0int_pred_ssize (x: ssize_t):<> ssize_t = "mac#%"
fun g0int_half_ssize (x: ssize_t):<> ssize_t = "mac#%"
fun g0int_asl_ssize (x: ssize_t, n: intGte(0)):<> ssize_t = "mac#%"
fun g0int_asr_ssize (x: ssize_t, n: intGte(0)):<> ssize_t = "mac#%"
fun g0int_add_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_sub_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_mul_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_div_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_mod_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_isltz_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_isltez_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_isgtz_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_isgtez_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_iseqz_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_isneqz_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_lt_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_lte_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_gt_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_gte_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_eq_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_neq_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_compare_ssize (x: ssize_t, y: ssize_t):<> int = "mac#%"
fun g0int_max_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_min_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
//
(* ****** ****** *)
//
fun fprint_int
  : fprint_type (int) = "mac#%"
overload fprint with fprint_int
fun print_int (x: int): void = "mac#%"
fun prerr_int (x: int): void = "mac#%"
overload print with print_int
overload prerr with prerr_int
//
fun fprint_lint
  : fprint_type (lint) = "mac#%"
overload fprint with fprint_lint
fun print_lint (x: lint): void = "mac#%"
fun prerr_lint (x: lint): void = "mac#%"
overload print with print_lint
overload prerr with prerr_lint
//
fun fprint_llint
  : fprint_type (llint) = "mac#%"
overload fprint with fprint_llint
fun print_llint (x: llint): void = "mac#%"
fun prerr_llint (x: llint): void = "mac#%"
overload print with print_llint
overload prerr with prerr_llint
//
fun fprint_ssize
  : fprint_type (ssize_t) = "mac#%"
overload fprint with fprint_ssize
fun print_ssize (x: ssize_t): void = "mac#%"
fun prerr_ssize (x: ssize_t): void = "mac#%"
overload print with print_ssize
overload prerr with prerr_ssize
//
(* ****** ****** *)
//
fun g0uint_succ_uint (x: uint):<> uint = "mac#%"
fun g0uint_pred_uint (x: uint):<> uint = "mac#%"
fun g0uint_half_uint (x: uint):<> uint = "mac#%"
fun g0uint_add_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_sub_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_mul_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_div_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_mod_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_lsl_uint (x: uint, n: intGte(0)):<> uint = "mac#%"
fun g0uint_lsr_uint (x: uint, n: intGte(0)):<> uint = "mac#%"
fun g0uint_lnot_uint (x: uint):<> uint = "mac#%"
fun g0uint_lor_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_lxor_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_land_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_isgtz_uint (x: uint):<> bool = "mac#%"
fun g0uint_iseqz_uint (x: uint):<> bool = "mac#%"
fun g0uint_isneqz_uint (x: uint):<> bool = "mac#%"
fun g0uint_lt_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_lte_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_gt_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_gte_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_eq_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_neq_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_compare_uint (x: uint, y: uint):<> int = "mac#%"
fun g0uint_max_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_min_uint (x: uint, y: uint):<> uint = "mac#%"
//
fun g0uint_succ_ulint (x: ulint):<> ulint = "mac#%"
fun g0uint_pred_ulint (x: ulint):<> ulint = "mac#%"
fun g0uint_half_ulint (x: ulint):<> ulint = "mac#%"
fun g0uint_add_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_sub_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_mul_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_div_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_mod_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_lsl_ulint (x: ulint, n: intGte(0)):<> ulint = "mac#%"
fun g0uint_lsr_ulint (x: ulint, n: intGte(0)):<> ulint = "mac#%"
fun g0uint_lnot_ulint (x: ulint):<> ulint = "mac#%"
fun g0uint_lor_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_lxor_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_land_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_isgtz_ulint (x: ulint):<> bool = "mac#%"
fun g0uint_iseqz_ulint (x: ulint):<> bool = "mac#%"
fun g0uint_isneqz_ulint (x: ulint):<> bool = "mac#%"
fun g0uint_lt_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_lte_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_gt_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_gte_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_eq_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_neq_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_compare_ulint (x: ulint, y: ulint):<> int = "mac#%"
fun g0uint_max_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_min_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
//
fun g0uint_succ_ullint (x: ullint):<> ullint = "mac#%"
fun g0uint_pred_ullint (x: ullint):<> ullint = "mac#%"
fun g0uint_half_ullint (x: ullint):<> ullint = "mac#%"
fun g0uint_add_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_sub_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_mul_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_div_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_mod_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_lsl_ullint (x: ullint, n: intGte(0)):<> ullint = "mac#%"
fun g0uint_lsr_ullint (x: ullint, n: intGte(0)):<> ullint = "mac#%"
fun g0uint_lnot_ullint (x: ullint):<> ullint = "mac#%"
fun g0uint_lor_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_lxor_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_land_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_isgtz_ullint (x: ullint):<> bool = "mac#%"
fun g0uint_iseqz_ullint (x: ullint):<> bool = "mac#%"
fun g0uint_isneqz_ullint (x: ullint):<> bool = "mac#%"
fun g0uint_lt_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_lte_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_gt_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_gte_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_eq_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_neq_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_compare_ullint (x: ullint, y: ullint):<> int = "mac#%"
fun g0uint_max_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_min_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
//
fun g0uint_succ_size (x: size_t):<> size_t = "mac#%"
fun g0uint_pred_size (x: size_t):<> size_t = "mac#%"
fun g0uint_half_size (x: size_t):<> size_t = "mac#%"
fun g0uint_add_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_sub_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_mul_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_div_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_mod_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_lsl_size (x: size_t, n: intGte(0)):<> size_t = "mac#%"
fun g0uint_lsr_size (x: size_t, n: intGte(0)):<> size_t = "mac#%"
fun g0uint_lnot_size (x: size_t):<> size_t = "mac#%"
fun g0uint_lor_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_lxor_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_land_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_isgtz_size (x: size_t):<> bool = "mac#%"
fun g0uint_iseqz_size (x: size_t):<> bool = "mac#%"
fun g0uint_isneqz_size (x: size_t):<> bool = "mac#%"
fun g0uint_lt_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_lte_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_gt_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_gte_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_eq_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_neq_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_compare_size (x: size_t, y: size_t):<> int = "mac#%"
fun g0uint_max_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_min_size (x: size_t, y: size_t):<> size_t = "mac#%"
//
(* ****** ****** *)
//
fun fprint_uint
  : fprint_type (uint) = "mac#%"
overload fprint with fprint_uint
fun print_uint (x: uint): void = "mac#%"
fun prerr_uint (x: uint): void = "mac#%"
overload print with print_uint
overload prerr with prerr_uint
//
fun fprint_ulint
  : fprint_type (ulint) = "mac#%"
overload fprint with fprint_ulint
fun print_ulint (x: ulint): void = "mac#%"
fun prerr_ulint (x: ulint): void = "mac#%"
overload print with print_ulint
overload prerr with prerr_ulint
//
fun fprint_ullint
  : fprint_type (ullint) = "mac#%"
overload fprint with fprint_ullint
fun print_ullint (x: ullint): void = "mac#%"
fun prerr_ullint (x: ullint): void = "mac#%"
overload print with print_ullint
overload prerr with prerr_ullint
//
fun fprint_size
  : fprint_type (size_t) = "mac#%"
overload fprint with fprint_size
fun print_size (x: size_t): void = "mac#%"
fun prerr_size (x: size_t): void = "mac#%"
overload print with print_size
overload prerr with prerr_size
//
(* ****** ****** *)
//
fun g1int_neg_int : g1int_neg_type (intknd) = "mac#%"
fun g1int_abs_int : g1int_abs_type (intknd) = "mac#%"
fun g1int_succ_int : g1int_succ_type (intknd) = "mac#%"
fun g1int_pred_int : g1int_pred_type (intknd) = "mac#%"
fun g1int_half_int : g1int_half_type (intknd) = "mac#%"
fun g1int_add_int : g1int_add_type (intknd) = "mac#%"
fun g1int_sub_int : g1int_sub_type (intknd) = "mac#%"
fun g1int_mul_int : g1int_mul_type (intknd) = "mac#%"
fun g1int_div_int : g1int_div_type (intknd) = "mac#%"
fun g1int_nmod_int : g1int_nmod_type (intknd) = "mac#%"
fun g1int_isltz_int : g1int_isltz_type (intknd) = "mac#%"
fun g1int_isltez_int : g1int_isltez_type (intknd) = "mac#%"
fun g1int_isgtz_int : g1int_isgtz_type (intknd) = "mac#%"
fun g1int_isgtez_int : g1int_isgtez_type (intknd) = "mac#%"
fun g1int_iseqz_int : g1int_iseqz_type (intknd) = "mac#%"
fun g1int_isneqz_int : g1int_isneqz_type (intknd) = "mac#%"
fun g1int_lt_int : g1int_lt_type (intknd) = "mac#%"
fun g1int_lte_int : g1int_lte_type (intknd) = "mac#%"
fun g1int_gt_int : g1int_gt_type (intknd) = "mac#%"
fun g1int_gte_int : g1int_gte_type (intknd) = "mac#%"
fun g1int_eq_int : g1int_eq_type (intknd) = "mac#%"
fun g1int_neq_int : g1int_neq_type (intknd) = "mac#%"
fun g1int_compare_int : g1int_compare_type (intknd) = "mac#%"
fun g1int_max_int : g1int_max_type (intknd) = "mac#%"
fun g1int_min_int : g1int_min_type (intknd) = "mac#%"
//
fun g1int_neg_lint : g1int_neg_type (lintknd) = "mac#%"
fun g1int_abs_lint : g1int_abs_type (lintknd) = "mac#%"
fun g1int_succ_lint : g1int_succ_type (lintknd) = "mac#%"
fun g1int_pred_lint : g1int_pred_type (lintknd) = "mac#%"
fun g1int_half_lint : g1int_half_type (lintknd) = "mac#%"
fun g1int_add_lint : g1int_add_type (lintknd) = "mac#%"
fun g1int_sub_lint : g1int_sub_type (lintknd) = "mac#%"
fun g1int_mul_lint : g1int_mul_type (lintknd) = "mac#%"
fun g1int_div_lint : g1int_div_type (lintknd) = "mac#%"
fun g1int_nmod_lint : g1int_nmod_type (lintknd) = "mac#%"
fun g1int_isltz_lint : g1int_isltz_type (lintknd) = "mac#%"
fun g1int_isltez_lint : g1int_isltez_type (lintknd) = "mac#%"
fun g1int_isgtz_lint : g1int_isgtz_type (lintknd) = "mac#%"
fun g1int_isgtez_lint : g1int_isgtez_type (lintknd) = "mac#%"
fun g1int_iseqz_lint : g1int_iseqz_type (lintknd) = "mac#%"
fun g1int_isneqz_lint : g1int_isneqz_type (lintknd) = "mac#%"
fun g1int_lt_lint : g1int_lt_type (lintknd) = "mac#%"
fun g1int_lte_lint : g1int_lte_type (lintknd) = "mac#%"
fun g1int_gt_lint : g1int_gt_type (lintknd) = "mac#%"
fun g1int_gte_lint : g1int_gte_type (lintknd) = "mac#%"
fun g1int_eq_lint : g1int_eq_type (lintknd) = "mac#%"
fun g1int_neq_lint : g1int_neq_type (lintknd) = "mac#%"
fun g1int_compare_lint : g1int_compare_type (lintknd) = "mac#%"
fun g1int_max_lint : g1int_max_type (lintknd) = "mac#%"
fun g1int_min_lint : g1int_min_type (lintknd) = "mac#%"
//
fun g1int_neg_llint : g1int_neg_type (llintknd) = "mac#%"
fun g1int_abs_llint : g1int_abs_type (llintknd) = "mac#%"
fun g1int_succ_llint : g1int_succ_type (llintknd) = "mac#%"
fun g1int_pred_llint : g1int_pred_type (llintknd) = "mac#%"
fun g1int_half_llint : g1int_half_type (llintknd) = "mac#%"
fun g1int_add_llint : g1int_add_type (llintknd) = "mac#%"
fun g1int_sub_llint : g1int_sub_type (llintknd) = "mac#%"
fun g1int_mul_llint : g1int_mul_type (llintknd) = "mac#%"
fun g1int_div_llint : g1int_div_type (llintknd) = "mac#%"
fun g1int_nmod_llint : g1int_nmod_type (llintknd) = "mac#%"
fun g1int_isltz_llint : g1int_isltz_type (llintknd) = "mac#%"
fun g1int_isltez_llint : g1int_isltez_type (llintknd) = "mac#%"
fun g1int_isgtz_llint : g1int_isgtz_type (llintknd) = "mac#%"
fun g1int_isgtez_llint : g1int_isgtez_type (llintknd) = "mac#%"
fun g1int_iseqz_llint : g1int_iseqz_type (llintknd) = "mac#%"
fun g1int_isneqz_llint : g1int_isneqz_type (llintknd) = "mac#%"
fun g1int_lt_llint : g1int_lt_type (llintknd) = "mac#%"
fun g1int_lte_llint : g1int_lte_type (llintknd) = "mac#%"
fun g1int_gt_llint : g1int_gt_type (llintknd) = "mac#%"
fun g1int_gte_llint : g1int_gte_type (llintknd) = "mac#%"
fun g1int_eq_llint : g1int_eq_type (llintknd) = "mac#%"
fun g1int_neq_llint : g1int_neq_type (llintknd) = "mac#%"
fun g1int_compare_llint : g1int_compare_type (llintknd) = "mac#%"
fun g1int_max_llint : g1int_max_type (llintknd) = "mac#%"
fun g1int_min_llint : g1int_min_type (llintknd) = "mac#%"
//
fun g1int_neg_ssize : g1int_neg_type (ssizeknd) = "mac#%"
fun g1int_abs_ssize : g1int_abs_type (ssizeknd) = "mac#%"
fun g1int_succ_ssize : g1int_succ_type (ssizeknd) = "mac#%"
fun g1int_pred_ssize : g1int_pred_type (ssizeknd) = "mac#%"
fun g1int_half_ssize : g1int_half_type (ssizeknd) = "mac#%"
fun g1int_add_ssize : g1int_add_type (ssizeknd) = "mac#%"
fun g1int_sub_ssize : g1int_sub_type (ssizeknd) = "mac#%"
fun g1int_mul_ssize : g1int_mul_type (ssizeknd) = "mac#%"
fun g1int_div_ssize : g1int_div_type (ssizeknd) = "mac#%"
fun g1int_nmod_ssize : g1int_nmod_type (ssizeknd) = "mac#%"
fun g1int_isltz_ssize : g1int_isltz_type (ssizeknd) = "mac#%"
fun g1int_isltez_ssize : g1int_isltez_type (ssizeknd) = "mac#%"
fun g1int_isgtz_ssize : g1int_isgtz_type (ssizeknd) = "mac#%"
fun g1int_isgtez_ssize : g1int_isgtez_type (ssizeknd) = "mac#%"
fun g1int_iseqz_ssize : g1int_iseqz_type (ssizeknd) = "mac#%"
fun g1int_isneqz_ssize : g1int_isneqz_type (ssizeknd) = "mac#%"
fun g1int_lt_ssize : g1int_lt_type (ssizeknd) = "mac#%"
fun g1int_lte_ssize : g1int_lte_type (ssizeknd) = "mac#%"
fun g1int_gt_ssize : g1int_gt_type (ssizeknd) = "mac#%"
fun g1int_gte_ssize : g1int_gte_type (ssizeknd) = "mac#%"
fun g1int_eq_ssize : g1int_eq_type (ssizeknd) = "mac#%"
fun g1int_neq_ssize : g1int_neq_type (ssizeknd) = "mac#%"
fun g1int_compare_ssize : g1int_compare_type (ssizeknd) = "mac#%"
fun g1int_max_ssize : g1int_max_type (ssizeknd) = "mac#%"
fun g1int_min_ssize : g1int_min_type (ssizeknd) = "mac#%"
//
(* ****** ****** *)
//
fun g1uint_succ_uint : g1uint_succ_type (uintknd) = "mac#%"
fun g1uint_pred_uint : g1uint_pred_type (uintknd) = "mac#%"
fun g1uint_half_uint : g1uint_half_type (uintknd) = "mac#%"
fun g1uint_add_uint : g1uint_add_type (uintknd) = "mac#%"
fun g1uint_sub_uint : g1uint_sub_type (uintknd) = "mac#%"
fun g1uint_mul_uint : g1uint_mul_type (uintknd) = "mac#%"
fun g1uint_div_uint : g1uint_div_type (uintknd) = "mac#%"
fun g1uint_mod_uint : g1uint_mod_type (uintknd) = "mac#%"
fun g1uint_isgtz_uint : g1uint_isgtz_type (uintknd) = "mac#%"
fun g1uint_iseqz_uint : g1uint_iseqz_type (uintknd) = "mac#%"
fun g1uint_isneqz_uint : g1uint_isneqz_type (uintknd) = "mac#%"
fun g1uint_lt_uint : g1uint_lt_type (uintknd) = "mac#%"
fun g1uint_lte_uint : g1uint_lte_type (uintknd) = "mac#%"
fun g1uint_gt_uint : g1uint_gt_type (uintknd) = "mac#%"
fun g1uint_gte_uint : g1uint_gte_type (uintknd) = "mac#%"
fun g1uint_eq_uint : g1uint_eq_type (uintknd) = "mac#%"
fun g1uint_neq_uint : g1uint_neq_type (uintknd) = "mac#%"
fun g1uint_compare_uint : g1uint_compare_type (uintknd) = "mac#%"
fun g1uint_max_uint : g1uint_max_type (uintknd) = "mac#%"
fun g1uint_min_uint : g1uint_min_type (uintknd) = "mac#%"
//
fun g1uint_succ_ulint : g1uint_succ_type (ulintknd) = "mac#%"
fun g1uint_pred_ulint : g1uint_pred_type (ulintknd) = "mac#%"
fun g1uint_half_ulint : g1uint_half_type (ulintknd) = "mac#%"
fun g1uint_add_ulint : g1uint_add_type (ulintknd) = "mac#%"
fun g1uint_sub_ulint : g1uint_sub_type (ulintknd) = "mac#%"
fun g1uint_mul_ulint : g1uint_mul_type (ulintknd) = "mac#%"
fun g1uint_div_ulint : g1uint_div_type (ulintknd) = "mac#%"
fun g1uint_mod_ulint : g1uint_mod_type (ulintknd) = "mac#%"
fun g1uint_isgtz_ulint : g1uint_isgtz_type (ulintknd) = "mac#%"
fun g1uint_iseqz_ulint : g1uint_iseqz_type (ulintknd) = "mac#%"
fun g1uint_isneqz_ulint : g1uint_isneqz_type (ulintknd) = "mac#%"
fun g1uint_lt_ulint : g1uint_lt_type (ulintknd) = "mac#%"
fun g1uint_lte_ulint : g1uint_lte_type (ulintknd) = "mac#%"
fun g1uint_gt_ulint : g1uint_gt_type (ulintknd) = "mac#%"
fun g1uint_gte_ulint : g1uint_gte_type (ulintknd) = "mac#%"
fun g1uint_eq_ulint : g1uint_eq_type (ulintknd) = "mac#%"
fun g1uint_neq_ulint : g1uint_neq_type (ulintknd) = "mac#%"
fun g1uint_compare_ulint : g1uint_compare_type (ulintknd) = "mac#%"
fun g1uint_max_ulint : g1uint_max_type (ulintknd) = "mac#%"
fun g1uint_min_ulint : g1uint_min_type (ulintknd) = "mac#%"
//
fun g1uint_succ_ullint : g1uint_succ_type (ullintknd) = "mac#%"
fun g1uint_pred_ullint : g1uint_pred_type (ullintknd) = "mac#%"
fun g1uint_half_ullint : g1uint_half_type (ullintknd) = "mac#%"
fun g1uint_add_ullint : g1uint_add_type (ullintknd) = "mac#%"
fun g1uint_sub_ullint : g1uint_sub_type (ullintknd) = "mac#%"
fun g1uint_mul_ullint : g1uint_mul_type (ullintknd) = "mac#%"
fun g1uint_div_ullint : g1uint_div_type (ullintknd) = "mac#%"
fun g1uint_mod_ullint : g1uint_mod_type (ullintknd) = "mac#%"
fun g1uint_isgtz_ullint : g1uint_isgtz_type (ullintknd) = "mac#%"
fun g1uint_iseqz_ullint : g1uint_iseqz_type (ullintknd) = "mac#%"
fun g1uint_isneqz_ullint : g1uint_isneqz_type (ullintknd) = "mac#%"
fun g1uint_lt_ullint : g1uint_lt_type (ullintknd) = "mac#%"
fun g1uint_lte_ullint : g1uint_lte_type (ullintknd) = "mac#%"
fun g1uint_gt_ullint : g1uint_gt_type (ullintknd) = "mac#%"
fun g1uint_gte_ullint : g1uint_gte_type (ullintknd) = "mac#%"
fun g1uint_eq_ullint : g1uint_eq_type (ullintknd) = "mac#%"
fun g1uint_neq_ullint : g1uint_neq_type (ullintknd) = "mac#%"
fun g1uint_compare_ullint : g1uint_compare_type (ullintknd) = "mac#%"
fun g1uint_max_ullint : g1uint_max_type (ullintknd) = "mac#%"
fun g1uint_min_ullint : g1uint_min_type (ullintknd) = "mac#%"
//
fun g1uint_succ_size : g1uint_succ_type (sizeknd) = "mac#%"
fun g1uint_pred_size : g1uint_pred_type (sizeknd) = "mac#%"
fun g1uint_half_size : g1uint_half_type (sizeknd) = "mac#%"
fun g1uint_add_size : g1uint_add_type (sizeknd) = "mac#%"
fun g1uint_sub_size : g1uint_sub_type (sizeknd) = "mac#%"
fun g1uint_mul_size : g1uint_mul_type (sizeknd) = "mac#%"
fun g1uint_div_size : g1uint_div_type (sizeknd) = "mac#%"
fun g1uint_mod_size : g1uint_mod_type (sizeknd) = "mac#%"
fun g1uint_isgtz_size : g1uint_isgtz_type (sizeknd) = "mac#%"
fun g1uint_iseqz_size : g1uint_iseqz_type (sizeknd) = "mac#%"
fun g1uint_isneqz_size : g1uint_isneqz_type (sizeknd) = "mac#%"
fun g1uint_lt_size : g1uint_lt_type (sizeknd) = "mac#%"
fun g1uint_lte_size : g1uint_lte_type (sizeknd) = "mac#%"
fun g1uint_gt_size : g1uint_gt_type (sizeknd) = "mac#%"
fun g1uint_gte_size : g1uint_gte_type (sizeknd) = "mac#%"
fun g1uint_eq_size : g1uint_eq_type (sizeknd) = "mac#%"
fun g1uint_neq_size : g1uint_neq_type (sizeknd) = "mac#%"
fun g1uint_compare_size : g1uint_compare_type (sizeknd) = "mac#%"
fun g1uint_max_size : g1uint_max_type (sizeknd) = "mac#%"
fun g1uint_min_size : g1uint_min_type (sizeknd) = "mac#%"
//
(* ****** ****** *)
//
macdef g0i2i (x) = g0int2int (,(x))
macdef g1i2i (x) = g1int2int (,(x))
//
macdef g0i2u (x) = g0int2uint (,(x))
macdef g1i2u (x) = g1int2uint (,(x))
//
macdef g0u2i (x) = g0uint2int (,(x))
macdef g1u2i (x) = g1uint2int (,(x))
//
macdef g0u2u (x) = g0uint2uint (,(x))
macdef g1u2u (x) = g1uint2uint (,(x))
//
macdef i2u (x) = g1int2uint_int_uint (,(x))
macdef i2sz (x) = g1int2uint_int_size (,(x))
macdef i2ssz (x) = g1int2int_int_ssize (,(x))
//
(* ****** ****** *)
//
macdef u2i (x) = g1uint2int_uint_int (,(x))
macdef u2sz (x) = g1uint2uint_uint_size (,(x))
//
(* ****** ****** *)
//
(*
macdef sz2i (x) = g1uint2int_size_int (,(x))
macdef sz2u (x) = g1uint2uint_size_uint (,(x))
*)
//
symintr sz2i
overload sz2i with g0uint2int_size_int of 0
overload sz2i with g1uint2int_size_int of 10
//
symintr sz2u
overload sz2u with g0uint2uint_size_uint of 0
overload sz2u with g1uint2uint_size_uint of 10
//
(* ****** ****** *)

(* end of [integer.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/array.atxt
** Time of generation: Sat Oct 17 15:19:48 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef t0p = t@ype
sortdef vtp = viewtype
sortdef vt0p = viewt@ype

(* ****** ****** *)

(*
//
// HX: [array_v] can also be defined as follows:
//
dataview
array_v
(
  a:vt@ype+, addr, int
) = // HX: for arry view
  | {l:addr}
    array_v_nil (a, l, 0)
  | {l:addr}{n:int}
    array_v_cons (a, l, n+1) of (a @ l, array_v (a, l+sizeof a, n))
// end of [array_v]
*)

(* ****** ****** *)

dataview
arrayopt_v
(
  a:vt@ype+, addr, int, bool
) = // HX: for optional array view
  | {l:addr}{n:int}
    arrayopt_v_some (a, l, n, true) of array_v (a, l, n)
  | {l:addr}{n:int}
    arrayopt_v_none (a, l, n, false) of array_v (a?, l, n)
// end of [arrayopt_v]

(* ****** ****** *)

exception
ArraySubscriptExn of ()
(*
fun ArraySubscriptExn ():<> exn = "mac#%ArraySubscriptExn_make"
fun isArraySubscriptExn (x: !exn):<> bool = "mac#%isArraySubscriptExn"
macdef
ifArraySubscriptExn
  {tres}(exn, body) =
(
let val x = ,(exn) in
(
if isArraySubscriptExn(x)
  then
    let prval () = __vfree_exn (x) in ,(body) end
  else $raise (x)
) : tres // end of [if]
end (* end of [let] *)
) // end of [ifArraySubscriptExn]
*)

(* ****** ****** *)

praxi
lemma_array_param{a:vt0p}
  {l:addr}{n:int} (A: &(@[INV(a)][n])): [n >= 0] void
// end of [lemma_array_param]
praxi
lemma_array_v_param{a:vt0p}
  {l:addr}{n:int} (pf: !array_v (INV(a), l, n)): [n >= 0] void
// end of [lemma_array_v_param]

(* ****** ****** *)

praxi
array_v_nil :
  {a:vt0p}{l:addr} () -<prf> array_v (a, l, 0)
praxi
array_v_unnil :
  {a:vt0p}{l:addr} array_v (a, l, 0) -<prf> void

prfun
array_v_unnil_nil :
  {a1,a2:vt0p}{l:addr} array_v (a1, l, 0) -<prf> array_v (a2, l, 0)
// end of [array_v_unnil_nil]

(* ****** ****** *)

praxi
array_v_cons :
  {a:vt0p}{l:addr}{n:int}
  (a @ l, array_v (INV(a), l+sizeof(a), n)) -<prf> array_v (a, l, n+1)
praxi
array_v_uncons :
  {a:vt0p}{l:addr}{n:int | n > 0}
  array_v (INV(a), l, n) -<prf> (a @ l, array_v (a, l+sizeof(a), n-1))

(* ****** ****** *)

prfun
array_v_sing
  {a:vt0p}{l:addr} (pf: INV(a) @ l): array_v (a, l, 1)
prfun
array_v_unsing
  {a:vt0p}{l:addr} (pf: array_v (INV(a), l, 1)): a @ l

(* ****** ****** *)
//
fun{a:vt0p}
array_getref_at
  {n:int} (A: &RD(@[INV(a)][n]), i: sizeLt n):<> cPtr1(a)
//
(* ****** ****** *)

fun{
a:t0p}{tk:tk
} array_get_at_gint
  {n:int} (A: &RD(@[INV(a)][n]), i: g1intLt (tk, n)):<> a
overload [] with array_get_at_gint of 0

fun{
a:t0p}{tk:tk
} array_get_at_guint
  {n:int} (A: &RD(@[INV(a)][n]), i: g1uintLt (tk, n)):<> a
overload [] with array_get_at_guint of 0

symintr array_get_at
overload array_get_at with array_get_at_gint of 0
overload array_get_at with array_get_at_guint of 0

(* ****** ****** *)

fun{
a:t0p}{tk:tk
} array_set_at_gint
  {n:int} (A: &(@[INV(a)][n]), i: g1intLt (tk, n), x: a):<!wrt> void
overload [] with array_set_at_gint of 0

fun{
a:t0p}{tk:tk
} array_set_at_guint
  {n:int} (A: &(@[INV(a)][n]), i: g1uintLt (tk, n), x: a):<!wrt> void
overload [] with array_set_at_guint of 0

symintr array_set_at
overload array_set_at with array_set_at_gint of 0
overload array_set_at with array_set_at_guint of 0

(* ****** ****** *)

fun{
a:vt0p}{tk:tk
} array_exch_at_gint{n:int}
(
  A: &(@[INV(a)][n]), i: g1intLt (tk, n), x: &a >> _
) :<!wrt> void
fun{
a:vt0p}{tk:tk
} array_exch_at_guint{n:int}
(
  A: &(@[INV(a)][n]), i: g1uintLt (tk, n), x: &a >> _
) :<!wrt> void

symintr array_exch_at
overload array_exch_at with array_exch_at_gint of 0
overload array_exch_at with array_exch_at_guint of 0

(* ****** ****** *)

fun{a:vt0p}
array_subreverse
 {n:int}
 {i,j:int |
  0 <= i; i <= j; j <= n}
(
  A: &(@[INV(a)][n]), i: size_t (i), j: size_t (j)
) :<!wrt> void // end of [array_subreverse]

(* ****** ****** *)

fun{a:vt0p}
array_interchange{n:int}
(
  A: &(@[INV(a)][n]), i: sizeLt (n), j: sizeLt (n)
) :<!wrt> void // end of [array_interchange]

(* ****** ****** *)

fun{a:vt0p}
array_subcirculate{n:int}
(
  A: &(@[INV(a)][n]), i: sizeLt (n), j: sizeLt (n)
) :<!wrt> void // end of [array_subcirculate]

(* ****** ****** *)

fun{a:vt0p}
array_ptr_takeout
  {l:addr}{n:int}{i:nat | i < n}
(
  array_v (INV(a), l, n) | ptr l, size_t i
) : (
  a @ (l+i*sizeof(a))
, a @ (l+i*sizeof(a)) -<lin,prf> array_v (a, l, n)
| ptr (l+i*sizeof(a))
) // end of [array_ptr_takeout]

(* ****** ****** *)

fun{a:vt0p}
array_ptr_alloc
  {n:int}
(
  asz: size_t n
) :<!wrt> [l:agz]
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) // end of [array_ptr_alloc]

fun{}
array_ptr_free
  {a:vt0p}{l:addr}{n:int}
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) :<!wrt> void // end of [array_ptr_free]

(* ****** ****** *)
//
fun{}
fprint_array$sep (out: FILEref): void
//
fun{a:vt0p}
fprint_array_int{n:int}
(
  out: FILEref, A: &RD(@[INV(a)][n]), n: int(n)
) : void // end of [fprint_array_int]
fun{a:vt0p}
fprint_array_size{n:int}
(
  out: FILEref, A: &RD(@[INV(a)][n]), n: size_t(n)
) : void // end of [fprint_array_size]
//
symintr fprint_array
overload fprint_array with fprint_array_int
overload fprint_array with fprint_array_size
//
fun{a:vt0p}
fprint_array_sep{n:int}
(
  out: FILEref
, A: &RD(@[INV(a)][n]), n: size_t n, sep: NSH(string)
) : void // end of [fprint_array_sep]
//
(* ****** ****** *)

overload fprint with fprint_array
overload fprint with fprint_array_sep

(* ****** ****** *)

fun{a:vt0p}
array_copy{n:int}
(
  to: &(@[a?][n]) >> @[a][n]
, from: &RD(@[INV(a)][n]) >> @[a?!][n]
, n: size_t (n)
) :<!wrt> void // end of [array_copy]

(* ****** ****** *)

fun{a:t0p}
array_copy_from_list{n:int}
(
  A: &(@[a?][n]) >> @[a][n], xs: list (INV(a), n)
) :<!wrt> void // end of [array_copy_from_list]

fun{a:vt0p}
array_copy_from_list_vt{n:int}
(
  A: &(@[a?][n]) >> @[a][n], xs: list_vt (INV(a), n)
) :<!wrt> void // end of [array_copy_from_list_vt]

(* ****** ****** *)

fun{a:vt0p}
array_copy_to_list_vt{n:int}
(
  A: &RD(@[INV(a)][n]) >> @[a?!][n], n: size_t n
) :<!wrt> list_vt (a, n) // endfun

macdef array2list = array_copy_to_list_vt

(* ****** ****** *)

fun{a:vt0p}
array_tabulate$fopr (i: size_t): (a)
fun{a:vt0p}
array_ptr_tabulate
  {n:int} (asz: size_t n)
  : [l:addr] (array_v (a, l, n), mfree_gc_v (l) | ptr l)
// end of [arrayptr_tabulate]

(* ****** ****** *)
//
fun{
a:vt0p
} array_foreach{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n
) : sizeLte (n) // end of [array_foreach]
//
fun{
a:vt0p}{env:vt0p
} array_foreach_env{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n, env: &(env) >> _
) : sizeLte (n) // end of [array_foreach_env]
//
fun{
a:vt0p}{env:vt0p
} array_foreach$cont (x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} array_foreach$fwork (x: &a >> _, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{a:vt0p}
array_foreach_funenv
  {v:view}
  {vt:vtype}
  {n:int}
  {fe:eff}
(
  pfv: !v
| A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t n
, f: (!v | &a >> _, !vt) -<fun,fe> void
, env: !vt
) :<fe> void
// end of [array_foreach_funenv]
//
fun
array_foreach_funenv_tsz
  {a:vt0p}
  {v:view}
  {vt:vtype}
  {n:int}
  {fe:eff}
(
  pfv: !v
| A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t(n), tsz: sizeof_t(a)
, f: (!v | &a >> _, !vt) -<fun,fe> void
, env: !vt
) :<fe> void = "ext#%"
// end of [array_foreach_funenv_tsz]
//
(* ****** ****** *)
//
fun{a:vt0p}
array_foreach_fun
  {n:int}{fe:eff}
(
  &(@[INV(a)][n]) >> @[a][n]
, size_t (n), (&a >> _) -<fun,fe> void
) :<fe> void // end of [array_foreach_fun]
fun{a:vt0p}
array_foreach_clo
  {n:int}{fe:eff}
(
  A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t (n), f: &(&a >> _) -<clo,fe> void
) :<fe> void // end of [array_foreach_clo]
fun{a:vt0p}
array_foreach_cloptr
  {n:int}{fe:eff}
(
  A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t n, f: (&a >> _) -<cloptr,fe> void
) :<fe> void // end of [array_foreach_cloptr]
fun{a:vt0p}
array_foreach_cloref
  {n:int}{fe:eff}
(
  A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t(n), f: (&a >> _) -<cloref,fe> void
) :<fe> void // end of [array_foreach_cloref]
//
(* ****** ****** *)
//
fun{a:vt0p}
array_foreach_vclo
  {v:view}{n:int}{fe:eff}
(
  pfv: !v
| A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t n, f: &(!v | &a >> _) -<clo,fe> void
) :<fe> void // end of [array_foreach_vclo]
fun{a:vt0p}
array_foreach_vcloptr
  {v:view}{n:int}{fe:eff}
(
  pfv: !v
| A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t(n), f: !(!v | &a >> _) -<cloptr,fe> void
) :<fe> void // end of [array_foreach_vcloptr]
//
(* ****** ****** *)

fun{
a1,a2:vt0p
} array_foreach2
  {n:int}
(
  A1: &(@[INV(a1)][n]) >> @[a1][n]
, A2: &(@[INV(a2)][n]) >> @[a2][n]
, asz: size_t (n)
) : sizeLte (n) // end of [array_foreach2]
//
fun{
a1,a2:vt0p}{env:vt0p
} array_foreach2_env
  {n:int}
(
  A1: &(@[INV(a1)][n]) >> @[a1][n]
, A2: &(@[INV(a2)][n]) >> @[a2][n]
, asz:size_t (n)
, env: &(env) >> env
) : sizeLte (n) // end of [array_foreach2_env]
//
fun{
a1,a2:vt0p}{env:vt0p
} array_foreach2$cont
  (x1: &a1, x2: &a2, env: &env): bool
fun{
a1,a2:vt0p}{env:vt0p
} array_foreach2$fwork
  (x1: &a1 >> _, x2: &a2 >> _, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
a:vt0p
} array_iforeach{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n
) : sizeLte (n) // end of [array_iforeach]
//
fun{
a:vt0p}{env:vt0p
} array_iforeach_env{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n, env: &(env) >> _
) : sizeLte (n) // end of [array_iforeach_env]
//
fun{
a:vt0p}{env:vt0p
} array_iforeach$cont (i: size_t, x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} array_iforeach$fwork (i: size_t, x: &a >> _, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
a:vt0p
} array_rforeach{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n
) : sizeLte (n) // end of [array_rforeach]
//
fun{
a:vt0p}{env:vt0p
} array_rforeach_env{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n, env: &(env) >> _
) : sizeLte (n) // end of [array_rforeach_env]
//
fun{
a:vt0p}{env:vt0p
} array_rforeach$cont (x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} array_rforeach$fwork (x: &a >> _, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{a:vt0p}
array_initize{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: size_t n
) : void // end of [array_initize]
//
fun{a:vt0p}
array_initize$init (i: size_t, x: &a? >> a): void
//
(* ****** ****** *)

fun{a:t0p}
array_initize_elt{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: size_t n, elt: a
) :<!wrt> void // end of [array_initize_elt]

(* ****** ****** *)

fun{a:t0p}
array_initize_list{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: int n, xs: list (INV(a), n)
) :<!wrt> void // end of [array_initize_list]
fun{a:t0p}
array_initize_rlist{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: int n, xs: list (INV(a), n)
) :<!wrt> void // end of [array_initize_rlist]

(* ****** ****** *)

fun{a:vt0p}
array_initize_list_vt{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: int n, xs: list_vt (INV(a), n)
) :<!wrt> void // end of [array_initize_list_vt]
fun{a:vt0p}
array_initize_rlist_vt{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: int n, xs: list_vt (INV(a), n)
) :<!wrt> void // end of [array_initize_rlist_vt]

(* ****** ****** *)
//
fun{a:vt0p}
array_uninitize{n:int}
(
  A: &(@[INV(a)][n]) >> @[a?][n], asz: size_t n
) : void // end of [array_uninitize]
//
fun{a:vt0p}
array_uninitize$clear (i: size_t, x: &a >> a?): void
//
(* ****** ****** *)
//
fun{a:vt0p}
array_bsearch
  {n:int} (A: &RD(@[a][n]), n: size_t (n)):<> sizeLte (n)
//
fun{a:vt0p}
array_bsearch$ford (x: &RD(a)):<> int
//
fun{a:vt0p}
array_bsearch_fun{n:int}
(
  A: &RD(@[a][n]), asz: size_t (n), key: &RD(a), cmp: cmpref (a)
) :<> sizeLte (n) // end of [array_bsearch_fun]
//
(* ****** ****** *)

(*
** HX: this one is based on [bsearch] in [stdlib]
*)
fun{a:vt0p}
array_bsearch_stdlib{n:int}
(
  A: &RD(@[a][n]), asz: size_t (n), key: &RD(a), cmp: cmpref (a)
) :<> Ptr0 (* found/~found : ~null/null *)

(* ****** ****** *)
//
fun{a:vt0p}
array_quicksort{n:int}
  (A: &(@[INV(a)][n]) >> @[a][n], n: size_t n):<!wrt> void
fun{a:vt0p}
array_quicksort$cmp (x1: &RD(a), x2: &RD(a)):<> int(*sgn*)
//
(* ****** ****** *)

(*
** HX: this one is based on [qsort] in [stdlib]
*)
fun{a:vt0p}
array_quicksort_stdlib{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], n: size_t n, cmp: cmpref (a)
) :<!wrt> void // end of [array_quicksort_stdlib]

(* ****** ****** *)
//
fun{
a:vt0p}{b:vt0p
} array_mapto{n:int}
(
  A: &array(INV(a), n)
, B: &array(b?, n) >> array (b, n)
, n: size_t (n)
) : void // end of [array_mapto]
//
fun{
a:vt0p}{b:vt0p
} array_mapto$fwork (x: &a, y: &b? >> b) : void
//
(* ****** ****** *)
//
fun{
a,b:vt0p}{c:vt0p
} array_map2to{n:int}
(
  A: &array(INV(a), n)
, B: &array(INV(b), n)
, C: &array(c?, n) >> array (c, n)
, n: size_t (n)
) : void // end of [array_map2to]
//
fun{
a,b:vt0p}{c:vt0p
} array_map2to$fwork (x: &a, y: &b, z: &c? >> c) : void
//
(* ****** ****** *)
//
fun{a:vt0p}
array_permute{n:int}
  (A: &(@[INV(a)][n]) >> @[a][n], n: size_t n): void
//
fun{}
array_permute$randint {n:int | n > 0} (size_t n): sizeLt (n)
//
(* ****** ****** *)

(* end of [array.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/integer_ptr.atxt
** Time of generation: Sat Oct 17 15:19:46 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)

(* ****** ****** *)
//
// HX: for unindexed integer types
//
(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

typedef SHR(a:t@ype) = a // for commenting purpose
typedef NSH(a:t@ype) = a // for commenting purpose

(* ****** ****** *)
//
stadef intptrknd = intptr_kind
stadef uintptrknd = uintptr_kind
//
(* ****** ****** *)
//
fun g0int2int_int_intptr(int):<> intptr = "mac#%"
fun g1int2int_int_intptr{i:int}(int(i)):<> intptr(i) = "mac#%"
fun g0int2int_lint_intptr(lint):<> intptr = "mac#%"
fun g1int2int_lint_intptr{i:int}(lint(i)):<> intptr(i) = "mac#%"
//
(* ****** ****** *)
//
fun g0int2uint_int_uintptr(int):<> uintptr = "mac#%"
fun g1int2uint_int_uintptr{i:nat}(int(i)):<> uintptr(i) = "mac#%"
//
(* ****** ****** *)
//
fun g0uint2uint_uint_uintptr(uint):<> uintptr = "mac#%"
fun g1uint2uint_uint_uintptr{u:int}(uint(u)):<> uintptr(u) = "mac#%"
fun g0uint2uint_ulint_uintptr(ulint):<> uintptr = "mac#%"
fun g1uint2uint_ulint_uintptr{u:int}(ulint(u)):<> uintptr(u) = "mac#%"
//
(* ****** ****** *)
//
fun g0int_neg_intptr (x: intptr):<> intptr = "mac#%"
fun g0int_abs_intptr (x: intptr):<> intptr = "mac#%"
fun g0int_succ_intptr (x: intptr):<> intptr = "mac#%"
fun g0int_pred_intptr (x: intptr):<> intptr = "mac#%"
fun g0int_half_intptr (x: intptr):<> intptr = "mac#%"
fun g0int_asl_intptr (x: intptr, n: intGte(0)):<> intptr = "mac#%"
fun g0int_asr_intptr (x: intptr, n: intGte(0)):<> intptr = "mac#%"
fun g0int_add_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_sub_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_mul_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_div_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_mod_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_isltz_intptr (x: intptr):<> bool = "mac#%"
fun g0int_isltez_intptr (x: intptr):<> bool = "mac#%"
fun g0int_isgtz_intptr (x: intptr):<> bool = "mac#%"
fun g0int_isgtez_intptr (x: intptr):<> bool = "mac#%"
fun g0int_iseqz_intptr (x: intptr):<> bool = "mac#%"
fun g0int_isneqz_intptr (x: intptr):<> bool = "mac#%"
fun g0int_lt_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_lte_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_gt_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_gte_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_eq_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_neq_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_compare_intptr (x: intptr, y: intptr):<> int = "mac#%"
fun g0int_max_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_min_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
//
(* ****** ****** *)
//
fun fprint_intptr
  : fprint_type (intptr) = "mac#%"
overload fprint with fprint_intptr
fun print_intptr (x: intptr): void = "mac#%"
fun prerr_intptr (x: intptr): void = "mac#%"
overload print with print_intptr
overload prerr with prerr_intptr
//
(* ****** ****** *)
//
fun g0uint_succ_uintptr (x: uintptr):<> uintptr = "mac#%"
fun g0uint_pred_uintptr (x: uintptr):<> uintptr = "mac#%"
fun g0uint_half_uintptr (x: uintptr):<> uintptr = "mac#%"
fun g0uint_add_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_sub_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_mul_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_div_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_mod_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_lsl_uintptr (x: uintptr, n: intGte(0)):<> uintptr = "mac#%"
fun g0uint_lsr_uintptr (x: uintptr, n: intGte(0)):<> uintptr = "mac#%"
fun g0uint_lnot_uintptr (x: uintptr):<> uintptr = "mac#%"
fun g0uint_lor_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_lxor_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_land_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_isgtz_uintptr (x: uintptr):<> bool = "mac#%"
fun g0uint_iseqz_uintptr (x: uintptr):<> bool = "mac#%"
fun g0uint_isneqz_uintptr (x: uintptr):<> bool = "mac#%"
fun g0uint_lt_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_lte_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_gt_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_gte_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_eq_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_neq_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_compare_uintptr (x: uintptr, y: uintptr):<> int = "mac#%"
fun g0uint_max_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_min_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
//
(* ****** ****** *)
//
fun fprint_uintptr
  : fprint_type (uintptr) = "mac#%"
overload fprint with fprint_uintptr
fun print_uintptr (x: uintptr): void = "mac#%"
fun prerr_uintptr (x: uintptr): void = "mac#%"
overload print with print_uintptr
overload prerr with prerr_uintptr
//
(* ****** ****** *)
//
fun g1int_neg_intptr : g1int_neg_type (intptrknd) = "mac#%"
fun g1int_abs_intptr : g1int_abs_type (intptrknd) = "mac#%"
fun g1int_succ_intptr : g1int_succ_type (intptrknd) = "mac#%"
fun g1int_pred_intptr : g1int_pred_type (intptrknd) = "mac#%"
fun g1int_half_intptr : g1int_half_type (intptrknd) = "mac#%"
fun g1int_add_intptr : g1int_add_type (intptrknd) = "mac#%"
fun g1int_sub_intptr : g1int_sub_type (intptrknd) = "mac#%"
fun g1int_mul_intptr : g1int_mul_type (intptrknd) = "mac#%"
fun g1int_div_intptr : g1int_div_type (intptrknd) = "mac#%"
fun g1int_nmod_intptr : g1int_nmod_type (intptrknd) = "mac#%"
fun g1int_isltz_intptr : g1int_isltz_type (intptrknd) = "mac#%"
fun g1int_isltez_intptr : g1int_isltez_type (intptrknd) = "mac#%"
fun g1int_isgtz_intptr : g1int_isgtz_type (intptrknd) = "mac#%"
fun g1int_isgtez_intptr : g1int_isgtez_type (intptrknd) = "mac#%"
fun g1int_iseqz_intptr : g1int_iseqz_type (intptrknd) = "mac#%"
fun g1int_isneqz_intptr : g1int_isneqz_type (intptrknd) = "mac#%"
fun g1int_lt_intptr : g1int_lt_type (intptrknd) = "mac#%"
fun g1int_lte_intptr : g1int_lte_type (intptrknd) = "mac#%"
fun g1int_gt_intptr : g1int_gt_type (intptrknd) = "mac#%"
fun g1int_gte_intptr : g1int_gte_type (intptrknd) = "mac#%"
fun g1int_eq_intptr : g1int_eq_type (intptrknd) = "mac#%"
fun g1int_neq_intptr : g1int_neq_type (intptrknd) = "mac#%"
fun g1int_compare_intptr : g1int_compare_type (intptrknd) = "mac#%"
fun g1int_max_intptr : g1int_max_type (intptrknd) = "mac#%"
fun g1int_min_intptr : g1int_min_type (intptrknd) = "mac#%"
//
(* ****** ****** *)
//
fun g1uint_succ_uintptr : g1uint_succ_type (uintptrknd) = "mac#%"
fun g1uint_pred_uintptr : g1uint_pred_type (uintptrknd) = "mac#%"
fun g1uint_half_uintptr : g1uint_half_type (uintptrknd) = "mac#%"
fun g1uint_add_uintptr : g1uint_add_type (uintptrknd) = "mac#%"
fun g1uint_sub_uintptr : g1uint_sub_type (uintptrknd) = "mac#%"
fun g1uint_mul_uintptr : g1uint_mul_type (uintptrknd) = "mac#%"
fun g1uint_div_uintptr : g1uint_div_type (uintptrknd) = "mac#%"
fun g1uint_mod_uintptr : g1uint_mod_type (uintptrknd) = "mac#%"
fun g1uint_isgtz_uintptr : g1uint_isgtz_type (uintptrknd) = "mac#%"
fun g1uint_iseqz_uintptr : g1uint_iseqz_type (uintptrknd) = "mac#%"
fun g1uint_isneqz_uintptr : g1uint_isneqz_type (uintptrknd) = "mac#%"
fun g1uint_lt_uintptr : g1uint_lt_type (uintptrknd) = "mac#%"
fun g1uint_lte_uintptr : g1uint_lte_type (uintptrknd) = "mac#%"
fun g1uint_gt_uintptr : g1uint_gt_type (uintptrknd) = "mac#%"
fun g1uint_gte_uintptr : g1uint_gte_type (uintptrknd) = "mac#%"
fun g1uint_eq_uintptr : g1uint_eq_type (uintptrknd) = "mac#%"
fun g1uint_neq_uintptr : g1uint_neq_type (uintptrknd) = "mac#%"
fun g1uint_compare_uintptr : g1uint_compare_type (uintptrknd) = "mac#%"
fun g1uint_max_uintptr : g1uint_max_type (uintptrknd) = "mac#%"
fun g1uint_min_uintptr : g1uint_min_type (uintptrknd) = "mac#%"
//
(* ****** ****** *)
//
macdef i2ptr (x) = g1int2int_int_intptr (,(x))
//
macdef u2ptr (x) = g1uint2uint_uint_uintptr (,(x))
//
(* ****** ****** *)

(* end of [integer_ptr.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/gnumber.atxt
** Time of generation: Sat Oct 17 15:19:47 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)

(* Author: Brandon Barker *)
(* Authoremail: brandon.barker AT gmail DOT com *)
(* Start time: July, 2013 *)

(* ****** ****** *)
//
// HX: for unindexed gnumber types
//
(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

abstype
fprecision_prop (a1:t0p, a2:t0p)
propdef
fprecision (a1:t0p, a2:t0p) = fprecision_prop (a1, a2)
praxi
fprecision_float (): fprecision (float, float)
praxi
fprecision_double (): fprecision (double, double)
praxi
fprecision_ldouble (): fprecision (ldouble, ldouble)

(* ****** ****** *)
//
// HX: generic number operations
//
(* ****** ****** *)
//

//
fun{a:t0p} gnumber_int (x: int):<> a
fun{a:t0p} gnumber_double (x: double):<> a
//
(* ****** ****** *)

fun{a:t0p} gabs_val (x: a):<> a
fun{a:t0p} gneg_val (x: a):<> a
fun{a:t0p} gsucc_val (x: a):<> a
fun{a:t0p} gpred_val (x: a):<> a
fun{a:t0p} grecip_val (x: a):<!exn> a

(* ****** ****** *)

fun{a:t0p} gadd_val_val (x: a, y: a):<> a
fun{a:t0p} gsub_val_val (x: a, y: a):<> a
fun{a:t0p} gmul_val_val (x: a, y: a):<> a
fun{a:t0p} gdiv_val_val (x: a, y: a):<!exn> a
fun{a:t0p} gmod_val_val (x: a, y: a):<!exn> a

(* ****** ****** *)
//
fun{a:t0p} gadd_val_int (x: a, y: int):<> a
fun{a:t0p} gsub_val_int (x: a, y: int):<> a
//
fun{a:t0p} gmul_int_val (x: int, y: a):<> a
fun{a:t0p} gmul_val_int (x: a, y: int):<> a
//
fun{a:t0p} gdiv_int_val (x: int, y: a):<!exn> a
fun{a:t0p} gdiv_val_int (x: a, y: int):<!exn> a
fun{a:t0p} gmod_val_int (x: a, y: int):<!exn> a
//
(* ****** ****** *)

fun{a:t0p} gsqrt_val (x: a):<!exn> a

(* ****** ****** *)

fun{a:t0p} gconjugate_val (x: a):<> a

(* ****** ****** *)

fun{a:t0p} gpow_int_val (n: intGte(0), x: a):<> a

(* ****** ****** *)

(* end of [gnumber.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/gorder.atxt
** Time of generation: Sat Oct 17 15:19:47 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)
//
// HX: generic ordering ops
//
(* ****** ****** *)
//
fun
{a:t0p}
gisltz_val (x: a):<> bool
fun
{a:t0p}
gisltez_val (x: a):<> bool
//
fun
{a:t0p}
gisgtz_val (x: a):<> bool
fun
{a:t0p}
gisgtez_val (x: a):<> bool
//
fun
{a:t0p}
giseqz_val (x: a):<> bool
fun
{a:t0p}
gisneqz_val (x: a):<> bool
//
(* ****** ****** *)
//
fun
{a:t0p}
glt_val_val (x: a, y: a):<> bool
fun
{a:t0p}
glte_val_val (x: a, y: a):<> bool
//
fun
{a:t0p}
ggt_val_val (x: a, y: a):<> bool
fun
{a:t0p}
ggte_val_val (x: a, y: a):<> bool
//
(* ****** ****** *)
//
fun
{a:t0p}
glt_val_int (x: a, y: int):<> bool
fun
{a:t0p}
glte_val_int (x: a, y: int):<> bool
//
fun
{a:t0p}
ggt_val_int (x: a, y: int):<> bool
fun
{a:t0p}
ggte_val_int (x: a, y: int):<> bool
//
(* ****** ****** *)
//
fun
{a:t0p}
geq_val_val (x: a, y: a):<> bool
fun
{a:t0p}
gneq_val_val (x: a, y: a):<> bool
//
(* ****** ****** *)
//
fun
{a:t0p}
geq_val_int (x: a, y: int):<> bool
fun
{a:t0p}
gneq_val_int (x: a, y: int):<> bool
//
(* ****** ****** *)
//
fun
{a:t0p}
gcompare_val_val (x: a, y: a):<> int
//
(* ****** ****** *)
//
fun
{a:t0p}
gmax_val_val (x: a, y: a):<> (a)
fun
{a:t0p}
gmin_val_val (x: a, y: a):<> (a)
//
(* ****** ****** *)
//
fun
{a:vt0p}
glt_ref_ref (x: &INV(a), y: &a):<> bool
fun
{a:vt0p}
glte_ref_ref (x: &INV(a), y: &a):<> bool
//
fun
{a:vt0p}
ggt_ref_ref (x: &INV(a), y: &a):<> bool
fun
{a:vt0p}
ggte_ref_ref (x: &INV(a), y: &a):<> bool
//
(* ****** ****** *)
//
fun
{a:vt0p}
geq_ref_ref (x: &INV(a), y: &a):<> bool
fun
{a:vt0p}
gneq_ref_ref (x: &INV(a), y: &a):<> bool
//
(* ****** ****** *)
//
fun
{a:vt0p}
gcompare_ref_ref (x: &INV(a), y: &a):<> int
//
(* ****** ****** *)

(* end of [gorder.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/matrixptr.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

absvtype
matrixptr_vt0ype_addr_int_int_vtype
  (a:vt@ype+, l: addr, m: int, n: int) = ptr
//
stadef
matrixptr = matrixptr_vt0ype_addr_int_int_vtype
vtypedef
matrixptr
  (a:vt@ype, m: int, n: int) = [l:addr] matrixptr(a, l, m, n)
//
(* ****** ****** *)

absvtype
matrixptrout_vt0ype_addr_int_int_vtype
  (a:vt@ype, l: addr, m: int, n: int) = ptr
//
stadef
matrixptrout = matrixptrout_vt0ype_addr_int_int_vtype
//
(* ****** ****** *)

praxi
lemma_matrixptr_param{a:vt0p}
  {l:addr}{m,n:int} (A: !matrixptr(a, l, m, n)): [m >= 0; n >= 0] void
// end of [lemma_matrixptr_param]

(* ****** ****** *)

castfn
matrixptr_encode :
  {a:vt0p}{l:addr}{m,n:int}
  (matrix_v(INV(a), l, m, n), mfree_gc_v(l) | ptr l) -<0> matrixptr(a, l, m, n)
// end of [matrixptr_encode]

castfn
matrixptr_encode2 :
  {a:vt0p}{l:addr}{m,n:int}
  @(matrix_v(INV(a), l, m, n), mfree_gc_v(l) | ptr l) -<0> matrixptr(a, l, m, n)
// end of [matrixptr_encode2]

(* ****** ****** *)
//
castfn
matrixptr2ptr
  {a:vt0p}
  {l:addr}{m,n:int}
  (A: !matrixptr(INV(a), l, m, n)):<> ptr(l)
//
castfn
matrixptrout2ptr
  {a:t0p}
  {l:addr}{m,n:int}
  (A: !matrixptrout(INV(a), l, m, n)):<> ptr(l)
//
(* ****** ****** *)

praxi
matrixptr_takeout
  {a:vt0p}{l:addr}{m,n:int}
(
  !matrixptr(INV(a), l, m, n) >> matrixptrout(a?, l, m, n)
) : matrix_v(a, l, m, n) // endfun
praxi
matrixptr_addback
  {a:vt0p}{l:addr}{m,n:int}
(
  pf: matrix_v(INV(a), l, m, n)
| mat: !matrixptrout(a?, l, m, n) >> matrixptr(a, l, m, n)
) : void // end of [matrixptr_addback]

(* ****** ****** *)

fun{
} arrayptr2matrixptr_int
  {a:vt0p}{l:addr}{m,n:nat}
  (A: arrayptr(INV(a), l, m*n), m: int m, n: int n):<> matrixptr(a, l, m, n)
fun{
} arrayptr2matrixptr_size
  {a:vt0p}{l:addr}{m,n:int}
  (A: arrayptr(INV(a), l, m*n), m: size_t m, n: size_t n):<> matrixptr(a, l, m, n)
//
symintr arrayptr2matrixptr
overload arrayptr2matrixptr with arrayptr2matrixptr_int
overload arrayptr2matrixptr with arrayptr2matrixptr_size
//
(* ****** ****** *)

fun{
a:t0p
} matrixptr_make_elt
  {m,n:int}
  (m: size_t m, n: size_t n, x: a):<!wrt> matrixptr(a, m, n)
// end of [matrixptr_make_elt]

(* ****** ****** *)

fun{a:t0p}
matrixptr_get_at_int
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n), i: natLt (m), n: int n, j: natLt (n)
) :<> (a) // end of [matrixptr_get_at_int]
fun{a:t0p}
matrixptr_get_at_size
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n), i: sizeLt (m), n: size_t n, j: sizeLt (n)
) :<> (a) // end of [matrixptr_get_at_size]
//
symintr matrixptr_get_at
overload matrixptr_get_at with matrixptr_get_at_int of 0
overload matrixptr_get_at with matrixptr_get_at_size of 0
//
(* ****** ****** *)

fun{a:t0p}
matrixptr_set_at_int
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n), i: natLt (m), n: int n, j: natLt (n), x: a
) :<!wrt> void // end of [matrixptr_set_at_int]
fun{a:t0p}
matrixptr_set_at_size
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n), i: sizeLt (m), n: size_t n, j: sizeLt (n), x: a
) :<!wrt> void // end of [matrixptr_set_at_size]
//
symintr matrixptr_set_at
overload matrixptr_set_at with matrixptr_set_at_int of 0
overload matrixptr_set_at with matrixptr_set_at_size of 0
//
(* ****** ****** *)

fun{a:vt0p}
matrixptr_exch_at_int
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n)
, i: natLt (m), n: int n, j: natLt (n), x: &a>>a
) :<!wrt> void // end of [matrixptr_exch_at_int]
fun{a:vt0p}
matrixptr_exch_at_size
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n)
, i: sizeLt (m), n: size_t n, j: sizeLt (n), x: &a>>a
) :<!wrt> void // end of [matrixptr_exch_at_size]
//
symintr matrixptr_exch_at
overload matrixptr_exch_at with matrixptr_exch_at_int
overload matrixptr_exch_at with matrixptr_exch_at_size
//
(* ****** ****** *)

(*
fprint_matrix$sep1 // col separation
fprint_matrix$sep2 // row separation
*)
fun{a:vt0p}
fprint_matrixptr{m,n:int}
(
  out: FILEref
, M: !matrixptr(INV(a), m, n), m: size_t m, n: size_t n
) : void // end of [fprint_matrixptr]

fun{a:vt0p}
fprint_matrixptr_sep{m,n:int}
(
  out: FILEref
, M: !matrixptr(INV(a), m, n), m: size_t (m), n: size_t (n)
, sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_matrixptr_sep]

(* ****** ****** *)

fun matrixptr_free
  {a:t0p}{l:addr}{m,n:int}
  (A: matrixptr(INV(a), l, m, n)):<!wrt> void = "mac#%"
// end of [matrixptr_free]

(*
fun{a:vt0p}
matrix_uninitize$clear
  (i: size_t, j: size_t, x: &a >> a?): void
*)
fun{
a:vt0p
} matrixptr_freelin
  {l:addr}{m,n:int}
  (A: matrixptr(INV(a), l, m, n)):<!wrt> void = "mac#%"
// end of [matrixptr_freelin]

(* ****** ****** *)
//
(*
fun{a:vt0p}
matrix_tabulate$fopr (i: size_t, j: size_t): (a)
*)
fun{a:vt0p}
matrixptr_tabulate
  {m,n:int} (nrow: size_t m, ncol: size_t n): matrixptr (a, m, n)
//
fun{a:vt0p}
matrixptr_tabulate_cloref
  {m,n:int}
(
  nrow: size_t m, ncol: size_t n, f: (sizeLt(m), sizeLt(n)) -<cloref> a
) : matrixptr (a, m, n) // end-of-fun
//
(* ****** ****** *)

(*
fun{
a:vt0p}{env:vt0p
} matrix_foreach$fwork (x: &a >> _, env: &(env) >> _): void
*)
//
fun{
a:vt0p
} matrixptr_foreach{m,n:int}
(
  A: !matrixptr(INV(a), m, n) >> _, m: size_t m, n: size_t n
) : void // end of [matrixptr_foreach]
fun{
a:vt0p}{env:vt0p
} matrixptr_foreach_env{m,n:int}
(
  A: !matrixptr(INV(a), m, n) >> _, m: size_t m, n: size_t n, env: &(env) >> _
) : void // end of [matrixptr_foreach_env]

(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with matrixptr_get_at_int
overload [] with matrixptr_get_at_size
overload [] with matrixptr_set_at_int
overload [] with matrixptr_set_at_size

(* ****** ****** *)

overload fprint with fprint_matrixptr
overload fprint with fprint_matrixptr_sep

(* ****** ****** *)

overload ptrcast with matrixptr2ptr
overload ptrcast with matrixptrout2ptr

(* ****** ****** *)

(* end of [matrixptr.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/arrayptr.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

#if(0)
//
// HX-2013-06:
// it is declared in [basic_dyn.sats]
//
absvtype
arrayptr_vt0ype_addr_int_vtype
  (a:vt0ype+, l: addr, n: int) = ptr (l)
//
stadef
arrayptr = arrayptr_vt0ype_addr_int_vtype
vtypedef
arrayptr
  (a:vt0p, n:int) = [l:addr] arrayptr (a, l, n)
//
#endif

(* ****** ****** *)

absvtype
arrayptrout_vt0ype_addr_int_vtype
  (a:t@ype, l: addr, n: int) = ptr (l)
stadef arrayptrout = arrayptrout_vt0ype_addr_int_vtype

(* ****** ****** *)

praxi
lemma_arrayptr_param{a:vt0p}
  {l:addr}{n:int} (A: !arrayptr (a, l, n)): [n >= 0] void
// end of [lemma_arrayptr_param]

(* ****** ****** *)

castfn
arrayptr_encode :
  {a:vt0p}{l:addr}{n:int}
  (array_v (INV(a), l, n), mfree_gc_v l | ptr l) -<0> arrayptr (a, l, n)
// end of [arrayptr_encode]
castfn
arrayptr_encode2 :
  {a:vt0p}{l:addr}{n:int}
  @(array_v (INV(a), l, n), mfree_gc_v l | ptr l) -<0> arrayptr (a, l, n)
// end of [arrayptr_encode2]

(* ****** ****** *)

castfn
arrayptr_objectify
  {a:vt0p}{l:addr}{n:int}
  (array_v (INV(a), l, n) | ptr(l)):<> (mfree_ngc_v(l) | arrayptr(a, l, n))
// end of [arrayptr_objectify]
castfn
arrayptr_unobjectify
  {a:vt0p}{l:addr}{n:int}
  (mfree_ngc_v(l) | arrayptr(INV(a), l, n)):<> (array_v (a, l, n) | ptr(l))
// end of [arrayptr_objectify]

(* ****** ****** *)
//
castfn
arrayptr2ptr
  {a:vt0p}
  {l:addr}{n:int} (A: !arrayptr (INV(a), l, n)):<> ptr (l)
castfn
arrayptrout2ptr
  {a:t0p}{l:addr}{n:int} (A: !arrayptrout (INV(a), l, n)):<> ptr (l)
//
(* ****** ****** *)

praxi
arrayptr_takeout
  {a:vt0p}{l:addr}{n:int}
(
  A: !arrayptr (INV(a), l, n) >> arrayptrout (a?, l, n)
) : array_v (a, l, n) // end of [arrayptr_takeout]

praxi
arrayptr_addback
  {a:vt0p}{l:addr}{n:int}
(
  pf: array_v (INV(a), l, n) | A: !arrayptrout (a?, l, n) >> arrayptr (a, l, n)
) : void // end of [arrayptr_addback]

(* ****** ****** *)

castfn
arrayptr_takeout_viewptr
  {a:vt0p}{l:addr}{n:int}
(
  A: !arrayptr (INV(a), l, n) >> arrayptrout (a?, l, n)
) : (array_v (a, l, n) | ptr l) // endfun

(* ****** ****** *)

castfn
arrpsz_encode :
  {a:vt0p}{n:int}
  @(arrayptr (INV(a), n), size_t n) -<0> arrpsz (a, n)
// end of [arrpsz_encode]

castfn
arrpsz_decode :
  {a:vt0p}{n:int}
  arrpsz (INV(a), n) -<0> @(arrayptr (a, n), size_t n)
// end of [arrpsz_decode]

(* ****** ****** *)

fun
arrpsz_get_ptrsize
  {a:vt0p}{n:int}
(
  psz: arrpsz (INV(a), n), asz: &size_t? >> size_t (n)
) :<!wrt> arrayptr (a, n) = "mac#%" // endfun

(* ****** ****** *)

symintr arrayptr

(* ****** ****** *)

fun{
a:t0p
} arrayptr_make_elt
  {n:int} (asz: size_t n, x: a):<!wrt> arrayptr (a, n)
// end of [arrayptr_make_elt]

(* ****** ****** *)

fun{
} arrayptr_make_intrange
  {l,r:int | l <= r}
  (l: int l, r: int r):<!wrt> arrayptr (intBtw(l, r), r-l)
// end of [arrayptr_make_intrange]

(* ****** ****** *)
//
// HX: this one is a field-selection
//
fun
arrayptr_make_arrpsz
  {a:vt0p}{n:int}
  (psz: arrpsz (INV(a), n)):<> arrayptr (a, n) = "mac#%"
overload arrayptr with arrayptr_make_arrpsz

(* ****** ****** *)

fun{a:t0p}
arrayptr_make_list{n:int}
  (asz: int n, xs: list (INV(a), n)):<!wrt> arrayptr (a, n)
// end of [arrayptr_make_list]
fun{a:t0p}
arrayptr_make_rlist{n:int}
  (asz: int n, xs: list (INV(a), n)):<!wrt> arrayptr (a, n)
// end of [arrayptr_make_rlist]

(* ****** ****** *)

fun{a:t0p}
arrayptr_make_subarray
  {n:int}{st,ln:int | st+ln <= n}
  (A: RD(arrayref (a, n)), size_t (st), size_t (ln)): arrayptr (a, ln)
// end of [arrayref_make_subarray]

(* ****** ****** *)

fun{a:vt0p}
arrayptr_make_list_vt{n:int}
  (asz: int n, xs: list_vt (INV(a), n)):<!wrt> arrayptr (a, n)
// end of [arrayptr_make_list_vt]
fun{a:vt0p}
arrayptr_make_rlist_vt{n:int}
  (asz: int n, xs: list_vt (INV(a), n)):<!wrt> arrayptr (a, n)
// end of [arrayptr_make_rlist_vt]

(* ****** ****** *)

fun{a:vt0p}
arrayptr_make_uninitized
  {n:int} (asz: size_t n):<!wrt> arrayptr (a?, n)
// end of [arrayptr_make_uninitized]

(* ****** ****** *)

fun{a:vt0p}
arrayptr_imake_list{n:int}
(
  A: !arrayptr (INV(a), n) >> arrayptr (a?!, n), n: size_t (n)
) : list_vt (a, n) // end of [arrayptr_imake_list]

(* ****** ****** *)

fun arrayptr_free
  {a:t0p}{l:addr}{n:int}
  (A: arrayptr (INV(a), l, n)):<!wrt> void = "mac#%"
// end of [arrayptr_free]

(* ****** ****** *)

(*
fun{}
fprint_array$sep (out: FILEref): void
*)
fun{a:vt0p}
fprint_arrayptr
  {l:addr}{n:int}
(
  out: FILEref, A: !arrayptr (INV(a), l, n), n: size_t n
) : void // end of [fprint_arrayptr]
fun{a:vt0p}
fprint_arrayptr_sep
  {l:addr}{n:int}
(
  out: FILEref
, A: !arrayptr (INV(a), l, n), n: size_t n, sep: NSH(string)
) : void // end of [fprint_arrayptr_sep]

(* ****** ****** *)

symintr arrayptr_get_at
//
fun{
a:t0p}{tk:tk
} arrayptr_get_at_gint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1int (tk, i)):<> (a)
fun{
a:t0p}{tk:tk
} arrayptr_get_at_guint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1uint (tk, i)):<> (a)
//
overload arrayptr_get_at with arrayptr_get_at_gint
overload arrayptr_get_at with arrayptr_get_at_guint
//
(* ****** ****** *)

symintr arrayptr_set_at
//
fun{
a:t0p}{tk:tk
} arrayptr_set_at_gint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1int (tk, i), x: a):<!wrt> void
fun{
a:t0p}{tk:tk
} arrayptr_set_at_guint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1uint (tk, i), x: a):<!wrt> void
//
overload arrayptr_set_at with arrayptr_set_at_gint of 0
overload arrayptr_set_at with arrayptr_set_at_guint of 0
//
(* ****** ****** *)

symintr arrayptr_exch_at

fun{
a:vt0p}{tk:tk
} arrayptr_exch_at_gint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1int (tk, i), x: &a >> _):<!wrt> void
// end of [arrayptr_exch_at_gint]

fun{
a:vt0p}{tk:tk
} arrayptr_exch_at_guint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1uint (tk, i), x: &a >> _):<!wrt> void
// end of [arrayptr_exch_at_guint]

overload arrayptr_exch_at with arrayptr_exch_at_gint of 0
overload arrayptr_exch_at with arrayptr_exch_at_guint of 0

(* ****** ****** *)

fun{a:vt0p}
arrayptr_interchange
  {n:int}
(
  A: !arrayptr (INV(a), n), i: sizeLt n, j: sizeLt n
) :<!wrt> void // end of [arrayptr_interchange]

(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_foreach$cont (x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_foreach$fwork (x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayptr_foreach{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n)
) : sizeLte(n) // end of [arrayptr_foreach]
fun{
a:vt0p}{env:vt0p
} arrayptr_foreach_env{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n), env: &(env) >> _
) : sizeLte(n) // end of [arrayptr_foreach_env]

(* ****** ****** *)

fun{a:vt0p}
arrayptr_foreach_fun
  {n:int}{fe:eff}
(
  A: !arrayptr (INV(a), n), asz: size_t n, f: (&a) -<fun,fe> void
) :<fe> void // end of [arrayptr_foreach_fun]

fun{a:vt0p}
arrayptr_foreach_funenv
  {v:view}
  {vt:vtype}
  {n:int}
  {fe:eff}
(
  pfv: !v
| A: !arrayptr (INV(a), n)
, asz: size_t n
, f: (!v | &a, !vt) -<fun,fe> void
, env: !vt
) :<fe> void
// end of [arrayptr_foreach_funenv]

(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_iforeach$cont (i: size_t, x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_iforeach$fwork (i: size_t, x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayptr_iforeach{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n)
) : sizeLte(n) // end of [arrayptr_iforeach]
fun{
a:vt0p}{env:vt0p
} arrayptr_iforeach_env{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n), env: &(env) >> _
) : sizeLte(n) // end of [arrayptr_iforeach_env]

(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_rforeach$cont (x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_rforeach$fwork (x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayptr_rforeach{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n)
) : sizeLte(n) // end of [arrayptr_rforeach]
fun{
a:vt0p}{env:vt0p
} arrayptr_rforeach_env{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n), env: &(env) >> _
) : sizeLte(n) // end of [arrayptr_rforeach_env]

(* ****** ****** *)

(*
fun{a:vt0p}
array_initize$init (i: size_t, x: &a >> a?): void
*)
fun{a:vt0p}
arrayptr_initize
  {l:addr}{n:int}
(
  A: !arrayptr (a?, l, n) >> arrayptr (a, l, n), asz: size_t n
) : void // end of [arrayptr_initize]
macdef arrayptr_initialize = arrayptr_initize

(* ****** ****** *)

(*
fun{a:vt0p}
array_uninitize$clear (i: size_t, x: &a >> a?): void
*)
fun{a:vt0p}
arrayptr_uninitize
  {l:addr}{n:int}
(
  A: !arrayptr (INV(a), l, n) >> arrayptr (a?, l, n), asz: size_t n
) : void // end of [arrayptr_uninitize]
macdef
arrayptr_uninitialize = arrayptr_uninitize

(* ****** ****** *)

(*
fun{a:vt0p}
array_uninitize$clear (i: size_t, x: &a >> a?): void
*)
fun{a:vt0p}
arrayptr_freelin
  {l:addr}{n:int}
  (A: arrayptr (INV(a), l, n), asz: size_t (n)): void
// end of [arrayptr_freelin]

(* ****** ****** *)
//
(*
fun{a:vt0p}
array_tabulate$fopr (index: size_t): (a)
*)
fun{a:vt0p}
arrayptr_tabulate
  {n:int} (asz: size_t n): arrayptr (a, n)
//
fun{a:vt0p}
arrayptr_tabulate_cloref
  {n:int}
  (size_t n, (sizeLt(n)) -<cloref> a): arrayptr (a, n)
//
(* ****** ****** *)
//
fun
{a:vt0p}
arrayptr_quicksort
  {n:int}(A: !arrayptr(a, n) >> _, asz: size_t(n)): void
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with arrayptr_get_at_gint of 0
overload [] with arrayptr_get_at_guint of 0
overload [] with arrayptr_set_at_gint of 0
overload [] with arrayptr_set_at_guint of 0

(* ****** ****** *)

overload free with arrayptr_free

(* ****** ****** *)

overload fprint with fprint_arrayptr
overload fprint with fprint_arrayptr_sep

(* ****** ****** *)

overload ptrcast with arrayptr2ptr
overload ptrcast with arrayptrout2ptr

(* ****** ****** *)

(* end of [arrayptr.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/stream_vt.atxt
** Time of generation: Sun Oct 18 08:25:08 2015
*)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = vt@ype

(* ****** ****** *)
//
// HX: lazy linear streams
//
datavtype
stream_vt_con
  (a:vt@ype+) =
  | stream_vt_nil of ((*void*))
  | stream_vt_cons of (a, stream_vt(a))
//
where
stream_vt(a:vt@ype) = lazy_vt(stream_vt_con(a))
//
(* ****** ****** *)

vtypedef
streamopt_vt (a:vt0p) = Option_vt(stream_vt(a))

(* ****** ****** *)
//
// HX-2014-04-07:
// this is a regular function
// instead of a cast function
//
fun{a:t0p}
stream_vt2t
  (xs: stream_vt (INV(a))): stream (a)
//
(* ****** ****** *)

fun{a:vt0p}
stream2list_vt
  (xs: stream_vt (INV(a))): List0_vt (a)
// end of [stream2list_vt]

(* ****** ****** *)

fun{a:t0p}
stream_vt_free (xs: stream_vt a):<!wrt> void

(* ****** ****** *)
//
fun{a:t0p}
stream_vt_drop_exn
  (xs: stream_vt(INV(a)), n: intGte(0)): stream_vt(a)
// end of [stream_vt_drop_exn]
//
fun{a:t0p}
stream_vt_drop_opt
  (xs: stream_vt(INV(a)), n: intGte(0)): streamopt_vt(a)
// end of [stream_vt_drop_opt]
//
(* ****** ****** *)
//
fun{a:t0p}
stream_vt_head
  (xs: stream_vt(INV(a))):<!exnwrt> (a)
fun{a:t0p}
stream_vt_tail
  (xs: stream_vt(INV(a))):<!exnwrt> stream_vt(a)
//
fun{a:vt0p}
stream_vt_uncons
  (xs: &stream_vt(INV(a)) >> stream_vt(a)):<!exnwrt> (a)
//
(* ****** ****** *)

fun{
a:vt0p}{env:vt0p
} stream_vt_foreach$fwork
  (x: &a >> a?!, env: &env >> _): void // lin-cleared
fun{a:vt0p}
stream_vt_foreach (xs: stream_vt (INV(a))): void
fun{
a:vt0p}{env:vt0p
} stream_vt_foreach_env (xs: stream_vt (INV(a)), &env >> _): void

(* ****** ****** *)
//
fun{a:vt0p}
stream_vt_filter$pred (x: &a):<> bool
//
fun{a:t0p}
stream_vt_filter (xs: stream_vt (INV(a))): stream_vt (a)
//
fun{a:t0p}
stream_vt_filter_fun
(
  xs: stream_vt (INV(a)), pred: (&a) -<fun> bool
) : stream_vt (a) // end of [stream_vt_filter_fun]
fun{a:t0p}
stream_vt_filter_cloptr
(
  xs: stream_vt (INV(a)), pred: (&a) -<cloptr> bool
) : stream_vt (a) // end of [stream_vt_filter_cloptr]
//
fun{a:vt0p}
stream_vt_filterlin$clear (x: &a >> a?):<!wrt> void
fun{a:vt0p}
stream_vt_filterlin (xs: stream_vt (INV(a))): stream_vt (a)
//
(* ****** ****** *)
//
fun{
a:vt0p}{b:vt0p
} stream_vt_map$fopr (x: &a >> a?!): b // lin-cleared
fun{
a:vt0p}{b:vt0p
} stream_vt_map (xs: stream_vt (INV(a))): stream_vt (b)
//
fun{
a:vt0p}{b:vt0p
} stream_vt_map_fun
  (xs: stream_vt (INV(a)), f: (&a >> a?!) -<fun> b): stream_vt (b)
fun{
a:vt0p}{b:vt0p
} stream_vt_map_cloptr
  (xs: stream_vt (INV(a)), f: (&a >> a?!) -<cloptr> b): stream_vt (b)
//
(* ****** ****** *)
//
fun{
a1,a2:t0p}{b:vt0p
} stream_vt_map2$fopr
  (x1: &a1 >> _, x2: &a2 >> _): b
fun{
a1,a2:t0p}{b:vt0p
} stream_vt_map2 (
  xs1: stream_vt (INV(a1))
, xs2: stream_vt (INV(a2))
) : stream_vt (b) // end of [stream_vt_map2]
//
fun{
a1,a2:t0p}{b:vt0p
} stream_vt_map2_fun
(
  xs1: stream_vt (INV(a1))
, xs2: stream_vt (INV(a2))
, f: (&a1 >> _, &a2 >> _) -<fun> b
) : stream_vt (b) // end of [stream_vt_map2_fun]
fun{
a1,a2:t0p}{b:vt0p
} stream_vt_map2_cloptr
(
  xs1: stream_vt (INV(a1))
, xs2: stream_vt (INV(a2))
, f: (&a1 >> _, &a2 >> _) -<cloptr> b
) : stream_vt (b) // end of [stream_vt_map2_cloptr]
//
(* ****** ****** *)

fun{a:vt0p}
stream_vt_tabulate (): stream_vt (a)
fun{a:vt0p}
stream_vt_tabulate$fopr (i: intGte(0)): (a)

(* ****** ****** *)
//
absvtype
streamer_vtype (a:vt@ype+) = ptr
//
vtypedef
streamer_vt (a:vt0p) = streamer_vtype (a)
//
(* ****** ****** *)
//
fun{}
streamer_vt_make
  {a:vt0p} (stream_vt(INV(a))): streamer_vt(a)
//
fun{}
streamer_vt_free{a:vt0p} (streamer_vt(INV(a))): void
//
fun{
a:vt@ype
} streamer_vt_eval_exn (xser: !streamer_vt(INV(a))): (a)
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

(* ****** ****** *)

overload ~ with streamer_vt_free

(* ****** ****** *)

overload [] with streamer_vt_eval_exn

(* ****** ****** *)

overload .head with stream_vt_head
overload .tail with stream_vt_tail

(* ****** ****** *)

(* end of [stream_vt.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/strptr.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

(*
** HX-2012:
** a Strptr0 is either the null-pointer or Strptr1
** a Strptr1 is a null-terminated arrayptr of characters
*)

(* ****** ****** *)

abst@ype
strbuf_t0ype (m:int, n:int) // HX: [m] byte size

(* ****** ****** *)

stadef
strbuf = strbuf_t0ype
viewdef
strbuf_v (l:addr, m:int, n:int) = strbuf (m, n) @ l

(* ****** ****** *)
//
praxi
strbuf2bytes
  {m,n:int} (buf: &strbuf (m, n) >> b0ytes (m)): void
//
praxi
strbuf2bytes_v
  {l:addr}{m,n:int} (pf: strbuf_v (l, m, n)): b0ytes_v (l, m)
//
(* ****** ****** *)

praxi
lemma_strptr_param
  {l:addr} (x: !strptr l): [l>=null] void
// end of [lemma_strptr_param]

praxi
lemma_strnptr_param
  {l:addr}{n:int}
(
  x: !strnptr (l, n)
) : [(l>null&&n>=0) || (l==null&&n==(~1))] void
// end of [lemma_strnptr_param]

(* ****** ****** *)

praxi
lemma_strbuf_param
  {l:addr}{m,n:int} (x: &strbuf (m, n)): [m>n] void
// end of [lemma_strbuf_param]

praxi
lemma_strbuf_v_param
  {l:addr}{m,n:int} (pf: !strbuf_v (l, m, n)): [l>null;m>n] void
// end of [lemma_strbuf_v_param]

(* ****** ****** *)

castfn
strptr2ptr
  {l:addr} (x: !strptr l):<> ptr (l)
castfn
strnptr2ptr
  {l:addr}{n:int} (x: !strnptr (l, n)):<> ptr (l)
// end of [strnptr2ptr]

(* ****** ****** *)
//
castfn
strnptr2strptr
  {l:addr}{n:int} (x: strnptr (l, n)):<> strptr (l)
// end of [strnptr2strptr]

castfn
strptr2strnptr
  {l:addr} (x: strptr (l)):<> [n:int] strnptr (l, n)
// end of [strptr2strnptr]
//
(* ****** ****** *)
//
castfn
strptr2stropt
  {l:addr}
(
  x: strptr (l)
) :<> [n:int|(l==null&&n < 0)||(l>null&&n>=0)] stropt (n)
castfn
strptr2stropt0 (x: Strptr0):<> Stropt0
castfn
stropt2stropt1 (x: Strptr1):<> Stropt1
//
castfn
strnptr2stropt
  {l:addr}{n:int} (x: strnptr (l, n)):<> stropt (n)
//
(* ****** ****** *)
//
castfn
strptr2string (x: Strptr1):<> String
//
castfn
strnptr2string
  {l:addr}{n:nat} (x: strnptr (l, n)):<> string (n)
//
(* ****** ****** *)

fun strptr_null ():<> strptr (null) = "mac#%"

(* ****** ****** *)

praxi
strptr_free_null
   {l:addr | l <= null} (x: strptr (l)):<> void
// end of [strptr_free_null]

(* ****** ****** *)

fun{}
strptr_is_null
  {l:addr} (x: !strptr l):<> bool (l==null)
fun{}
strptr_isnot_null
  {l:addr} (x: !strptr l):<> bool (l > null)

(* ****** ****** *)

fun{} strptr_is_empty (x: !Strptr1):<> bool
fun{} strptr_isnot_empty (x: !Strptr1):<> bool

(* ****** ****** *)

fun{}
strnptr_is_null
  {l:addr}{n:int} (x: !strnptr (l, n)):<> bool (l==null)
fun{}
strnptr_isnot_null
  {l:addr}{n:int} (x: !strnptr (l, n)):<> bool (l > null)

(* ****** ****** *)

fun lt_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload < with lt_strptr_strptr
fun lte_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload <= with lte_strptr_strptr

fun gt_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload > with gt_strptr_strptr
fun gte_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload >= with gte_strptr_strptr

fun eq_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload = with eq_strptr_strptr
fun neq_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload != with neq_strptr_strptr
overload <> with neq_strptr_strptr

(* ****** ****** *)
//
fun compare_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> Sgn = "mac#%"
//
(* ****** ****** *)

fun eq_strptr_string
  (x1: !Strptr1, x2: string):<> bool = "mac#%"
overload = with eq_strptr_string

fun neq_strptr_string
  (x1: !Strptr1, x2: string):<> bool = "mac#%"
overload != with neq_strptr_string
overload <> with neq_strptr_string

(* ****** ****** *)
//
fun compare_strptr_string
  (x1: !Strptr1, x2: string):<> Sgn = "mac#%"
//
(* ****** ****** *)

fun strptr_free (x: Strptr0):<!wrt> void = "mac#%"
fun strnptr_free (x: Strnptr0):<!wrt> void = "mac#%"

(* ****** ****** *)
//
fun
fprint_strptr
(
  out: FILEref, x: !Strptr0
) : void = "mac#%"
//
fun print_strptr (x: !Strptr0): void = "mac#%"
fun prerr_strptr (x: !Strptr0): void = "mac#%"
//
(* ****** ****** *)
//
fun print_strbuf
  {m,n:int} (buf: &strbuf(m, n)): void = "mac#%"
fun prerr_strbuf
  {m,n:int} (buf: &strbuf(m, n)): void = "mac#%"
//
fun
fprint_strbuf{m,n:int}
  (out: FILEref, buf: &strbuf (m, n)): void = "mac#%"
//
(* ****** ****** *)
//
fun{}
strnptr_get_at_size {n:int}
  (str: !strnptr (n), i: sizeLt n):<> charNZ
//
fun{tk:tk}
strnptr_get_at_gint
  {n:int}{i:nat | i < n}
  (s: !strnptr (n), i: g1int (tk, i)):<> charNZ
fun{tk:tk}
strnptr_get_at_guint
  {n:int}{i:nat | i < n}
  (s: !strnptr (n), i: g1uint (tk, i)):<> charNZ
//
symintr strnptr_get_at
overload strnptr_get_at with strnptr_get_at_size of 1
overload strnptr_get_at with strnptr_get_at_gint of 0
overload strnptr_get_at with strnptr_get_at_guint of 0
//
(* ****** ****** *)
//
fun{}
strnptr_set_at_size {n:int}
  (str: !strnptr (n), i: sizeLt n, c: charNZ):<!wrt> void
//
fun{tk:tk}
strnptr_set_at_gint
  {n:int}{i:nat | i < n}
  (s: !strnptr (n), i: g1int (tk, i), c: charNZ):<!wrt> void
fun{tk:tk}
strnptr_set_at_guint
  {n:int}{i:nat | i < n}
  (s: !strnptr (n), i: g1uint (tk, i), c: charNZ):<!wrt> void
//
symintr strnptr_set_at
overload strnptr_set_at with strnptr_set_at_size of 1
overload strnptr_set_at with strnptr_set_at_gint of 0
overload strnptr_set_at with strnptr_set_at_guint of 0
//
(* ****** ****** *)

fun{}
strptr_length (x: !Strptr0):<> ssize_t
fun{}
strnptr_length {n:int} (x: !strnptr n):<> ssize_t (n)

(* ****** ****** *)
//
fun{
} strptr0_copy (x: !Strptr0):<!wrt> Strptr0
fun{
} strptr1_copy (x: !Strptr1):<!wrt> Strptr1
fun{
} strnptr_copy
  {n:int} (x: !strnptr (n)):<!wrt> strnptr (n)
//
(* ****** ****** *)
//
fun{
} strptr_append (x1: !Strptr0, x2: !Strptr0):<!wrt> Strptr0
fun{
} strnptr_append {n1,n2:nat}
  (x1: !strnptr n1, x2: !strnptr n2):<!wrt> strnptr (n1+n2)
//
(* ****** ****** *)

fun{
} strptrlst_free (xs: List_vt (Strptr0)):<!wrt> void

(* ****** ****** *)

fun{
} strptrlst_concat (xs: List_vt (Strptr0)):<!wrt> Strptr0

(* ****** ****** *)

fun{env:vt0p}
strnptr_foreach$cont (c: &charNZ, env: &env): bool
fun{env:vt0p}
strnptr_foreach$fwork (c: &charNZ >> _, env: &env): void
fun{}
strnptr_foreach {n:nat} (str: !strnptr n): sizeLte(n)
fun{env:vt0p}
strnptr_foreach_env
  {n:nat} (str: !strnptr n, env: &(env) >> _): sizeLte(n)
// end of [strnptr_foreach_env]

(* ****** ****** *)

fun{env:vt0p}
strnptr_rforeach$cont (c: &charNZ, env: &env): bool
fun{env:vt0p}
strnptr_rforeach$fwork (c: &charNZ >> _, env: &env): void
fun{}
strnptr_rforeach {n:nat} (str: !strnptr n): sizeLte(n)
fun{env:vt0p}
strnptr_rforeach_env
  {n:nat} (str: !strnptr n, env: &(env) >> _): sizeLte(n)
// end of [strnptr_rforeach_env]

(* ****** ****** *)
//
// overloading for certain symbols
//
overload
[] with strnptr_get_at_size of 1
overload
[] with strnptr_get_at_gint of 0
overload
[] with strnptr_get_at_guint of 0
//
overload
[] with strnptr_set_at_size of 1
overload
[] with strnptr_set_at_gint of 0
overload
[] with strnptr_set_at_guint of 0
//
overload iseqz with strptr_is_null
overload iseqz with strnptr_is_null
overload isneqz with strptr_isnot_null
overload isneqz with strnptr_isnot_null
//
overload
compare with compare_strptr_strptr
overload
compare with compare_strptr_string
//
overload length with strptr_length
overload length with strnptr_length
//
overload copy with strptr0_copy of 0
overload copy with strptr1_copy of 10
//
overload free with strptr_free
overload free with strnptr_free
//
overload print with print_strptr
overload prerr with prerr_strptr
overload fprint with fprint_strptr
//
overload print with print_strbuf
overload prerr with prerr_strbuf
overload fprint with fprint_strbuf
//
overload ptrcast with strptr2ptr
overload ptrcast with strnptr2ptr
//
(* ****** ****** *)

(* end of [strptr.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/integer_fixed.atxt
** Time of generation: Sat Oct 17 15:19:46 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)

(* ****** ****** *)
//
// HX: for unindexed integer types
//
(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

typedef SHR(a:t@ype) = a // for commenting purpose
typedef NSH(a:t@ype) = a // for commenting purpose

(* ****** ****** *)
//
stadef int8knd = int8_kind
stadef int16knd = int16_kind
stadef int32knd = int32_kind
stadef int64knd = int64_kind
//
stadef uint8knd = uint8_kind
stadef uint16knd = uint16_kind
stadef uint32knd = uint32_kind
stadef uint64knd = uint64_kind
//
(* ****** ****** *)
//
fun g0int2int_int8_int (x: int8):<> int = "mac#%"
fun g0int2int_int16_int (x: int16):<> int = "mac#%"
fun g0int2int_int32_int (x: int32):<> int = "mac#%"
fun g0int2int_int64_int (x: int64):<> int = "mac#%"
//
(* ****** ****** *)
//
fun g0int_neg_int8 (x: int8):<> int8 = "mac#%"
fun g0int_abs_int8 (x: int8):<> int8 = "mac#%"
fun g0int_succ_int8 (x: int8):<> int8 = "mac#%"
fun g0int_pred_int8 (x: int8):<> int8 = "mac#%"
fun g0int_half_int8 (x: int8):<> int8 = "mac#%"
fun g0int_asl_int8 (x: int8, n: intGte(0)):<> int8 = "mac#%"
fun g0int_asr_int8 (x: int8, n: intGte(0)):<> int8 = "mac#%"
fun g0int_add_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_sub_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_mul_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_div_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_mod_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_isltz_int8 (x: int8):<> bool = "mac#%"
fun g0int_isltez_int8 (x: int8):<> bool = "mac#%"
fun g0int_isgtz_int8 (x: int8):<> bool = "mac#%"
fun g0int_isgtez_int8 (x: int8):<> bool = "mac#%"
fun g0int_iseqz_int8 (x: int8):<> bool = "mac#%"
fun g0int_isneqz_int8 (x: int8):<> bool = "mac#%"
fun g0int_lt_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_lte_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_gt_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_gte_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_eq_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_neq_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_compare_int8 (x: int8, y: int8):<> int = "mac#%"
fun g0int_max_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_min_int8 (x: int8, y: int8):<> int8 = "mac#%"
//
fun g0int_neg_int16 (x: int16):<> int16 = "mac#%"
fun g0int_abs_int16 (x: int16):<> int16 = "mac#%"
fun g0int_succ_int16 (x: int16):<> int16 = "mac#%"
fun g0int_pred_int16 (x: int16):<> int16 = "mac#%"
fun g0int_half_int16 (x: int16):<> int16 = "mac#%"
fun g0int_asl_int16 (x: int16, n: intGte(0)):<> int16 = "mac#%"
fun g0int_asr_int16 (x: int16, n: intGte(0)):<> int16 = "mac#%"
fun g0int_add_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_sub_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_mul_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_div_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_mod_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_isltz_int16 (x: int16):<> bool = "mac#%"
fun g0int_isltez_int16 (x: int16):<> bool = "mac#%"
fun g0int_isgtz_int16 (x: int16):<> bool = "mac#%"
fun g0int_isgtez_int16 (x: int16):<> bool = "mac#%"
fun g0int_iseqz_int16 (x: int16):<> bool = "mac#%"
fun g0int_isneqz_int16 (x: int16):<> bool = "mac#%"
fun g0int_lt_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_lte_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_gt_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_gte_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_eq_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_neq_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_compare_int16 (x: int16, y: int16):<> int = "mac#%"
fun g0int_max_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_min_int16 (x: int16, y: int16):<> int16 = "mac#%"
//
fun g0int_neg_int32 (x: int32):<> int32 = "mac#%"
fun g0int_abs_int32 (x: int32):<> int32 = "mac#%"
fun g0int_succ_int32 (x: int32):<> int32 = "mac#%"
fun g0int_pred_int32 (x: int32):<> int32 = "mac#%"
fun g0int_half_int32 (x: int32):<> int32 = "mac#%"
fun g0int_asl_int32 (x: int32, n: intGte(0)):<> int32 = "mac#%"
fun g0int_asr_int32 (x: int32, n: intGte(0)):<> int32 = "mac#%"
fun g0int_add_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_sub_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_mul_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_div_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_mod_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_isltz_int32 (x: int32):<> bool = "mac#%"
fun g0int_isltez_int32 (x: int32):<> bool = "mac#%"
fun g0int_isgtz_int32 (x: int32):<> bool = "mac#%"
fun g0int_isgtez_int32 (x: int32):<> bool = "mac#%"
fun g0int_iseqz_int32 (x: int32):<> bool = "mac#%"
fun g0int_isneqz_int32 (x: int32):<> bool = "mac#%"
fun g0int_lt_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_lte_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_gt_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_gte_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_eq_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_neq_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_compare_int32 (x: int32, y: int32):<> int = "mac#%"
fun g0int_max_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_min_int32 (x: int32, y: int32):<> int32 = "mac#%"
//
fun g0int_neg_int64 (x: int64):<> int64 = "mac#%"
fun g0int_abs_int64 (x: int64):<> int64 = "mac#%"
fun g0int_succ_int64 (x: int64):<> int64 = "mac#%"
fun g0int_pred_int64 (x: int64):<> int64 = "mac#%"
fun g0int_half_int64 (x: int64):<> int64 = "mac#%"
fun g0int_asl_int64 (x: int64, n: intGte(0)):<> int64 = "mac#%"
fun g0int_asr_int64 (x: int64, n: intGte(0)):<> int64 = "mac#%"
fun g0int_add_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_sub_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_mul_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_div_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_mod_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_isltz_int64 (x: int64):<> bool = "mac#%"
fun g0int_isltez_int64 (x: int64):<> bool = "mac#%"
fun g0int_isgtz_int64 (x: int64):<> bool = "mac#%"
fun g0int_isgtez_int64 (x: int64):<> bool = "mac#%"
fun g0int_iseqz_int64 (x: int64):<> bool = "mac#%"
fun g0int_isneqz_int64 (x: int64):<> bool = "mac#%"
fun g0int_lt_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_lte_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_gt_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_gte_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_eq_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_neq_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_compare_int64 (x: int64, y: int64):<> int = "mac#%"
fun g0int_max_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_min_int64 (x: int64, y: int64):<> int64 = "mac#%"
//
(* ****** ****** *)

fun fprint_int8
  : fprint_type (int8) = "mac#%"
overload fprint with fprint_int8
fun print_int8 (x: int8): void = "mac#%"
fun prerr_int8 (x: int8): void = "mac#%"
overload print with print_int8
overload prerr with prerr_int8

fun fprint_int16
  : fprint_type (int16) = "mac#%"
overload fprint with fprint_int16
fun print_int16 (x: int16): void = "mac#%"
fun prerr_int16 (x: int16): void = "mac#%"
overload print with print_int16
overload prerr with prerr_int16

fun fprint_int32
  : fprint_type (int32) = "mac#%"
overload fprint with fprint_int32
fun print_int32 (x: int32): void = "mac#%"
fun prerr_int32 (x: int32): void = "mac#%"
overload print with print_int32
overload prerr with prerr_int32

fun fprint_int64
  : fprint_type (int64) = "mac#%"
overload fprint with fprint_int64
fun print_int64 (x: int64): void = "mac#%"
fun prerr_int64 (x: int64): void = "mac#%"
overload print with print_int64
overload prerr with prerr_int64


(* ****** ****** *)
//
fun g0int2uint_int8_uint (x: int8):<> uint = "mac#%"
fun g0int2uint_int16_uint (x: int16):<> uint = "mac#%"
fun g0int2uint_int32_uint (x: int32):<> uint = "mac#%"
fun g0int2uint_int64_uint (x: int64):<> uint = "mac#%"
//
fun g0uint2int_uint8_int (x: uint8):<> int = "mac#%"
fun g0uint2int_uint16_int (x: uint16):<> int = "mac#%"
fun g0uint2int_uint32_int (x: uint32):<> int = "mac#%"
fun g0uint2int_uint64_int (x: uint64):<> int = "mac#%"
//
fun g0uint2uint_uint8_uint (x: uint8):<> uint = "mac#%"
fun g0uint2uint_uint16_uint (x: uint16):<> uint = "mac#%"
fun g0uint2uint_uint32_uint (x: uint32):<> uint = "mac#%"
fun g0uint2uint_uint64_uint (x: uint64):<> uint = "mac#%"
//
(* ****** ****** *)
//
fun g0uint_succ_uint8 (x: uint8):<> uint8 = "mac#%"
fun g0uint_pred_uint8 (x: uint8):<> uint8 = "mac#%"
fun g0uint_half_uint8 (x: uint8):<> uint8 = "mac#%"
fun g0uint_add_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_sub_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_mul_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_div_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_mod_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_lsl_uint8 (x: uint8, n: intGte(0)):<> uint8 = "mac#%"
fun g0uint_lsr_uint8 (x: uint8, n: intGte(0)):<> uint8 = "mac#%"
fun g0uint_lnot_uint8 (x: uint8):<> uint8 = "mac#%"
fun g0uint_lor_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_lxor_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_land_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_isgtz_uint8 (x: uint8):<> bool = "mac#%"
fun g0uint_iseqz_uint8 (x: uint8):<> bool = "mac#%"
fun g0uint_isneqz_uint8 (x: uint8):<> bool = "mac#%"
fun g0uint_lt_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_lte_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_gt_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_gte_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_eq_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_neq_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_compare_uint8 (x: uint8, y: uint8):<> int = "mac#%"
fun g0uint_max_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_min_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
//
fun g0uint_succ_uint16 (x: uint16):<> uint16 = "mac#%"
fun g0uint_pred_uint16 (x: uint16):<> uint16 = "mac#%"
fun g0uint_half_uint16 (x: uint16):<> uint16 = "mac#%"
fun g0uint_add_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_sub_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_mul_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_div_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_mod_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_lsl_uint16 (x: uint16, n: intGte(0)):<> uint16 = "mac#%"
fun g0uint_lsr_uint16 (x: uint16, n: intGte(0)):<> uint16 = "mac#%"
fun g0uint_lnot_uint16 (x: uint16):<> uint16 = "mac#%"
fun g0uint_lor_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_lxor_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_land_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_isgtz_uint16 (x: uint16):<> bool = "mac#%"
fun g0uint_iseqz_uint16 (x: uint16):<> bool = "mac#%"
fun g0uint_isneqz_uint16 (x: uint16):<> bool = "mac#%"
fun g0uint_lt_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_lte_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_gt_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_gte_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_eq_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_neq_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_compare_uint16 (x: uint16, y: uint16):<> int = "mac#%"
fun g0uint_max_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_min_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
//
fun g0uint_succ_uint32 (x: uint32):<> uint32 = "mac#%"
fun g0uint_pred_uint32 (x: uint32):<> uint32 = "mac#%"
fun g0uint_half_uint32 (x: uint32):<> uint32 = "mac#%"
fun g0uint_add_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_sub_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_mul_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_div_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_mod_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_lsl_uint32 (x: uint32, n: intGte(0)):<> uint32 = "mac#%"
fun g0uint_lsr_uint32 (x: uint32, n: intGte(0)):<> uint32 = "mac#%"
fun g0uint_lnot_uint32 (x: uint32):<> uint32 = "mac#%"
fun g0uint_lor_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_lxor_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_land_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_isgtz_uint32 (x: uint32):<> bool = "mac#%"
fun g0uint_iseqz_uint32 (x: uint32):<> bool = "mac#%"
fun g0uint_isneqz_uint32 (x: uint32):<> bool = "mac#%"
fun g0uint_lt_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_lte_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_gt_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_gte_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_eq_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_neq_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_compare_uint32 (x: uint32, y: uint32):<> int = "mac#%"
fun g0uint_max_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_min_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
//
fun g0uint_succ_uint64 (x: uint64):<> uint64 = "mac#%"
fun g0uint_pred_uint64 (x: uint64):<> uint64 = "mac#%"
fun g0uint_half_uint64 (x: uint64):<> uint64 = "mac#%"
fun g0uint_add_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_sub_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_mul_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_div_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_mod_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_lsl_uint64 (x: uint64, n: intGte(0)):<> uint64 = "mac#%"
fun g0uint_lsr_uint64 (x: uint64, n: intGte(0)):<> uint64 = "mac#%"
fun g0uint_lnot_uint64 (x: uint64):<> uint64 = "mac#%"
fun g0uint_lor_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_lxor_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_land_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_isgtz_uint64 (x: uint64):<> bool = "mac#%"
fun g0uint_iseqz_uint64 (x: uint64):<> bool = "mac#%"
fun g0uint_isneqz_uint64 (x: uint64):<> bool = "mac#%"
fun g0uint_lt_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_lte_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_gt_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_gte_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_eq_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_neq_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_compare_uint64 (x: uint64, y: uint64):<> int = "mac#%"
fun g0uint_max_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_min_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
//
(* ****** ****** *)

fun fprint_uint8
  : fprint_type (uint8) = "mac#%"
overload fprint with fprint_uint8
fun print_uint8 (x: uint8): void = "mac#%"
fun prerr_uint8 (x: uint8): void = "mac#%"
overload print with print_uint8
overload prerr with prerr_uint8

fun fprint_uint16
  : fprint_type (uint16) = "mac#%"
overload fprint with fprint_uint16
fun print_uint16 (x: uint16): void = "mac#%"
fun prerr_uint16 (x: uint16): void = "mac#%"
overload print with print_uint16
overload prerr with prerr_uint16

fun fprint_uint32
  : fprint_type (uint32) = "mac#%"
overload fprint with fprint_uint32
fun print_uint32 (x: uint32): void = "mac#%"
fun prerr_uint32 (x: uint32): void = "mac#%"
overload print with print_uint32
overload prerr with prerr_uint32

fun fprint_uint64
  : fprint_type (uint64) = "mac#%"
overload fprint with fprint_uint64
fun print_uint64 (x: uint64): void = "mac#%"
fun prerr_uint64 (x: uint64): void = "mac#%"
overload print with print_uint64
overload prerr with prerr_uint64


(* ****** ****** *)
//
fun g1int_neg_int8 : g1int_neg_type (int8knd) = "mac#%"
fun g1int_abs_int8 : g1int_abs_type (int8knd) = "mac#%"
fun g1int_succ_int8 : g1int_succ_type (int8knd) = "mac#%"
fun g1int_pred_int8 : g1int_pred_type (int8knd) = "mac#%"
fun g1int_half_int8 : g1int_half_type (int8knd) = "mac#%"
fun g1int_add_int8 : g1int_add_type (int8knd) = "mac#%"
fun g1int_sub_int8 : g1int_sub_type (int8knd) = "mac#%"
fun g1int_mul_int8 : g1int_mul_type (int8knd) = "mac#%"
fun g1int_div_int8 : g1int_div_type (int8knd) = "mac#%"
fun g1int_nmod_int8 : g1int_nmod_type (int8knd) = "mac#%"
fun g1int_isltz_int8 : g1int_isltz_type (int8knd) = "mac#%"
fun g1int_isltez_int8 : g1int_isltez_type (int8knd) = "mac#%"
fun g1int_isgtz_int8 : g1int_isgtz_type (int8knd) = "mac#%"
fun g1int_isgtez_int8 : g1int_isgtez_type (int8knd) = "mac#%"
fun g1int_iseqz_int8 : g1int_iseqz_type (int8knd) = "mac#%"
fun g1int_isneqz_int8 : g1int_isneqz_type (int8knd) = "mac#%"
fun g1int_lt_int8 : g1int_lt_type (int8knd) = "mac#%"
fun g1int_lte_int8 : g1int_lte_type (int8knd) = "mac#%"
fun g1int_gt_int8 : g1int_gt_type (int8knd) = "mac#%"
fun g1int_gte_int8 : g1int_gte_type (int8knd) = "mac#%"
fun g1int_eq_int8 : g1int_eq_type (int8knd) = "mac#%"
fun g1int_neq_int8 : g1int_neq_type (int8knd) = "mac#%"
fun g1int_compare_int8 : g1int_compare_type (int8knd) = "mac#%"
fun g1int_max_int8 : g1int_max_type (int8knd) = "mac#%"
fun g1int_min_int8 : g1int_min_type (int8knd) = "mac#%"
//
fun g1int_neg_int16 : g1int_neg_type (int16knd) = "mac#%"
fun g1int_abs_int16 : g1int_abs_type (int16knd) = "mac#%"
fun g1int_succ_int16 : g1int_succ_type (int16knd) = "mac#%"
fun g1int_pred_int16 : g1int_pred_type (int16knd) = "mac#%"
fun g1int_half_int16 : g1int_half_type (int16knd) = "mac#%"
fun g1int_add_int16 : g1int_add_type (int16knd) = "mac#%"
fun g1int_sub_int16 : g1int_sub_type (int16knd) = "mac#%"
fun g1int_mul_int16 : g1int_mul_type (int16knd) = "mac#%"
fun g1int_div_int16 : g1int_div_type (int16knd) = "mac#%"
fun g1int_nmod_int16 : g1int_nmod_type (int16knd) = "mac#%"
fun g1int_isltz_int16 : g1int_isltz_type (int16knd) = "mac#%"
fun g1int_isltez_int16 : g1int_isltez_type (int16knd) = "mac#%"
fun g1int_isgtz_int16 : g1int_isgtz_type (int16knd) = "mac#%"
fun g1int_isgtez_int16 : g1int_isgtez_type (int16knd) = "mac#%"
fun g1int_iseqz_int16 : g1int_iseqz_type (int16knd) = "mac#%"
fun g1int_isneqz_int16 : g1int_isneqz_type (int16knd) = "mac#%"
fun g1int_lt_int16 : g1int_lt_type (int16knd) = "mac#%"
fun g1int_lte_int16 : g1int_lte_type (int16knd) = "mac#%"
fun g1int_gt_int16 : g1int_gt_type (int16knd) = "mac#%"
fun g1int_gte_int16 : g1int_gte_type (int16knd) = "mac#%"
fun g1int_eq_int16 : g1int_eq_type (int16knd) = "mac#%"
fun g1int_neq_int16 : g1int_neq_type (int16knd) = "mac#%"
fun g1int_compare_int16 : g1int_compare_type (int16knd) = "mac#%"
fun g1int_max_int16 : g1int_max_type (int16knd) = "mac#%"
fun g1int_min_int16 : g1int_min_type (int16knd) = "mac#%"
//
fun g1int_neg_int32 : g1int_neg_type (int32knd) = "mac#%"
fun g1int_abs_int32 : g1int_abs_type (int32knd) = "mac#%"
fun g1int_succ_int32 : g1int_succ_type (int32knd) = "mac#%"
fun g1int_pred_int32 : g1int_pred_type (int32knd) = "mac#%"
fun g1int_half_int32 : g1int_half_type (int32knd) = "mac#%"
fun g1int_add_int32 : g1int_add_type (int32knd) = "mac#%"
fun g1int_sub_int32 : g1int_sub_type (int32knd) = "mac#%"
fun g1int_mul_int32 : g1int_mul_type (int32knd) = "mac#%"
fun g1int_div_int32 : g1int_div_type (int32knd) = "mac#%"
fun g1int_nmod_int32 : g1int_nmod_type (int32knd) = "mac#%"
fun g1int_isltz_int32 : g1int_isltz_type (int32knd) = "mac#%"
fun g1int_isltez_int32 : g1int_isltez_type (int32knd) = "mac#%"
fun g1int_isgtz_int32 : g1int_isgtz_type (int32knd) = "mac#%"
fun g1int_isgtez_int32 : g1int_isgtez_type (int32knd) = "mac#%"
fun g1int_iseqz_int32 : g1int_iseqz_type (int32knd) = "mac#%"
fun g1int_isneqz_int32 : g1int_isneqz_type (int32knd) = "mac#%"
fun g1int_lt_int32 : g1int_lt_type (int32knd) = "mac#%"
fun g1int_lte_int32 : g1int_lte_type (int32knd) = "mac#%"
fun g1int_gt_int32 : g1int_gt_type (int32knd) = "mac#%"
fun g1int_gte_int32 : g1int_gte_type (int32knd) = "mac#%"
fun g1int_eq_int32 : g1int_eq_type (int32knd) = "mac#%"
fun g1int_neq_int32 : g1int_neq_type (int32knd) = "mac#%"
fun g1int_compare_int32 : g1int_compare_type (int32knd) = "mac#%"
fun g1int_max_int32 : g1int_max_type (int32knd) = "mac#%"
fun g1int_min_int32 : g1int_min_type (int32knd) = "mac#%"
//
fun g1int_neg_int64 : g1int_neg_type (int64knd) = "mac#%"
fun g1int_abs_int64 : g1int_abs_type (int64knd) = "mac#%"
fun g1int_succ_int64 : g1int_succ_type (int64knd) = "mac#%"
fun g1int_pred_int64 : g1int_pred_type (int64knd) = "mac#%"
fun g1int_half_int64 : g1int_half_type (int64knd) = "mac#%"
fun g1int_add_int64 : g1int_add_type (int64knd) = "mac#%"
fun g1int_sub_int64 : g1int_sub_type (int64knd) = "mac#%"
fun g1int_mul_int64 : g1int_mul_type (int64knd) = "mac#%"
fun g1int_div_int64 : g1int_div_type (int64knd) = "mac#%"
fun g1int_nmod_int64 : g1int_nmod_type (int64knd) = "mac#%"
fun g1int_isltz_int64 : g1int_isltz_type (int64knd) = "mac#%"
fun g1int_isltez_int64 : g1int_isltez_type (int64knd) = "mac#%"
fun g1int_isgtz_int64 : g1int_isgtz_type (int64knd) = "mac#%"
fun g1int_isgtez_int64 : g1int_isgtez_type (int64knd) = "mac#%"
fun g1int_iseqz_int64 : g1int_iseqz_type (int64knd) = "mac#%"
fun g1int_isneqz_int64 : g1int_isneqz_type (int64knd) = "mac#%"
fun g1int_lt_int64 : g1int_lt_type (int64knd) = "mac#%"
fun g1int_lte_int64 : g1int_lte_type (int64knd) = "mac#%"
fun g1int_gt_int64 : g1int_gt_type (int64knd) = "mac#%"
fun g1int_gte_int64 : g1int_gte_type (int64knd) = "mac#%"
fun g1int_eq_int64 : g1int_eq_type (int64knd) = "mac#%"
fun g1int_neq_int64 : g1int_neq_type (int64knd) = "mac#%"
fun g1int_compare_int64 : g1int_compare_type (int64knd) = "mac#%"
fun g1int_max_int64 : g1int_max_type (int64knd) = "mac#%"
fun g1int_min_int64 : g1int_min_type (int64knd) = "mac#%"
//
(* ****** ****** *)
//
fun g1uint_succ_uint8 : g1uint_succ_type (uint8knd) = "mac#%"
fun g1uint_pred_uint8 : g1uint_pred_type (uint8knd) = "mac#%"
fun g1uint_half_uint8 : g1uint_half_type (uint8knd) = "mac#%"
fun g1uint_add_uint8 : g1uint_add_type (uint8knd) = "mac#%"
fun g1uint_sub_uint8 : g1uint_sub_type (uint8knd) = "mac#%"
fun g1uint_mul_uint8 : g1uint_mul_type (uint8knd) = "mac#%"
fun g1uint_div_uint8 : g1uint_div_type (uint8knd) = "mac#%"
fun g1uint_mod_uint8 : g1uint_mod_type (uint8knd) = "mac#%"
fun g1uint_isgtz_uint8 : g1uint_isgtz_type (uint8knd) = "mac#%"
fun g1uint_iseqz_uint8 : g1uint_iseqz_type (uint8knd) = "mac#%"
fun g1uint_isneqz_uint8 : g1uint_isneqz_type (uint8knd) = "mac#%"
fun g1uint_lt_uint8 : g1uint_lt_type (uint8knd) = "mac#%"
fun g1uint_lte_uint8 : g1uint_lte_type (uint8knd) = "mac#%"
fun g1uint_gt_uint8 : g1uint_gt_type (uint8knd) = "mac#%"
fun g1uint_gte_uint8 : g1uint_gte_type (uint8knd) = "mac#%"
fun g1uint_eq_uint8 : g1uint_eq_type (uint8knd) = "mac#%"
fun g1uint_neq_uint8 : g1uint_neq_type (uint8knd) = "mac#%"
fun g1uint_compare_uint8 : g1uint_compare_type (uint8knd) = "mac#%"
fun g1uint_max_uint8 : g1uint_max_type (uint8knd) = "mac#%"
fun g1uint_min_uint8 : g1uint_min_type (uint8knd) = "mac#%"
//
fun g1uint_succ_uint16 : g1uint_succ_type (uint16knd) = "mac#%"
fun g1uint_pred_uint16 : g1uint_pred_type (uint16knd) = "mac#%"
fun g1uint_half_uint16 : g1uint_half_type (uint16knd) = "mac#%"
fun g1uint_add_uint16 : g1uint_add_type (uint16knd) = "mac#%"
fun g1uint_sub_uint16 : g1uint_sub_type (uint16knd) = "mac#%"
fun g1uint_mul_uint16 : g1uint_mul_type (uint16knd) = "mac#%"
fun g1uint_div_uint16 : g1uint_div_type (uint16knd) = "mac#%"
fun g1uint_mod_uint16 : g1uint_mod_type (uint16knd) = "mac#%"
fun g1uint_isgtz_uint16 : g1uint_isgtz_type (uint16knd) = "mac#%"
fun g1uint_iseqz_uint16 : g1uint_iseqz_type (uint16knd) = "mac#%"
fun g1uint_isneqz_uint16 : g1uint_isneqz_type (uint16knd) = "mac#%"
fun g1uint_lt_uint16 : g1uint_lt_type (uint16knd) = "mac#%"
fun g1uint_lte_uint16 : g1uint_lte_type (uint16knd) = "mac#%"
fun g1uint_gt_uint16 : g1uint_gt_type (uint16knd) = "mac#%"
fun g1uint_gte_uint16 : g1uint_gte_type (uint16knd) = "mac#%"
fun g1uint_eq_uint16 : g1uint_eq_type (uint16knd) = "mac#%"
fun g1uint_neq_uint16 : g1uint_neq_type (uint16knd) = "mac#%"
fun g1uint_compare_uint16 : g1uint_compare_type (uint16knd) = "mac#%"
fun g1uint_max_uint16 : g1uint_max_type (uint16knd) = "mac#%"
fun g1uint_min_uint16 : g1uint_min_type (uint16knd) = "mac#%"
//
fun g1uint_succ_uint32 : g1uint_succ_type (uint32knd) = "mac#%"
fun g1uint_pred_uint32 : g1uint_pred_type (uint32knd) = "mac#%"
fun g1uint_half_uint32 : g1uint_half_type (uint32knd) = "mac#%"
fun g1uint_add_uint32 : g1uint_add_type (uint32knd) = "mac#%"
fun g1uint_sub_uint32 : g1uint_sub_type (uint32knd) = "mac#%"
fun g1uint_mul_uint32 : g1uint_mul_type (uint32knd) = "mac#%"
fun g1uint_div_uint32 : g1uint_div_type (uint32knd) = "mac#%"
fun g1uint_mod_uint32 : g1uint_mod_type (uint32knd) = "mac#%"
fun g1uint_isgtz_uint32 : g1uint_isgtz_type (uint32knd) = "mac#%"
fun g1uint_iseqz_uint32 : g1uint_iseqz_type (uint32knd) = "mac#%"
fun g1uint_isneqz_uint32 : g1uint_isneqz_type (uint32knd) = "mac#%"
fun g1uint_lt_uint32 : g1uint_lt_type (uint32knd) = "mac#%"
fun g1uint_lte_uint32 : g1uint_lte_type (uint32knd) = "mac#%"
fun g1uint_gt_uint32 : g1uint_gt_type (uint32knd) = "mac#%"
fun g1uint_gte_uint32 : g1uint_gte_type (uint32knd) = "mac#%"
fun g1uint_eq_uint32 : g1uint_eq_type (uint32knd) = "mac#%"
fun g1uint_neq_uint32 : g1uint_neq_type (uint32knd) = "mac#%"
fun g1uint_compare_uint32 : g1uint_compare_type (uint32knd) = "mac#%"
fun g1uint_max_uint32 : g1uint_max_type (uint32knd) = "mac#%"
fun g1uint_min_uint32 : g1uint_min_type (uint32knd) = "mac#%"
//
fun g1uint_succ_uint64 : g1uint_succ_type (uint64knd) = "mac#%"
fun g1uint_pred_uint64 : g1uint_pred_type (uint64knd) = "mac#%"
fun g1uint_half_uint64 : g1uint_half_type (uint64knd) = "mac#%"
fun g1uint_add_uint64 : g1uint_add_type (uint64knd) = "mac#%"
fun g1uint_sub_uint64 : g1uint_sub_type (uint64knd) = "mac#%"
fun g1uint_mul_uint64 : g1uint_mul_type (uint64knd) = "mac#%"
fun g1uint_div_uint64 : g1uint_div_type (uint64knd) = "mac#%"
fun g1uint_mod_uint64 : g1uint_mod_type (uint64knd) = "mac#%"
fun g1uint_isgtz_uint64 : g1uint_isgtz_type (uint64knd) = "mac#%"
fun g1uint_iseqz_uint64 : g1uint_iseqz_type (uint64knd) = "mac#%"
fun g1uint_isneqz_uint64 : g1uint_isneqz_type (uint64knd) = "mac#%"
fun g1uint_lt_uint64 : g1uint_lt_type (uint64knd) = "mac#%"
fun g1uint_lte_uint64 : g1uint_lte_type (uint64knd) = "mac#%"
fun g1uint_gt_uint64 : g1uint_gt_type (uint64knd) = "mac#%"
fun g1uint_gte_uint64 : g1uint_gte_type (uint64knd) = "mac#%"
fun g1uint_eq_uint64 : g1uint_eq_type (uint64knd) = "mac#%"
fun g1uint_neq_uint64 : g1uint_neq_type (uint64knd) = "mac#%"
fun g1uint_compare_uint64 : g1uint_compare_type (uint64knd) = "mac#%"
fun g1uint_max_uint64 : g1uint_max_type (uint64knd) = "mac#%"
fun g1uint_min_uint64 : g1uint_min_type (uint64knd) = "mac#%"
//
(* ****** ****** *)

(* end of [integer_fixed.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/extern.atxt
** Time of generation: Sat Oct 17 15:19:51 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2012 *)

(* ****** ****** *)

sortdef vt0p = viewt@ype

(* ****** ****** *)

abstype
carrayptr (a:t@ype, l:addr, n:int) = ptr(l)
typedef
carrayptr0 (a:t@ype, n:int) = [l:addr] carrayptr (a, l, n)
typedef
carrayptr1 (a:t@ype, n:int) = [l:addr | l > null] carrayptr (a, l, n)

(* ****** ****** *)
//
// HX-2014-01-30: these are inherently unsafe:
//
castfn
carrayptr_null
  {a:t@ype}{n:nat} (p: ptr(null)):<> carrayptr (a, null, n)
castfn
carrayptr_array
  {a:t@ype}{n:int} (A: &array(INV(a), n)):<> carrayptr1 (a, n)
castfn
carrayptr_arrayref
  {a:t@ype}{n:int} (A: arrayref(INV(a), n)):<> carrayptr1 (a, n)
castfn
carrayptr_arrayptr
  {a:t@ype}{l:addr}{n:int}
  (A: !arrayptr(INV(a), l, n)):<> [l > null] carrayptr (a, l, n)
//
(* ****** ****** *)

symintr carrayptr
overload carrayptr with carrayptr_null
overload carrayptr with carrayptr_array
overload carrayptr with carrayptr_arrayref
overload carrayptr with carrayptr_arrayptr

(* ****** ****** *)
//
// HX: note that (vt1 \minus v2) roughly means that a ticket of
// [v2] is taken from [vt1]; the ticket must be returned before
// [vt1] is consumed. However, the ticket should not be issued
// repeatedly for otherwise safety may be potentially compromised.
//
absview
minus_viewt0ype_view_view (vt1: vt0p, v2: view) = vt1
viewdef
minus(vt1: vt0p, v2: view) = minus_viewt0ype_view_view(vt1, v2)
//
praxi minus_addback
  {vt1:vt0p}{v2:view} (pf1: minus (vt1, v2), pf2: v2 | x: !vt1): void
//
(* ****** ****** *)

vtypedef vtget0 (vt1:vt0p, vt2: vt0p) = (minus (vt1, vt2) | vt2)

(* ****** ****** *)

castfn
argv_takeout_strarr
  {n:int} (
  argv: !argv (n)
) :<> [l:addr] (
  array_v (string, l, n), minus (argv n, array_v (string, l, n)) | ptr l
) // end of [argv_takeout_strarr]

castfn
argv_takeout_parray
  {n:int} (
  argv: !argv (n)
) :<> [l:addr] (
  parray_v (string, l, n), minus (argv n, parray_v (string, l, n)) | ptr l
) // end of [argv_takeout_parray]

(* ****** ****** *)

(* end of [extern.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/filebas.atxt
** Time of generation: Sun Oct 18 14:27:08 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

val stdin_ref : FILEref = "mac#%FILE_stdin"
val stdout_ref : FILEref = "mac#%FILE_stdout"
val stderr_ref : FILEref = "mac#%FILE_stderr"

(* ****** ****** *)

fun{} dirsep_get ():<> charNZ
fun{} dirname_self ():<> string
fun{} dirname_parent ():<> string

(* ****** ****** *)

fun{}
filename_get_ext (name: string):<> vStrptr0
fun{}
filename_test_ext (name: string, ext: string):<> bool

(* ****** ****** *)

fun{}
filename_get_base (name: string):<> vStrptr1
fun{}
filename_test_base (name: string, base: string):<> bool

(* ****** ****** *)
//
val file_mode_r
  : file_mode (file_mode_r()) = "mac#%" // = "r"
val file_mode_rr
  : file_mode (file_mode_rw()) = "mac#%" // = "r+"
//
val file_mode_w
  : file_mode (file_mode_w()) = "mac#%" // = "w"
val file_mode_ww
  : file_mode (file_mode_rw()) = "mac#%" // = "w+"
//
val file_mode_a
  : file_mode (file_mode_rw()) = "mac#%" // = "a"
val file_mode_aa
  : file_mode (file_mode_rw()) = "mac#%" // = "a+"
//
(* ****** ****** *)
//
(*
** HX: [stat] is called
*)
fun
test_file_exists (path: NSH(string)): bool = "mac#%"
//
(* ****** ****** *)
//
// HX-2011-02-16:
// [stat] is called to obtain the mode of a given file
// for [f] to be applied to it.
//
fun{}
test_file_mode (path: NSH(string)): int
//
fun{} test_file_mode$pred (mode: uint): bool
//
fun test_file_mode_fun
  (path: NSH(string), f: uint -> bool): int = "mac#%"
//
// HX: [stat] is called // ~1/0/1: error/false/true
//
fun test_file_isblk (path: NSH(string)): int = "mac#%"
fun test_file_ischr (path: NSH(string)): int = "mac#%"
fun test_file_isdir (path: NSH(string)): int = "mac#%"
fun test_file_isfifo (path: NSH(string)): int = "mac#%"
fun test_file_isreg (path: NSH(string)): int = "mac#%"
//
// HX: [lstat] is called // ~1/0/1: error/false/true
//
fun test_file_islnk (path: NSH(string)): int = "mac#%"
//
(* ****** ****** *)

fun
fileref_open_exn
  (path: NSH(string), fm: file_mode): FILEref = "mac#%"
// end of [fileref_open_exn]

fun{}
fileref_open_opt
  (path: NSH(string), fm: file_mode): Option_vt (FILEref)
// end of [fileref_open_opt]

(* ****** ****** *)

fun fileref_close (fil: FILEref): void = "mac#%"

(* ****** ****** *)

fun fileref_flush (fil: FILEref): void = "mac#%"

(* ****** ****** *)
//
// HX: error indication: EOF
//
fun fileref_getc (inp: FILEref): int = "mac#%"
//
(* ****** ****** *)
//
// HX: no error reporting
//
symintr fileref_putc
//
fun fileref_putc_int
  (out: FILEref, c: int): void = "mac#%"
overload fileref_putc with fileref_putc_int
fun fileref_putc_char
  (out: FILEref, c: char): void = "mac#%"
overload fileref_putc with fileref_putc_char
//
(* ****** ****** *)
//
// HX: no error reporting
//
fun fileref_puts
  (out: FILEref, s: NSH(string)): void = "mac#%"
//
(* ****** ****** *)
//
fun fileref_is_eof (fil: FILEref): bool = "mac#%"
//
macdef
fileref_isnot_eof (inp) = ~fileref_is_eof (,(inp))
//
(* ****** ****** *)

typedef
fileref_load_type (a:t@ype) =
  (FILEref, &a? >> opt (a, b)) -<fun1> #[b:bool] bool (b)
// end of [fileref_load_type]

fun{a:t0p}
fileref_load : fileref_load_type (a)

fun fileref_load_int : fileref_load_type (int) = "mac#%"
fun fileref_load_lint : fileref_load_type (lint) = "mac#%"
fun fileref_load_uint : fileref_load_type (uint) = "mac#%"
fun fileref_load_ulint : fileref_load_type (ulint) = "mac#%"

fun fileref_load_float : fileref_load_type (float) = "mac#%"
fun fileref_load_double : fileref_load_type (double) = "mac#%"

(* ****** ****** *)

fun{a:t0p}
fileref_get_optval
  (inp: FILEref): Option_vt (a)
// end of [fileref_get_optval]

fun{
a:t0p
} fileref_get_exnmsg
  (inp: FILEref, msg: NSH(string)): a
// end of [fileref_get_exnmsg]

macdef
fileref_get_exnloc
  (inp) = fileref_get_exnmsg (,(inp), $mylocation)
// end of [fileref_get_exnloc]

(* ****** ****** *)

typedef charlst = List0 (char)
vtypedef charlst_vt = List0_vt (char)

(* ****** ****** *)
//
fun
fileref_get_line_charlst (inp: FILEref): charlst_vt
//
(* ****** ****** *)
//
(*
** HX: only for files of "tiny" size
*)
fun
fileref_get_lines_charlstlst (inp: FILEref): List0_vt (charlst_vt)
//
(* ****** ****** *)
//
(*
** HX: for handling files of "tiny" size
*)
fun
fileref_get_file_charlst (inp: FILEref): List0_vt (char)
fun
fileref_get2_file_charlst (inp: FILEref, n: int): List0_vt (char)
//
(* ****** ****** *)
//
fun
fileref_put_charlst (inp: FILEref, cs: NSH(List(char))): void
//
(* ****** ****** *)
//
//
// HX-2013-05:
// these functions are based on [fgets];
// they should only be applied to files containing
// no occurrences of the NUL character ('\000').
//
fun{}
fileref_get_line_string (inp: FILEref): Strptr1
//
fun{}
fileref_get_line_string_main
  (inp: FILEref, n: &int? >> int n): #[n:nat] strnptr (n)
fun{}
fileref_get_line_string$bufsize ((*void*)): intGte(1)
//
fun{}
fileref_get_lines_stringlst (inp: FILEref): List0_vt (Strptr1)
//
(* ****** ****** *)
//
fun{}
fileref_get_file_string (inp: FILEref): Strptr1
fun{}
fileref_get_file_string$bufsize ((*void*)): intGte(1)
//
(* ****** ****** *)
//
fun{}
fileref_get_word (inp: FILEref): Strptr0
fun{}
fileref_get_word$isalpha (c: charNZ): bool
//
(* ****** ****** *)
//
fun{}
fileref_foreach (inp: FILEref): void
fun{
env:vt0p
} fileref_foreach_env (inp: FILEref, env: &(env) >> _): void
//
fun{}
fileref_foreach$bufsize (): sizeGte(1)
fun{
env:vt0p
} fileref_foreach$fwork (c: char, env: &(env) >> _): void
fun{
env:vt0p
} fileref_foreach$fworkv
  {n:int} (arrayref(char, n), size_t(n), &(env) >> _): void
//
(* ****** ****** *)

(* end of [filebas.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/parray.atxt
** Time of generation: Sat Oct 17 15:19:51 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

sortdef vtp = viewtype

(* ****** ****** *)

(*
** HX: for null-pointer terminated arrays
*)

dataview
parray_v (
  a:viewt@ype+, addr(*l*), int(*n*)
) = // for arrays with a sentinel at the end
  | {l:addr}{n:int}
    parray_v_cons (a, l, n+1) of (a @ l, parray_v (a, l+sizeof(a), n))
  | {l:addr} parray_v_nil (a, l, 0) of (ptr null @ l)
// end of [parray_v]

(* ****** ****** *)

prfun
lemma_parray_v_params{a:vtp}
  {l:addr}{n:int} (pf: !parray_v (INV(a), l, n)): [l > null;n >= 0] void
// end of [lemma_parray_v_params]

(* ****** ****** *)

fun{
a:vtp
} parray_is_empty
  {l:addr}{n:int} (
  pf: !parray_v (INV(a), l, n) | p: ptr l
) :<> bool (n == 0) // end of [parray_is_empty]

fun{
a:vtp
} parray_isnot_empty
  {l:addr}{n:int}
  (pf: !parray_v (INV(a), l, n) | p: ptr l):<> bool (n > 0)
// end of [parray_isnot_empty]

(* ****** ****** *)

fun{
a:vtp
} parray_size
  {l:addr}{n:int}
  (pf: !parray_v (INV(a), l, n) | p: ptr l):<> size_t (n)
// end of [parray_size]

(* ****** ****** *)

(* end of [parray.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/checkast.atxt
** Time of generation: Sat Oct 17 15:19:46 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: December, 2013 *)

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.prelude.checkast"

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

fun{tk:tk}
checkast_gintLt{i:int}
  (x: g0int(tk), i: int i, msg: RD(string)): g1intLt(tk, i)
fun{tk:tk}
checkast_gintLte{i:int}
  (x: g0int(tk), i: int i, msg: RD(string)): g1intLte(tk, i)
fun{tk:tk}
checkast_gintGt{i:int}
  (x: g0int(tk), i: int i, msg: RD(string)): g1intGt(tk, i)
fun{tk:tk}
checkast_gintGte{i:int}
  (x: g0int(tk), i: int i, msg: RD(string)): g1intGte(tk, i)
fun{tk:tk}
checkast_gintBtw{i,j:int}
  (x: g0int(tk), i: int i, j: int j, msg: RD(string)): g1intBtw(tk, i, j)
fun{tk:tk}
checkast_gintBtwe{i,j:int}
  (x: g0int(tk), i: int i, j: int j, msg: RD(string)): g1intBtwe(tk, i, j)

(* ****** ****** *)

macdef
ckastloc_gintLt (x, i) = checkast_gintLt (,(x), ,(i), $mylocation)
macdef
ckastloc_gintLte (x, i) = checkast_gintLte (,(x), ,(i), $mylocation)
macdef
ckastloc_gintGt (x, i) = checkast_gintGt (,(x), ,(i), $mylocation)
macdef
ckastloc_gintGte (x, i) = checkast_gintGte (,(x), ,(i), $mylocation)
macdef
ckastloc_gintBtw (x, i, j) = checkast_gintBtw (,(x), ,(i), ,(j), $mylocation)
macdef
ckastloc_gintBtwe (x, i, j) = checkast_gintBtwe (,(x), ,(i), ,(j), $mylocation)

(* ****** ****** *)

fun{}
checkast_Ptr1 (x: ptr, msg: RD(string)): Ptr1

(* ****** ****** *)

macdef
ckastloc_Ptr1 (x) = checkast_Ptr1 (,(x), $mylocation)

(* ****** ****** *)

fun{}
checkast_Strptr1 (x: Strptr0, msg: RD(string)): Strptr1

(* ****** ****** *)

macdef
ckastloc_Strptr1 (x) = checkast_Strptr1 (,(x), $mylocation)

(* ****** ****** *)

(* end of [checkast.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/array_prf.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

prfun
array_v_split
  {a:vt0p}
  {l:addr}
  {n:int}{i:nat | i <= n}
(
  pfarr: array_v (INV(a), l, n)
) :<prf> @(
  array_v (a, l, i), array_v (a, l+i*sizeof(a), n-i)
) // end of [array_v_split]

prfun
array_v_split_at
  {a:vt0p}
  {l:addr}
  {n:int}{i:nat | i <= n}
(
  pfarr: array_v (INV(a), l, n) | i: size_t (i)
) :<prf> @(
  array_v (a, l, i), array_v (a, l+i*sizeof(a), n-i)
) // end of [array_v_split_at]

prfun
array_v_unsplit
  {a:vt0p}
  {l:addr}
  {n1,n2:int}
(
  pf1arr: array_v (INV(a), l, n1)
, pf2arr: array_v (a, l+n1*sizeof(a), n2)
) :<prf> array_v (a, l, n1+n2) // end of [array_v_unsplit]

(* ****** ****** *)
//
prfun
array_v_extend :
  {a:vt0p}
  {l:addr}{n:int}
  (array_v (INV(a), l, n), a @ l+n*sizeof(a)) -<prf> array_v (a, l, n+1)
//
prfun
array_v_unextend :
  {a:vt0p}
  {l:addr}
  {n:int | n > 0}
  (array_v (INV(a), l, n)) -<prf> (array_v (a, l, n-1), a @ l+(n-1)*sizeof(a))
//
(* ****** ****** *)

prfun
array_v_takeout
  {a:vt0p}
  {l:addr}
  {n:int }
  {i:nat | i < n}
(
  pfarr: array_v (INV(a), l, n)
) :<prf> vtakeout (
  array_v (a, l, n), a @ (l+i*sizeof(a))
) (* end of [array_v_takeout] *)

(* ****** ****** *)

praxi
array_v_group
  {a:vt0p}{l:addr}{m,n:int}
  (pf: array_v (INV(a), l, m*n)): array_v (@[a][n], l, m)
// end of [array_v_group]

praxi
array_v_ungroup
  {a:vt0p}{l:addr}{m,n:int}
  (pf: array_v (@[INV(a)][n], l, m)): array_v (INV(a), l, m*n)
// end of [array_v_ungroup]

(* ****** ****** *)

(* end of [array_prf.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/giterator.atxt
** Time of generation: Sat Oct 17 15:19:50 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

sortdef tk = tkind
sortdef t0p = t@ype
sortdef vtp = viewtype
sortdef vt0p = viewt@ype

(* ****** ****** *)
//
absviewtype
giter_viewtype ( // HX: boxed
  knd: tkind, kpm: tkind, x: viewt@ype+, f: int, r: int
) // end of [giter_viewtype]
stadef giter_5 = giter_viewtype
//
viewtypedef giter_3 (
  knd: tkind, kpm: tkind, x: vt0p
) = [f,r:int] giter_viewtype (knd, kpm, x, f, r)
viewtypedef giter_4 (
  knd: tkind, kpm: tkind, x: vt0p, fr:int
) = [f,r:int | f+r==fr] giter_viewtype (knd, kpm, x, f, r)
//
stadef giter = giter_3
stadef giter = giter_4
stadef giter = giter_5
//
(* ****** ****** *)

prfun lemma_giter_param
  {knd:tk}{kpm:tk}{x:vt0p}{f,r:int}
  (itr: !giter (knd, kpm, x, f, r)): [f>=0;r>=0] void
// end of [lemma_giter_param]

(* ****** ****** *)
//
// HX: for fun list giters
//
stacst giter_list_kind : tkind
stacst giter_list_param : () -> tkind

fun{x:t0p}
giter_make_list
  {n:int}
(
  xs: list (INV(x), n)
) : giter
  (giter_list_kind, giter_list_param(), x, 0, n)
// end of [giter_make_list]

fun giter_free_list
  {x:t0p}{f,r:int}
(
  itr: giter
    (giter_list_kind, giter_list_param(), x, f, r)
) : list (x, r) // end of [giter_free_list]

(* ****** ****** *)
//
// HX: for singly-linked list giters
//
stacst giter_list_vt_kind : tkind
stacst giter_list_vt_param : () -> tkind

fun{x:t0p}
giter_make_list_vt
  {n:int}
(
  xs: list_vt (INV(x), n)
) : giter
  (giter_list_vt_kind, giter_list_vt_param(), x, 0, n)
// end of [giter_make_list_vt]

fun giter_free_list_vt
  {x:t0p}{f,r:int}
(
  itr: giter
    (giter_list_vt_kind, giter_list_vt_param(), x, f, r)
) : list_vt (x, f+r) // end of [giter_free_list_vt]

(* ****** ****** *)
//
// HX: for linear array giters
//
stacst giter_array_kind : tkind
stacst giter_array_param : (addr) -> tkind

fun{x:vt0p}
giter_make_array
  {l:addr}{n:int}
(
  pf: array_v (INV(x), l, n) | p: ptr l, n: size_t n
) : giter (giter_array_kind, giter_array_param(l), x, 0, n)
// end of [giter_make_array]

fun giter_free_array
  {x:vt0p}{l:addr}{f,r:int}
(
  itr: giter
    (giter_array_kind, giter_array_param(l), x, f, r)
) : (array_v (x, l, f+r) | void) // endfun

(* ****** ****** *)
//
// HX: for functional string giters
//
stacst giter_string_kind : tkind
stacst giter_string_param : () -> tkind

fun
giter_make_string
  {n:int}
(
  str: string (n)
) : giter (
  giter_string_kind, giter_string_param(), char, 0, n
) // end of [giter_make_string]

fun
giter_free_string
  {f,r:int}
(
  itr: giter (giter_string_kind, giter_string_param(), char, f, r)
) : string (f+r) // end of [giter_free_string]

(* ****** ****** *)

fun{
knd:tk
}{x:vt0p
} fprint_giter_sep
  {kpm:tk}{f,r:int}
(
  out: FILEref
, itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+r, 0)
, sep: NSH(string)
) : void // end of [fprint_giter_sep]

(* ****** ****** *)

macdef BEG = 0 and END = 1

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_is_atbeg
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)):<> bool (f==0)
// end of [giter_is_atbeg]

fun{
knd:tk}{x:vt0p
} giter_isnot_atbeg
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)):<> bool (f > 0)
// end of [giter_isnot_atbeg]

fun{
knd:tk}{x:vt0p
} eq_int_iter
  {kpm:tk}{f,r:int}
(
  BEG: int(0), itr: !giter (knd, kpm, INV(x), f, r)
) : bool (f==0) // end of [eq_int_iter]
fun{
knd:tk}{x:vt0p
} lt_int_iter
  {kpm:tk}{f,r:int}
(
  BEG: int(0), itr: !giter (knd, kpm, INV(x), f, r)
) : bool (f > 0) // end of [lt_int_iter]

overload = with eq_int_iter
overload < with lt_int_iter

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_is_atend
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)):<> bool (r==0)
// end of [giter_is_atend]
fun{
knd:tk}{x:vt0p
} giter_isnot_atend
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)):<> bool (r > 0)
// end of [giter_isnot_atend]

fun{
knd:tk}{x:vt0p
} eq_giter_int
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r), END: int(1)
) : bool (r==0) // end of [eq_giter_int]
fun{
knd:tk}{x:vt0p
} lt_giter_int
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r), END: int(1)
) : bool (r > 0) // end of [lt_giter_int]

overload = with eq_giter_int
overload < with lt_giter_int

(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_get
  {kpm:tk}{f,r:int | r > 0}
  (itr: !giter (knd, kpm, INV(x), f, r)): x
// end of [giter_get]

fun{
knd:tk}{x:t0p
} giter_set
  {kpm:tk}{f,r:int | r > 0}
  (itr: !giter (knd, kpm, INV(x), f, r), x: x): void
// end of [giter_set]

fun{
knd:tk}{x:vt0p
} giter_exch
  {kpm:tk}{f,r:int | r > 0}
  (itr: !giter (knd, kpm, INV(x), f, r), x: &x >> x): void
// end of [giter_exch]

overload get with giter_get
overload set with giter_set
overload exch with giter_exch

fun{
knd:tk}{x:vt0p
} giter_getref
  {kpm:tk}{f,r:int | r > 0}
  (itr: !giter (knd, kpm, INV(x), f, r)): Ptr1
// end of [giter_getref]

fun{
knd:tk}{x:vt0p
} giter_vttake
  {kpm:tk}{f,r:int | r > 0}
  (itr: !giter (knd, kpm, INV(x), f, r)): vttakeout0 (x)
// end of [giter_vttake]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1)
) : void // end of [giter_inc]
fun{
knd:tk}{x:vt0p
} giter_dec
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1)
) : void // end of [giter_dec]

overload ++ with giter_inc
overload -- with giter_dec
overload inc with giter_inc
overload dec with giter_dec 

(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_get_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1)
) : x // end of [giter_get_inc]

fun{
knd:tk}{x:t0p
} giter_set_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1), x: x
) : void // end of [giter_set_inc]

fun{
knd:tk}{x:vt0p
} giter_exch_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1)
, x: &x >> x
) : void // end of [giter_exch_inc]

overload !++ with giter_get_inc
overload =++ with giter_set_inc
overload getinc with giter_get_inc
overload setinc with giter_set_inc
overload exchinc with giter_exch_inc

fun{
knd:tk}{x:vt0p
} giter_getref_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1)
) : Ptr1 // end of [giter_getref_inc]

fun{
knd:tk}{x:vt0p
} giter_vttake_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1)
) : vttakeout0 (x) // end of [giter_vttake_inc]

(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_dec_get
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1)
) : x // end of [giter_dec_get]

fun{
knd:tk}{x:t0p
} giter_dec_set
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1), x: x
) : void // end of [giter_dec_set]

fun{
knd:tk}{x:vt0p
} giter_dec_exch
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1)
, x: &x >> x
) : void // end of [giter_dec_exch]

overload --! with giter_dec_get
overload --= with giter_dec_set
overload decget with giter_dec_get
overload decset with giter_dec_set
overload decexch with giter_dec_exch

fun{
knd:tk}{x:vt0p
} giter_dec_getref
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1)
) : Ptr1 // end of [giter_dec_getref]

fun{
knd:tk}{x:vt0p
} giter_dec_vttake
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1)
) : vttakeout0 (x) // end of [giter_dec_vttake]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_get_fofs
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)): size_t (f)
// end of [giter_get_fofs]

fun{
knd:tk}{x:vt0p
} giter_get_rofs
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)): size_t (r)
// end of [giter_get_rofs]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_fjmp // forward-jmp
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i <= r}
(
//
// HX: O(log(n))-time expected (O(1) for arrays)
//
  itr: !giter (knd, kpm, INV(x), f, r)
         >> giter (knd, kpm, x, f+i, r-i), i: size_t (i)
) : void // end of [giter_fjmp]

(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_fget_at // forward-get
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: size_t (i)
) : x // end of [giter_fget_at]
fun{
knd:tk}{x:t0p
} giter_fset_at // forward-set
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: size_t (i), x: x
) : void // end of [giter_fset_at]

fun{
knd:tk}{x:vt0p
} giter_fexch_at // forward-exch
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: size_t (i), x: &x >> x
) : void // end of [giter_fexch_at]

fun{
knd:tk}{x:vt0p
} giter_fgetref_at // forward-get
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: size_t (i)
) : Ptr1 // end of [giter_fgetref_at]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_fbjmp // forward/backward-jmp
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i <= r}
(
//
// HX: O(log(n))-time expected (O(1) for arrays)
//
  itr: !giter (knd, kpm, INV(x), f, r)
         >> giter (knd, kpm, x, f+i, r-i), i: ssize_t (i)
) : void // end of [giter_fbjmp]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_fbgetref_at // forward/backward-getref
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: ssize_t (i)
) : Ptr1 // end of [giter_fbgetref_at]

fun{
knd:tk}{x:t0p
} giter_fbget_at // forward/backward-get
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: ssize_t (i)
) : x // end of [giter_fbget_at]
fun{
knd:tk}{x:t0p
} giter_fbset_at // forward/backward-set
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: ssize_t (i), x: x
) : void // end of [giter_fbset_at]

fun{
knd:tk}{x:vt0p
} giter_fbexch_at // forward/backward-exch
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: ssize_t (i), x: &x >> x
) : void // end of [giter_fbexch_at]

(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_fgetlst
//
// forward-getlst
//
  {kpm:tk}
  {f,r:int}
  {i:nat}
(
  itr: !giter (knd, kpm, INV(x), f, r)
         >> giter (knd, kpm, x, f+i1, r-i1)
, i: &int i >> int (i-i1)
) : #[
  i1:int | i1==min(i, r)
] list_vt (x, i1) // end of [giter_fgetlst]

fun{
knd:tk}{x:t0p
} giter_bgetlst
//
// backward-getlst
//
  {kpm:tk}
  {f,r:int}
  {i:nat}
(
  itr: !giter (knd, kpm, INV(x), f, r)
         >> giter (knd, kpm, x, f-i1, r+i1)
, i: &int i >> int (i-i1)
) : #[
  i1:int | i1==min(i, f)
] list_vt (x, i1) // end of [giter_bgetlst]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_ins
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f, r+1), x: x
) : void // end of [giter_ins]

fun{
knd:tk}{x:vt0p
} giter_ins_inc
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r), x: x
) : void // end of [giter_ins_inc]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_rmv
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f, r-1)
) : x(*removed*) // end of [giter_rmv]

fun{
knd:tk}{x:vt0p
} giter_dec_rmv
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r)
) : x(*removed*) // end of [giter_dec_rmv]

(* ****** ****** *)
//
// HX: some common generic functions on giters
//
(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_listize_cpy {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+r, 0)
) : list_vt (x, r) // end of [giter_listize_cpy]
fun{
knd:tk}{x:t0p
} giter_rlistize_cpy {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+r, 0)
) : list_vt (x, r) // end of [giter_rlistize_cpy]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_listize_rmv {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f, 0)
) : list_vt (x, r) // end of [giter_listize_rmv]
fun{
knd:tk}{x:vt0p
} giter_rlistize_rmv {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f, 0)
) : list_vt (x, r) // end of [giter_rlistize_rmv]

(* ****** ****** *)

fun{
x:vt0p}{env:vt0p
} giter_foreach$cont (x: &x, env: &env): bool
fun{
x:vt0p}{env:vt0p
} giter_foreach$fwork (x: &x, env: &env): void
fun{
knd:tk}{x:vt0p
} giter_foreach
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f1, r1)
) : #[f1,r1:int | f <= f1; f+r==f1+r1] void // end of [giter_foreach]
fun{
knd:tk}{x:vt0p}{env:vt0p
} giter_foreach_env
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f1, r1)
, env: &(env) >> env
) : #[f1,r1:int | f <= f1; f+r==f1+r1] void // end of [giter_foreach_env]

(* ****** ****** *)

fun{
x:vt0p}{env:vt0p
} giter_rforeach$cont (x: &x, env: &env): bool
fun{
x:vt0p}{env:vt0p
} giter_rforeach$fwork (x: &x, env: &env): void
fun{
knd:tk}{x:vt0p
} giter_rforeach
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f1, r1)
) : #[f1,r1:int | f >= f1; f+r==f1+r1] void // end of [giter_rforeach]
fun{
knd:tk}{x:vt0p}{env:vt0p
} giter_rforeach_env
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f1, r1)
, env: &(env) >> env
) : #[f1,r1:int | f <= f1; f+r==f1+r1] void // end of [giter_rforeach_env]

(* ****** ****** *)

(*
** HX-2012-05:
** Note that [iter] should support at least log-time
** fjmp and fget in order to make binary search meaningful.
**
** ford (x) = cmp (x0, x), where [x0] is the key being searched
**
** The after-interator points to the left-most location
** where the value [x0] can be inserted without violating
** orderedness.
*)
fun{x:vt0p}
giter_bsearch$ford (x: &x): int
fun{
knd:tk}{x:vt0p
} giter_bsearch
  {kpm:tk}
  {f,r:int}
  {ra:int | ra <= r}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f1, r1)
, ra: size_t (ra) // range being searched
) : #[
  f1,r1:int | f1>=f;f+ra>=f1;f1+r1==f+r
] void // end of [giter_bsearch]

(* ****** ****** *)

(* end of [giterator.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/arith_prf.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)

dataprop
MUL (int, int, int) =
  | {n:int}
    MULbas (0, n, 0)
  | {m:nat}{n:int}{p:int}
    MULind (m+1, n, p+n) of MUL (m, n, p)
  | {m:pos}{n:int}{p:int}
    MULneg (~m, n, ~p) of MUL (m, n, p)
// end of [MUL]

(* ****** ****** *)

praxi mul_make : {m,n:int} () -<prf> MUL (m, n, m*n)
praxi mul_elim : {m,n:int} {p:int} MUL (m, n, p) -<prf> [p == m*n] void

(* ****** ****** *)

prfun mul_istot {m,n:int} ():<prf> [p:int] MUL (m, n, p)

prfun mul_isfun {m,n:int} {p1,p2:int}
  (pf1: MUL (m, n, p1), pf2: MUL (m, n, p2)):<prf> [p1==p2] void
prfun mul_isfun2 {m,n:int} {p1,p2:int}
  (pf1: MUL (m, n, p1), pf2: MUL (m, n, p2)):<prf> EQINT (p1, p2)

(* ****** ****** *)
//
// HX: (m+i)*n = m*n+i*n
//
praxi mul_add_const {i:int}
  {m,n:int} {p:int} (pf: MUL (m, n, p)):<prf> MUL (m+i, n, p+i*n)
// end of [mul_add_const]

(* ****** ****** *)
//
// HX: (ax+b)*(cy+d) = ac*xy + ad*x + bc*y + bd
//
praxi mul_expand_linear // a,b,c,d: constants!
  {a,b:int}
  {c,d:int}
  {x,y:int}
  {xy:int} (
  pf: MUL (x, y, xy)
) :<prf> MUL (a*x+b, c*y+d, a*c*xy+a*d*x+b*c*y+b*d)
// end of [mul_expand_linear]

(* ****** ****** *)
//
// HX: (a1x1+a2x2+b)*(c1y1+c2y2+d) = ...
//
praxi mul_expand2_linear // a1,b1,c1,a2,b2,c2: constants!
  {a1,a2,b:int}
  {c1,c2,d:int}
  {x1,x2:int}
  {y1,y2:int}
  {x1y1,x1y2,x2y1,x2y2:int} (
  pf11: MUL (x1, y1, x1y1), pf12: MUL (x1, y2, x1y2)
, pf21: MUL (x2, y1, x2y1), pf22: MUL (x2, y2, x2y2)
) :<prf> MUL (
  a1*x1+a2*x2+b
, c1*y1+c2*y2+d
, a1*c1*x1y1 + a1*c2*x1y2 +
  a2*c1*x2y1 + a2*c2*x2y2 +
  a1*d*x1 + a2*d*x2 +
  b*c1*y1 + b*c2*y2 +
  b*d
) // end of [mul_expand2_linear]

(* ****** ****** *)

prfun mul_gte_gte_gte
  : {m,n:int | m >= 0; n >= 0} () -<prf> [m*n >= 0] void
prfun mul_lte_gte_lte
  : {m,n:int | m <= 0; n >= 0} () -<prf> [m*n <= 0] void
prfun mul_gte_lte_lte
  : {m,n:int | m >= 0; n <= 0} () -<prf> [m*n <= 0] void
prfun mul_lte_lte_gte
  : {m,n:int | m <= 0; n <= 0} () -<prf> [m*n >= 0] void

(* ****** ****** *)

prfun mul_nat_nat_nat :
  {m,n:nat} {p:int} MUL (m, n, p) -<prf> [p >= 0] void
prfun mul_pos_pos_pos :
  {m,n:pos} {p:int} MUL (m, n, p) -<prf> [p >= m+n-1] void

(* ****** ****** *)

prfun mul_negate
  {m,n:int} {p:int} (pf: MUL (m, n, p)):<prf> MUL (~m, n, ~p)
prfun mul_negate2
  {m,n:int} {p:int} (pf: MUL (m, n, p)):<prf> MUL (m, ~n, ~p)

(* ****** ****** *)
//
// HX: m*n = n*m
//
prfun mul_commute
  {m,n:int} {p:int} (pf: MUL (m, n, p)):<prf> MUL (n, m, p)
prfun mul_is_commutative
  {m,n:int} {p,q:int} (pf1: MUL (m, n, p), pf2: MUL (n, m, q)): [p==q] void

(* ****** ****** *)
//
// HX: m*(n1+n2) = m*n1+m*n2
//
prfun mul_distribute
  {m:int} {n1,n2:int} {p1,p2:int}
  (pf1: MUL (m, n1, p1), pf2: MUL (m, n2, p2)):<prf> MUL (m, n1+n2, p1+p2)
//
// HX: (m1+m2)*n = m1*n + m2*n
//
prfun mul_distribute2
  {m1,m2:int} {n:int} {p1,p2:int}
  (pf1: MUL (m1, n, p1), pf2: MUL (m2, n, p2)):<prf> MUL (m1+m2, n, p1+p2)
//
(* ****** ****** *)

prfun
mul_is_associative
  {x,y,z:int}
  {xy,yz:int}
  {xy_z,x_yz:int} (
  pf1: MUL (x, y, xy), pf2: MUL (y, z, yz)
, pf3: MUL (xy, z, xy_z), pf4: MUL (x, yz, x_yz)
) :<prf> [xy_z==x_yz] void

(* ****** ****** *)
//
// HX-2010-12-30: 
//
absprop
DIVMOD (
  x:int, y: int, q: int, r: int // x = q * y + r
) // end of [DIVMOD]

propdef
DIV (x:int, y:int, q:int) = [r:int] DIVMOD (x, y, q, r)
propdef
MOD (x:int, y:int, r:int) = [q:int] DIVMOD (x, y, q, r)

(* ****** ****** *)
//
praxi
div_istot
  {x,y:int | x >= 0; y > 0} (): DIV (x, y, x/y)
//
praxi
divmod_istot
  {x,y:int |
   x >= 0; y > 0}
  ((*void*)): [q,r:nat | r < y] DIVMOD (x, y, q, r)
//
(* ****** ****** *)

praxi
divmod_isfun
  {x,y:int | x >= 0; y > 0}
  {q1,q2:int} {r1,r2:int} (
  pf1: DIVMOD (x, y, q1, r1)
, pf2: DIVMOD (x, y, q2, r2)
) : [q1==q2;r1==r2] void // end of [divmod_isfun]

(* ****** ****** *)

praxi
divmod_elim
  {x,y:int | x >= 0; y > 0}
  {q,r:int}
(
  pf: DIVMOD (x, y, q, r)
) : [qy:nat | 0 <= r; r < y; x==qy+r] MUL (q, y, qy)

praxi
divmod_mul_elim
  {x,y:int | x >= 0; y > 0}
  {q,r:int}
  (pf: DIVMOD (x, y, q, r))
: [0 <= q; 0 <= r; r < y; q==ndiv_int_int(x, y); x==q*y+r] void
// end of [divmod_mul_elim]

(* ****** ****** *)
//
dataprop
EXP2 (int, int) =
  | EXP2bas (0, 1)
  | {n:nat}{p:nat}
    EXP2ind (n+1, 2*p) of EXP2 (n, p)
// end of [EXP2]
//
prfun lemma_exp2_param :
  {n:int}{p:int} EXP2 (n, p) -<prf> [n>=0;p>=1] void
// end of [lemma_exp2_param]
//
prfun exp2_istot {n:nat} (): [p:nat] EXP2 (n, p)
prfun exp2_isfun {n:nat} {p1,p2:int}
  (pf1: EXP2 (n, p1), pf2: EXP2 (n, p2)): [p1==p2] void
// end of [exp2_isfun]
//
// HX: proven in [arith_prf.dats]
//
prfun exp2_ispos
  {n:nat} {p:int} (pf: EXP2 (n, p)): [p >= 1] void
// end of [exp2_ispos]
//
// HX: proven in [arith_prf.dats]
//
prfun exp2_is_mono
  {n1,n2:nat | n1 <= n2} {p1,p2:int}
  (pf1: EXP2 (n1, p1), pf2: EXP2 (n2, p2)): [p1 <= p2] void
// end of [exp2_is_mono]
//
// HX: proven in [arith_prf.dats]
//
prfun exp2_muladd
  {n1,n2:nat | n1 <= n2} {p1,p2:int} {p:int} (
  pf1: EXP2 (n1, p1), pf2: EXP2 (n2, p2), pf3: MUL (p1, p2, p)
) : EXP2 (n1+n2, p) // end of [exp2_muladd]
//
(* ****** ****** *)

absprop EXP (int(*base*), int(*power*), int(*res*))

praxi lemma_exp_param
  {b:int}{n:int}{p:int} (pf: EXP (b, n, p)): [n >= 0] void
// end of [lemma_exp_param]

praxi exp_istot {b:int}{n:nat} (): [p:nat] EXP (b, n, p)
praxi exp_isfun {b:int}{n:int}{p1,p2:int}
  (pf1: EXP (b, n, p1), pf2: EXP (b, n, p2)): [p1==p2] void
// end of [exp_isfun]

praxi exp_elim_0 {n:pos}{p:int} (pf: EXP (0, n, p)): [p==0] void
praxi exp_elim_1 {n:int}{p:int} (pf: EXP (1, n, p)): [p==1] void
praxi exp_elim_2 {n:int}{p:int} (pf: EXP (2, n, p)): EXP2 (n, p)
praxi exp_elim_b_0 {b:int}{p:int} (pf: EXP (b, 0, p)): [p==1] void
praxi exp_elim_b_1 {b:int}{p:int} (pf: EXP (b, 1, p)): [p==b] void
praxi exp_elim_b_2 {b:int}{p:int} (pf: EXP (b, 2, p)): MUL (b, b, p)

praxi exp_muladd
  {b:int}{n1,n2:int}{p1,p2:int}{p:int} (
  pf1: EXP (b, n1, p1), pf2: EXP (b, n2, p2)
) : EXP (b, n1+n2, p1*p2) // end of [exp_muladd]

praxi exp_expmul
  {b:int}{n1,n2:int}{bn1:int}{bn1n2:int} (
  pf1: EXP (b, n1, bn1), pf2: EXP (bn1, n2, bn1n2)
) : EXP (b, n1*n2, bn1n2) // end of [exp_muladd]

(* ****** ****** *)

(* end of [arith_prf.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/matrix.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef t0p = t@ype
sortdef vtp = viewtype
sortdef vt0p = viewt@ype

(* ****** ****** *)

absvt@ype
matrix_vt0ype_int_int_vt0ype
  (a:vt@ype+, row:int, col:int) = array(a, row*col)
stadef matrix = matrix_vt0ype_int_int_vt0ype

(* ****** ****** *)

viewdef
matrix_v (
  a:viewt@ype+, l:addr, row:int, col:int
) = matrix (a, row, col) @ l

(* ****** ****** *)

exception
MatrixSubscriptExn of ((*void*))

(* ****** ****** *)
//
praxi
lemma_matrix_param{a:vt0p}
  {l:addr}{m,n:int} (M: &matrix(INV(a), m, n)): [m >= 0; n >= 0] void
//
praxi
lemma_matrix_v_param{a:vt0p}
  {l:addr}{m,n:int} (pf: !matrix_v (INV(a), l, m, n)): [m >= 0; n >= 0] void
//
(* ****** ****** *)
//
praxi
array2matrix_v
  {a:vt0p}{l:addr}{m,n:int}
  (pf: array_v (INV(a), l, m * n)) : matrix_v (a, l, m, n)
praxi
matrix2array_v
  {a:vt0p}{l:addr}{m,n:int}
  (pf: matrix_v (INV(a), l, m, n)) : array_v (a, l, m * n)
//
(* ****** ****** *)
//
// HX: ATS matrices is of row-major style
//
absview
matrow_view (a:viewt@ype+, l:addr, m:int, n:int)
stadef matrow_v = matrow_view
absview
matcol_view (a:viewt@ype+, l:addr, m:int, n:int)
stadef matcol_v = matcol_view
//
(* ****** ****** *)

fun{a:vt0p}
matrix_getref_at_int
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: natLt (m), n: int n, j: natLt (n)
) :<> cPtr1 (a) // endfun

fun{a:vt0p}
matrix_getref_at_size
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: sizeLt (m), n: size_t n, j: sizeLt (n)
) :<> cPtr1 (a) // endfun

symintr matrix_getref_at
overload matrix_getref_at with matrix_getref_at_int
overload matrix_getref_at with matrix_getref_at_size

(* ****** ****** *)

fun{a:t0p}
matrix_get_at_int
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: natLt (m), n: int n, j: natLt (n)
) :<> (a) // endfun
overload [] with matrix_get_at_int

fun{a:t0p}
matrix_get_at_size
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: sizeLt (m), n: size_t n, j: sizeLt (n)
) :<> (a) // endfun
overload [] with matrix_get_at_size

symintr matrix_get_at
overload matrix_get_at with matrix_get_at_int of 0
overload matrix_get_at with matrix_get_at_size of 0

(* ****** ****** *)

fun{a:t0p}
matrix_set_at_int
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: natLt (m), n: int n, j: natLt (n), x: a
) :<!wrt> void // endfun
overload [] with matrix_set_at_int

fun{a:t0p}
matrix_set_at_size
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: sizeLt (m), n: size_t n, j: sizeLt (n), x: a
) :<!wrt> void // endfun
overload [] with matrix_set_at_size

symintr matrix_set_at
overload matrix_set_at with matrix_set_at_int of 0
overload matrix_set_at with matrix_set_at_size of 0

(* ****** ****** *)

fun{a:vt0p}
matrix_exch_at_int
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: natLt (m), n: int n, j: natLt (n), x: &a>>a
) :<!wrt> void // endfun

fun{a:vt0p}
matrix_exch_at_size
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: sizeLt (m), n: size_t n, j: sizeLt (n), x: &a>>a
) :<!wrt> void // endfun

symintr matrix_exch_at
overload matrix_exch_at with matrix_exch_at_int
overload matrix_exch_at with matrix_exch_at_size

(* ****** ****** *)

fun{a:vt0p}
matrix_ptr_alloc
  {m,n:int}
(
  row: size_t m, col: size_t n
) :<!wrt> [l:agz]
(
  matrix_v (a?, l, m, n), mfree_gc_v (l) | ptr l
) // end of [matrix_ptr_alloc]

fun{}
matrix_ptr_free
  {a:vt0p}{l:addr}{m,n:int}
(
  matrix_v (a?, l, m, n), mfree_gc_v (l) | ptr l
) :<!wrt> void // end of [matrix_ptr_free]

(* ****** ****** *)

fun{a:vt0p}
matrix_tabulate$fopr (i: size_t, j: size_t): (a)
fun{a:vt0p}
matrix_ptr_tabulate
  {m,n:int} (row: size_t m, col: size_t n)
  : [l:addr] (matrix_v (a, l, m, n), mfree_gc_v (l) | ptr l)
// end of [matrixptr_tabulate]

(* ****** ****** *)
//
fun{
} fprint_matrix$sep1 (out: FILEref): void // col separation
fun{
} fprint_matrix$sep2 (out: FILEref): void // row separation
//
fun{a:vt0p}
fprint_matrix_int{m,n:int}
(
  out: FILEref
, M: &matrix (INV(a), m, n), m: int (m), n: int (n)
) : void // end of [fprint_matrix_int]
fun{a:vt0p}
fprint_matrix_size{m,n:int}
(
  out: FILEref
, M: &matrix (INV(a), m, n), m: size_t (m), n: size_t (n)
) : void // end of [fprint_matrix_size]
//
symintr fprint_matrix
overload fprint_matrix with fprint_matrix_int
overload fprint_matrix with fprint_matrix_size
overload fprint with fprint_matrix
//
(* ****** ****** *)

fun{a:vt0p}
fprint_matrix_sep{m,n:int}
(
  out: FILEref
, M: &matrix (INV(a), m, n), m: size_t (m), n: size_t (n)
, sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_matrix_sep]

(* ****** ****** *)

fun{a:vt0p}
matrix_ptr_takeout_elt
  {l0:addr}
  {m,n:int}
  {i,j:nat | i < m; j < n} (
  pfmat: matrix_v (INV(a), l0, m, n)
| base: ptr l0, i: size_t i, n: size_t n, j: size_t j
) :<> [l:addr] (
  a @ l
, a @ l -<lin,prf> matrix_v (a, l0, m, n)
| ptr (l)
) // end of [matrix_ptr_takeout_elt]

fun{a:vt0p}
matrix_ptr_takeout_row
  {l0:addr}
  {m,n:int}
  {i:int | i < m}
(
  pfmat: matrix_v (INV(a), l0, m, n)
| base: ptr l0, i: size_t i, n: size_t n
) :<> [l:addr] (
  matrow_v (a, l, m, n)
, matrow_v (a, l, m, n) -<lin,prf> matrix_v (a, l0, m, n)
| ptr (l)
) // end of [matrix_ptr_takeout_row]

fun{a:vt0p}
matrix_ptr_takeout_col
  {l0:addr}
  {m,n:int}
  {i:int | i < m}
(
  pfmat: matrix_v (INV(a), l0, m, n)
| base: ptr l0, i: size_t i, n: size_t n
) :<> [l:addr] (
  matcol_v (a, l, m, n)
, matcol_v (a, l, m, n) -<lin,prf> matrix_v (a, l0, m, n)
| ptr (l)
) // end of [matrix_ptr_takeout_col]

(* ****** ****** *)

fun{
a:vt0p}{env:vt0p
} matrix_foreach$fwork (x: &a >> _, env: &(env) >> _): void
fun{
a:vt0p
} matrix_foreach{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t m, n: size_t n
) : void // end of [matrix_foreach]
fun{
a:vt0p}{env:vt0p
} matrix_foreach_env{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t m, n: size_t n, env: &(env) >> _
) : void // end of [matrix_foreach_env]

(* ****** ****** *)

fun{
a:vt0p}{env:vt0p
} matrix_foreachrow$fwork{n:int}
(
  row: &array (INV(a), n) >> _, n: size_t n, env: &(env) >> _
) : void // end of [matrix_foreachrow$fwork]

fun{
a:vt0p
} matrix_foreachrow{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t (m), n: size_t (n)
) : void // end of [matrix_foreachrow]
fun{
a:vt0p}{env:vt0p
} matrix_foreachrow_env{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t m, n: size_t n, env: &(env) >> _
) : void // end of [matrix_foreachrow_env]

(* ****** ****** *)

fun{a:vt0p}
matrix_initize$init
  (i: size_t, j: size_t, x: &a? >> a): void
fun{a:vt0p}
matrix_initize{m,n:int}
(
  A: &matrix (a?, m, n) >> matrix (a, m, n), row: size_t m, col: size_t n
) : void // end of [matrix_initize]

macdef matrix_initialize = matrix_initize

(* ****** ****** *)

fun
{a:vt0p}
{b:vt0p}
matrix_mapto$fwork
  (x: &a, y: &b? >> b): void
fun
{a:vt0p}
{b:vt0p}
matrix_mapto
  {m,n:int}
(
  A: &matrix (INV(a), m, n)
, B: &matrix (b?, m, n) >> matrix (b, m, n)
, m: size_t m, n: size_t n
) : void // end of [matrix_mapto]

(* ****** ****** *)

fun
{a,b:vt0p}
{c:vt0p}
matrix_map2to$fwork
  (x: &a, y: &b, z: &c? >> c): void
fun
{a,b:vt0p}
{c:vt0p}
matrix_map2to
  {m,n:int}
(
  A: &matrix (INV(a), m, n)
, B: &matrix (INV(b),  m, n)
, C: &matrix (c?, m, n) >> matrix (c, m, n)
, m: size_t m, n: size_t n
) : void // end of [matrix_map2to]

(* ****** ****** *)

(* end of [matrix.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/bool.atxt
** Time of generation: Sat Oct 17 15:19:44 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)
//
castfn g0ofg1_bool (x: Bool):<> bool
castfn g1ofg0_bool (x: bool):<> Bool
//
overload g0ofg1 with g0ofg1_bool // index-erasing
overload g1ofg0 with g1ofg0_bool // index-inducing
//
(* ****** ****** *)
//
symintr int2bool
//
fun int2bool0 (i: int):<> bool = "mac#%"
fun int2bool1
  {i:int} (i: int i):<> bool (i != 0) = "mac#%"
//
overload int2bool with int2bool0 of 0
overload int2bool with int2bool1 of 10
//
symintr bool2int
//
fun bool2int0 (b: bool):<> natLt(2) = "mac#%"
fun bool2int1
  {b:bool} (b: bool b):<> int (bool2int(b)) = "mac#%"
//
overload bool2int with bool2int0 of 0
overload bool2int with bool2int1 of 10
//
(* ****** ****** *)

(*
//
// HX: declared in [prelude/basics_dyn.sats]
//
val true : bool (true) and false : bool (false)
*)

(* ****** ****** *)

(*
** HX-2012-06:
** shortcut version of disjuction and conjuction
** note that these two cannot be declared as functions
*)
macdef || (b1, b2) = (if ,(b1) then true else ,(b2)): bool
macdef && (b1, b2) = (if ,(b1) then ,(b2) else false): bool

(* ****** ****** *)

typedef boolLte (b: bool) = [a: bool | a <= b] bool (a)
typedef boolGte (b: bool) = [a: bool | a >= b] bool (a)

(* ****** ****** *)

fun neg_bool0
  (b: bool):<> bool = "mac#%"
overload ~ with neg_bool0 of 0
overload not with neg_bool0 of 0

(* ****** ****** *)

fun add_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload + with add_bool0_bool0 of 0
fun mul_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload * with mul_bool0_bool0 of 0

(* ****** ****** *)
//
fun xor_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
//
(* ****** ****** *)

fun lt_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload < with lt_bool0_bool0 of 0
fun lte_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload <= with lte_bool0_bool0 of 0

fun gt_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload > with gt_bool0_bool0 of 0
fun gte_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload >= with gte_bool0_bool0 of 0

fun eq_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload = with eq_bool0_bool0 of 0
fun neq_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload != with neq_bool0_bool0 of 0
overload <> with neq_bool0_bool0 of 0

(* ****** ****** *)

fun compare_bool0_bool0
  (b1: bool, b2: bool):<> Sgn = "mac#%"
overload compare with compare_bool0_bool0

(* ****** ****** *)
//
// HX:
// return is statically allocated
//
fun
bool2string(b: bool):<> string = "mac#%"
//
(* ****** ****** *)
//
fun print_bool (x: bool): void = "mac#%"
fun prerr_bool (x: bool): void = "mac#%"
fun fprint_bool : fprint_type (bool) = "mac#%"
//
overload print with print_bool
overload prerr with prerr_bool
overload fprint with fprint_bool
//
(* ****** ****** *)

fun neg_bool1 {b:bool}
  (b: bool b):<> bool (~b) = "mac#%"
overload ~ with neg_bool1 of 10
overload not with neg_bool1 of 10

(* ****** ****** *)

fun
add_bool1_bool0 {b1:bool}
  (b1: bool b1, b2: bool):<> boolGte (b1) = "mac#%"
overload + with add_bool1_bool0 of 10

fun
add_bool0_bool1 {b2:bool}
  (b1: bool, b2: bool b2):<> boolGte (b2) = "mac#%"
overload + with add_bool0_bool1 of 10

fun
add_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 || b2) = "mac#%"
overload + with add_bool1_bool1 of 20

(* ****** ****** *)

fun
mul_bool1_bool0 {b1:bool}
  (b1: bool b1, b2: bool):<> boolLte (b1) = "mac#%"
overload * with mul_bool1_bool0 of 10

fun
mul_bool0_bool1 {b2:bool}
  (b1: bool, b2: bool b2):<> boolLte (b2) = "mac#%"
overload * with mul_bool0_bool1 of 10

fun
mul_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 && b2) = "mac#%"
overload * with mul_bool1_bool1 of 20

(* ****** ****** *)

//
// (b1 < b2) == (~b1 && b2)
//
fun
lt_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 < b2) = "mac#%"
overload < with lt_bool1_bool1 of 20
//
// (b1 <= b2) == (~b1 || b2)
//
fun
lte_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 <= b2) = "mac#%"
overload <= with lte_bool1_bool1 of 20
//
// (b1 > b2) == (b1 && ~b2)
//
fun
gt_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 > b2) = "mac#%"
overload > with gt_bool1_bool1 of 20
//
// (b1 >= b2) == (b1 || ~b2)
//
fun
gte_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 >= b2) = "mac#%"
overload >= with gte_bool1_bool1 of 20

(* ****** ****** *)

fun
eq_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 == b2) = "mac#%"
overload = with eq_bool1_bool1 of 20
fun
neq_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 != b2) = "mac#%"
overload != with neq_bool1_bool1 of 20
overload <> with neq_bool1_bool1 of 20

(* ****** ****** *)

fun
compare_bool1_bool1
  {b1,b2:bool} // HX: this one is a function
(
 b1: bool b1, b2: bool b2
) :<> int (bool2int(b1) - bool2int(b2)) = "mac#%"
overload compare with compare_bool1_bool1 of 20

(* ****** ****** *)

(* end of [bool.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/reference.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

castfn ref_get_ptr
  {a:vt0p} (r: ref a):<> [l:agz] ptr (l)
castfn ref_get_viewptr
  {a:vt0p} (r: ref a):<> [l:agz] (vbox (a @ l) | ptr l)
// end of [ref_get_viewptr]

(* ****** ****** *)

(*
macdef ptr_of_ref = ref_get_ptr
*)

(* ****** ****** *)

fun{a:vt0p} ref (x: a):<!wrt> ref a
fun{a:vt0p} ref_make_elt (x: a):<!wrt> ref a

castfn ref_make_viewptr
  {a:vt0p}{l:addr} (pf: a @ l | p: ptr l):<> ref (a)
// end of [ref_make_viewptr]

(* ****** ****** *)
//
fun{a:t0p} ref_get_elt (r: ref a):<!ref> a
fun{a:t0p} ref_set_elt (r: ref a, x: a):<!refwrt> void
//
(* ****** ****** *)
//
fun{a:vt0p} ref_exch_elt (r: ref a, x: &a>>a):<!refwrt> void
//
(* ****** ****** *)

(*
** HX-2012-05:
** this is not particularly useful except for the purpose
** of avoiding using the [vbox] pattern
*)

fun{}
ref_app_fun{a:vt0p}
(
  r: ref a, f: (&(a)>>_) -<0,!wrt> void
) :<!refwrt> void // end of [ref_app_fun]

fun{}
ref_app_funenv{a:vt0p}
  {v:view}{vt:viewtype}
(
  pfv: !v
| r: ref a, f: (!v | &(a)>>_, !vt) -<0,!wrt> void, env: !vt
) :<!refwrt> void // end of [ref_app_funenv]

(* ****** ****** *)
//
// HX-2013-10: unsafe but convenient
//
fun{}
ref_vtakeout
  {a:vt0p}
(
  ref: ref (a)
) :<!ref> [l:addr] (a @ l, (a @ l) -<lin,prf> void | ptr(l))
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with ref_get_elt // ref[]
overload [] with ref_set_elt // ref[] := (val)

(* ****** ****** *)

(* end of [reference.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/gprint.atxt
** Time of generation: Sat Oct 17 15:19:50 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2012 *)

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef t0p = t@ype

(* ****** ****** *)

fun{}
gprint$out(): FILEref

(* ****** ****** *)

fun{}
gprint_newline(): void

(* ****** ****** *)

fun{a:t0p}
gprint_val (x: a): void
fun{a:vt0p}
gprint_ref (x: &INV(a)): void

(* ****** ****** *)

fun{}
gprint_int (x: int): void
fun{}
gprint_char (x: char): void
fun{}
gprint_float (x: float): void
fun{}
gprint_double (x: double): void
fun{}
gprint_string (x: string): void

(* ****** ****** *)

fun{} gprint_list$beg(): void
fun{} gprint_list$end(): void
fun{} gprint_list$sep(): void
//
fun{a:t0p}
gprint_list (xs: List(a)): void

(* ****** ****** *)

fun{} gprint_listlist$beg1(): void
fun{} gprint_listlist$end1(): void
fun{} gprint_listlist$sep1(): void
//
fun{} gprint_listlist$beg2(): void
fun{} gprint_listlist$end2(): void
fun{} gprint_listlist$sep2(): void
//
fun{a:t0p}
gprint_listlist (xss: List(List(a))): void

(* ****** ****** *)
//
fun{} gprint_array$beg(): void
fun{} gprint_array$end(): void
fun{} gprint_array$sep(): void
//
fun{a:t0p}
gprint_array
  {n:int}
  (A: &(@[INV(a)][n]), n: size_t(n)): void
// end of [gprint_array]
fun{a:t0p}
gprint_arrayptr
  {n:int}
  (A: !arrayptr(INV(a), n), n: size_t(n)): void
// end of [gprint_arrayptr]
fun{a:t0p}
gprint_arrayref
  {n:int}(A: arrayref(a, n), n: size_t(n)): void
// end of [gprint_arrayref]
//
fun{a:t0p} gprint_arrszref(ASZ: arrszref(a)): void
//
(* ****** ****** *)

(* end of [gprint.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/arrayref.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)
//
// arrayref: a reference to an array with no size information attached
//
(* ****** ****** *)

#if(0)
//
// HX-2013-06:
// it is declared in [basic_dyn.sats]
//
abstype
arrayref_vt0ype_int_type
  (a: vt@ype(*elt*), n: int(*size*)) = ptr
stadef arrayref = arrayref_vt0ype_int_type
#endif

(* ****** ****** *)

praxi
lemma_arrayref_param
  {a:vt0p}{n:int} (A: arrayref (a, n)): [n >= 0] void
// end of [lemma_arrayref_param]

(* ****** ****** *)

castfn
arrayref2ptr{a:vt0p}{n:int} (A: arrayref(a, n)):<> Ptr0

(* ****** ****** *)

(*
** HX-2012-06:
** this function essentially passes the proof of array-view
** to GC (leaks it if GC is unavailable)
*)
castfn
arrayptr_refize
  {a:vt0p}
  {l:addr}
  {n:int} (
  A: arrayptr (INV(a), l, n)
) :<!wrt> arrayref (a, n) // end of [arrayptr_refize]

castfn
arrayref_get_viewptr
  {a:vt0p}
  {n:int} (
  A: arrayref (a, n)
) :<> [l:addr] (vbox (array_v (a, l, n)) | ptr l)

(* ****** ****** *)
//
symintr arrayref
//
fun
arrayref_make_arrpsz
  {a:vt0p}{n:int}
  (psz: arrpsz (INV(a), n)):<!wrt> arrayref (a, n) = "mac#%"
overload arrayref with arrayref_make_arrpsz
//
(* ****** ****** *)

fun{a:t0p}
arrayref_make_elt
  {n:int} (asz: size_t n, x: a):<!wrt> arrayref (a, n)
// end of [arrayref_make_elt]

(* ****** ****** *)

fun{
} arrayref_make_intrange
  {l,r:int | l <= r} (l: int l, r: int r):<!wrt> arrayref (int, r-l)
// end of [arrayref_make_intrange]

(* ****** ****** *)

fun{a:t0p}
arrayref_make_list{n:int}
  (asz: int n, xs: list (INV(a), n)):<!wrt> arrayref (a, n)
// end of [arrayref_make_list]

fun{a:t0p}
arrayref_make_rlist{n:int}
  (asz: int n, xs: list (INV(a), n)):<!wrt> arrayref (a, n)
// end of [arrayref_make_rlist]

(* ****** ****** *)
//
// HX-2014-02:
// [A] must survive [arrayref_tail(A)]
// in order to support proper garbage-collection
//
fun{a:t0p}
arrayref_head
  {n:pos} (A: arrayref (a, n)):<!ref> (a) // A[0]
fun{a:t0p}
arrayref_tail
  {n:pos} (A: arrayref (a, n)):<!ref> arrayref (a, n-1)
//
(* ****** ****** *)
//
fun{
a:t0p}{tk:tk
} arrayref_get_at_gint
  {n:int}{i:nat | i < n}
(
  A: arrayref (a, n), i: g1int (tk, i)
) :<!ref> a // end of [arrayref_get_at_gint]
//
fun{
a:t0p}{tk:tk
} arrayref_get_at_guint
  {n:int}{i:nat | i < n}
(
  A: arrayref (a, n), i: g1uint (tk, i)
) :<!ref> a // end of [arrayref_get_at_guint]
//
symintr arrayref_get_at
overload arrayref_get_at with arrayref_get_at_gint of 0
overload arrayref_get_at with arrayref_get_at_guint of 0
//
(* ****** ****** *)
//
fun{
a:t0p}{tk:tk
} arrayref_set_at_gint
  {n:int}{i:nat | i < n} (
  A: arrayref (a, n), i: g1int (tk, i), x: a
) :<!refwrt> void // end of [arrayref_set_at_gint]
//
fun{
a:t0p}{tk:tk
} arrayref_set_at_guint
  {n:int}{i:nat | i < n} (
  A: arrayref (a, n), i: g1uint (tk, i), x: a
) :<!refwrt> void // end of [arrayref_set_at_guint]
//
symintr arrayref_set_at
overload arrayref_set_at with arrayref_set_at_gint of 0
overload arrayref_set_at with arrayref_set_at_guint of 0
//
(* ****** ****** *)

fun{
a:vt0p}{tk:tk
} arrayref_exch_at_gint
  {n:int}{i:nat | i < n} (
  A: arrayref (a, n), i: g1int (tk, i), x: &a >> _
) :<!refwrt> void // end of [arrayref_exch_at_gint]

fun{
a:vt0p}{tk:tk
} arrayref_exch_at_guint
  {n:int}{i:nat | i < n} (
  A: arrayref (a, n), i: g1uint (tk, i), x: &a >> _
) :<!refwrt> void // end of [arrayref_exch_at_guint]

symintr arrayref_exch_at
overload arrayref_exch_at with arrayref_exch_at_gint of 0
overload arrayref_exch_at with arrayref_exch_at_guint of 0

(* ****** ****** *)

fun{a:vt0p}
arrayref_interchange
  {n:int} (A: arrayref (a, n), i: sizeLt n, j: sizeLt n):<!refwrt> void
// end of [arrayref_interchange]

(* ****** ****** *)

fun{a:vt0p}
arrayref_subcirculate
  {n:int} (A: arrayref (a, n), i: sizeLt n, j: sizeLt n):<!refwrt> void
// end of [arrayref_subcirculate]

(* ****** ****** *)

(*
fun{}
fprint_array$sep (out: FILEref): void
*)
fun{a:vt0p}
fprint_arrayref
  {n:int} (
  out: FILEref, A: arrayref (INV(a), n), n: size_t n
) : void // end of [fprint_arrayref]
fun{a:vt0p}
fprint_arrayref_sep
  {n:int} (
  out: FILEref
, A: arrayref (a, n), asz: size_t n, sep: NSH(string)
) : void // end of [fprint_arrayref_sep]

(* ****** ****** *)

fun{a:t0p}
arrayref_copy{n:int}
  (A: arrayref (a, n), n: size_t (n)): arrayptr (a, n)
// end of [arrayref_copy]

(* ****** ****** *)
//
(*
fun{a:vt0p}
array_tabulate$fopr (index: size_t): (a)
*)
fun{a:vt0p}
arrayref_tabulate
  {n:int} (asz: size_t n): arrayref (a, n)
//
fun{a:vt0p}
arrayref_tabulate_cloref
  {n:int} (size_t n, (sizeLt(n)) -<cloref> a): arrayref (a, n)
//
(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_foreach$cont (x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_foreach$fwork (x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayref_foreach{n:int} (
  A: arrayref (a, n), asz: size_t (n)
) : sizeLte(n) // end of [arrayref_foreach]
fun{
a:vt0p}{env:vt0p
} arrayref_foreach_env{n:int} (
  A: arrayref (a, n), asz: size_t (n), env: &(env)>>env
) : sizeLte(n) // end of [arrayref_foreach_env]

(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_iforeach$cont (i: size_t, x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_iforeach$fwork (i: size_t, x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayref_iforeach{n:int} (
  A: arrayref (INV(a), n), asz: size_t (n)
) : sizeLte(n) // end of [arrayref_iforeach]
fun{
a:vt0p}{env:vt0p
} arrayref_iforeach_env{n:int} (
  A: arrayref (INV(a), n), asz: size_t (n), env: &(env)>>env
) : sizeLte(n) // end of [arrayref_iforeach_env]

(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_rforeach$cont (x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_rforeach$fwork (x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayref_rforeach{n:int} (
  A: arrayref (a, n), asz: size_t (n)
) : sizeLte(n) // end of [arrayref_rforeach]
fun{
a:vt0p}{env:vt0p
} arrayref_rforeach_env{n:int} (
  A: arrayref (a, n), asz: size_t (n), env: &(env)>>env
) : sizeLte(n) // end of [arrayref_rforeach_env]

(* ****** ****** *)
//
fun
{a:vt0p}
arrayref_quicksort
  {n:int}(A: arrayref(a, n), asz: size_t(n)): void
//
(* ****** ****** *)
//
// arrszref: a reference to an array with size information attached
//
(* ****** ****** *)

#if(0)
//
// HX-2013-06:
// it is declared in [basic_dyn.sats]
//
abstype
arrszref_vt0ype_type (a: vt@ype) = ptr
stadef arrszref = arrszref_vt0ype_type
//
#endif

(* ****** ****** *)

symintr arrszref

(* ****** ****** *)

fun{}
arrszref_make_arrpsz
  {a:vt0p}{n:int}
  (arrpsz (INV(a), n)):<!wrt> arrszref(a)
//
overload arrszref with arrszref_make_arrpsz
//
(* ****** ****** *)

fun{}
arrszref_make_arrayref
  {a:vt0p}{n:int}
  (A: SHR(arrayref(a, n)), n: size_t n):<!wrt> arrszref (a)
// end of [arrszref_make_arrayref]

(* ****** ****** *)

fun{
} arrszref_get_ref{a:vt0p} (A: arrszref (a)):<> Ptr1
fun{
} arrszref_get_size{a:vt0p} (A: arrszref (a)):<> size_t

(* ****** ****** *)

fun{}
arrszref_get_refsize{a:vt0p}
  (A: arrszref (a), asz: &size_t? >> size_t n):<!wrt> #[n:nat] arrayref (a, n)
// end of [arrszref_get_refsize]

(* ****** ****** *)

fun{a:t0p}
arrszref_make_elt (asz: size_t, x: a):<!wrt> arrszref (a)
// end of [arrszref_make_elt]

(* ****** ****** *)

fun{a:t0p}
arrszref_make_list (xs: List (INV(a))):<!wrt> arrszref (a)
// end of [arrszref_make_list]

fun{a:t0p}
arrszref_make_rlist (xs: List (INV(a))):<!wrt> arrszref (a)
// end of [arrszref_make_rlist]

(* ****** ****** *)

(*
fun{}
fprint_array$sep (out: FILEref): void
*)
fun{a:vt0p}
fprint_arrszref
  (out: FILEref, A: arrszref (a)): void
// end of [fprint_arrszref]
fun{a:vt0p}
fprint_arrszref_sep (
  out: FILEref, A: arrszref (a), sep: NSH(string)
) : void // end of [fprint_arrszref_sep]

(* ****** ****** *)
//
fun{a:t0p}
arrszref_get_at_size
  (A: arrszref (a), i: size_t):<!exnref> a
//
fun{
a:t0p}{tk:tk
} arrszref_get_at_gint
  (A: arrszref (a), i: g0int (tk)):<!exnref> a
//
fun{
a:t0p}{tk:tk
} arrszref_get_at_guint
  (A: arrszref (a), i: g0uint (tk)):<!exnref> a
//
symintr arrszref_get_at
overload arrszref_get_at with arrszref_get_at_gint of 0
overload arrszref_get_at with arrszref_get_at_guint of 0
//
(* ****** ****** *)
//
fun{a:t0p}
arrszref_set_at_size
  (A: arrszref (a), i: size_t, x: a):<!exnrefwrt> void
//
fun{
a:t0p}{tk:tk
} arrszref_set_at_gint
  (A: arrszref (a), i: g0int (tk), x: a):<!exnrefwrt> void
//
fun{
a:t0p}{tk:tk
} arrszref_set_at_guint
  (A: arrszref (a), i: g0uint (tk), x: a):<!exnrefwrt> void
//
symintr arrszref_set_at
overload arrszref_set_at with arrszref_set_at_gint of 0
overload arrszref_set_at with arrszref_set_at_guint of 0
//
(* ****** ****** *)

fun{a:vt0p}
arrszref_exch_at_size
  (A: arrszref (a), i: size_t, x: &a >> _):<!exnrefwrt> void
// end of [arrszref_exch_at_size]

fun{
a:vt0p}{tk:tk
} arrszref_exch_at_gint
  (A: arrszref (a), i: g0int (tk), x: &a >> _):<!exnrefwrt> void
// end of [arrszref_exch_at_gint]

fun{
a:vt0p}{tk:tk
} arrszref_exch_at_guint
  (A: arrszref (a), i: g0uint (tk), x: &a >> _):<!exnrefwrt> void
// end of [arrszref_exch_at_guint]

symintr arrszref_exch_at
overload arrszref_exch_at with arrszref_exch_at_gint of 0
overload arrszref_exch_at with arrszref_exch_at_guint of 0

(* ****** ****** *)

fun{a:vt0p}
arrszref_interchange
  (A: arrszref (a), i: size_t, j: size_t):<!exnrefwrt> void
// end of [arrszref_interchange]

(* ****** ****** *)

fun{a:vt0p}
arrszref_subcirculate
  (A: arrszref (a), i: size_t, j: size_t):<!exnrefwrt> void
// end of [arrszref_subcirculate]

(* ****** ****** *)
//
(*
fun{a:vt0p}
array_tabulate$fopr (index: size_t): (a)
*)
fun{a:vt0p}
arrszref_tabulate (asz: size_t): arrszref (a)
//
fun{a:vt0p}
arrszref_tabulate_cloref
  {n:int} (size_t n, (sizeLt(n)) -<cloref> a): arrszref (a)
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with arrayref_get_at_gint of 0
overload [] with arrayref_get_at_guint of 0
overload [] with arrayref_set_at_gint of 0
overload [] with arrayref_set_at_guint of 0
overload [] with arrszref_get_at_gint of 0
overload [] with arrszref_get_at_guint of 0
overload [] with arrszref_set_at_gint of 0
overload [] with arrszref_set_at_guint of 0

(* ****** ****** *)

overload .head with arrayref_head
overload .tail with arrayref_tail

(* ****** ****** *)

overload .size with arrszref_get_size

(* ****** ****** *)

overload fprint with fprint_arrayref
overload fprint with fprint_arrayref_sep
overload fprint with fprint_arrszref
overload fprint with fprint_arrszref_sep

(* ****** ****** *)

overload ptrcast with arrayref2ptr

(* ****** ****** *)

(* end of [arrayref.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/tuple.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

typedef tup2
  (a0:t0p, a1:t0p) = @(a0, a1)
stadef tup = tup2
typedef tup3
  (a0:t0p, a1:t0p, a2:t0p) = @(a0, a1, a2)
stadef tup = tup3
typedef tup4
  (a0:t0p, a1:t0p, a2:t0p, a3:t0p) = @(a0, a1, a2, a3)
stadef tup = tup4

(* ****** ****** *)

fun{} fprint_tup$beg (out: FILEref): void
fun{} fprint_tup$end (out: FILEref): void
fun{} fprint_tup$sep (out: FILEref): void

(* ****** ****** *)

fun{
a0,a1:t0p
} fprint_tupval2 (out: FILEref, x: @(a0, a1)): void
fun{
a0,a1,a2:t0p
} fprint_tupval3 (out: FILEref, x: @(a0, a1, a2)): void
fun{
a0,a1,a2,a3:t0p
} fprint_tupval4 (out: FILEref, x: @(a0, a1, a2, a3)): void

(* ****** ****** *)

fun{
a0,a1:vt0p
} fprint_tupref2 (out: FILEref, x: &(a0, a1)): void
fun{
a0,a1,a2:vt0p
} fprint_tupref3 (out: FILEref, x: &(a0, a1, a2)): void
fun{
a0,a1,a2,a3:vt0p
} fprint_tupref4 (out: FILEref, x: &(a0, a1, a2, a3)): void

(* ****** ****** *)

fun{
a0,a1:t0p
} tupval2_compare
  (x: @(a0, a1), y: @(a0, a1)):<> int
// end of [tupval2_compare]

fun{
a0,a1,a2:t0p
} tupval3_compare
  (x: @(a0, a1, a2), y: @(a0, a1, a2)):<> int
// end of [tupval3_compare]

fun{
a0,a1,a2,a3:t0p
} tupval4_compare
  (x: @(a0, a1, a2, a3), y: @(a0, a1, a2, a3)):<> int
// end of [tupval4_compare]

(* ****** ****** *)

fun{
a0,a1:vt0p
} tupref2_compare
  (x: &(a0, a1), y: &(a0, a1)):<> int
// end of [tupref2_compare]

fun{
a0,a1,a2:vt0p
} tupref3_compare
  (x: &(a0, a1, a2), y: &(a0, a1, a2)):<> int
// end of [tupref3_compare]

fun{
a0,a1,a2,a3:vt0p
} tupref4_compare
  (x: &(a0, a1, a2, a3), y: &(a0, a1, a2, a3)):<> int
// end of [tupref4_compare]

(* ****** ****** *)

(* end of [tuple.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/list_vt.atxt
** Time of generation: Sat Oct 17 15:19:48 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

#if(0)
//
// HX: these decls are available in [basic_dyn.sats]
//
datavtype // vt@ype+: covariant
list_vt0ype_int_vtype (a:vt@ype+, int) =
  | {n:int | n >= 0}
    list_vt_cons (a, n+1) of (a, list_vt0ype_int_vtype (a, n))
  | list_vt_nil (a, 0) of ((*void*))
// end of [list_vt0ype_int_vtype]
//
stadef list_vt = list_vt0ype_int_vtype
vtypedef
List_vt (a:vt0p) = [n:int] list_vt (a, n)
vtypedef
List0_vt (a:vt0p) = [n:int | n >= 0] list_vt (a, n)
vtypedef
List1_vt (a:vt0p) = [n:int | n >= 1] list_vt (a, n)
vtypedef listLt_vt
  (a:vt0p, n:int) = [k:nat | k < n] list_vt (a, k)
vtypedef listLte_vt
  (a:vt0p, n:int) = [k:nat | k <= n] list_vt (a, k)
vtypedef listGt_vt
  (a:vt0p, n:int) = [k:int | k > n] list_vt (a, k)
vtypedef listGte_vt
  (a:vt0p, n:int) = [k:int | k >= n] list_vt (a, k)
vtypedef listBtw_vt
  (a:vt0p, m:int, n:int) = [k:int | m <= k; k < n] list_vt (a, k)
vtypedef listBtwe_vt
  (a:vt0p, m:int, n:int) = [k:int | m <= k; k <= n] list_vt (a, k)
//
#endif

(* ****** ****** *)

#define nil_vt list_vt_nil
#define cons_vt list_vt_cons

(* ****** ****** *)

prfun
lemma_list_vt_param
  {x:vt0p}{n:int}
  (xs: !list_vt (INV(x), n)): [n >= 0] void
// end of [lemma_list_vt_param]

(* ****** ****** *)

castfn
list_vt_cast
  {x:vt0p}{n:int}
  (xs: list_vt (INV(x), n)):<> list_vt (x, n)
// end of [list_vt_cast]

(* ****** ****** *)

#define list_vt_sing(x)
  list_vt_cons(x, list_vt_nil())
#define list_vt_pair(x1, x2)
  list_vt_cons(x1, list_vt_cons (x2, list_vt_nil()))

(* ****** ****** *)

fun{x:vt0p}
list_vt_make_sing (x: x):<!wrt> list_vt (x, 1)
fun{x:vt0p}
list_vt_make_pair (x1: x, x2: x):<!wrt> list_vt (x, 2)

(* ****** ****** *)
//
fun{x:vt0p}
print_list_vt (xs: !List_vt (INV(x))): void
fun{x:vt0p}
prerr_list_vt (xs: !List_vt (INV(x))): void
//
fun{x:vt0p}
fprint_list_vt
  (out: FILEref, xs: !List_vt (INV(x))): void
fun{} fprint_list_vt$sep (out: FILEref): void
//
fun{x:vt0p}
fprint_list_vt_sep (
  out: FILEref, xs: !List_vt (INV(x)), sep: NSH(string)
) : void // end of [fprint_list_vt_sep]
//
(* ****** ****** *)
//
fun{x:vt0p}
list_vt_is_nil
  {n:int} (xs: !list_vt (INV(x), n)):<> bool (n==0)
//
fun{x:vt0p}
list_vt_is_cons
  {n:int} (xs: !list_vt (INV(x), n)):<> bool (n > 0)
//
(* ****** ****** *)

fun{x:vt0p}
list_vt_is_sing
  {n:int} (xs: !list_vt (INV(x), n)):<> bool (n==1)
// end of [list_vt_is_sing]

fun{x:vt0p}
list_vt_is_pair
  {n:int} (xs: !list_vt (INV(x), n)):<> bool (n==2)
// end of [list_vt_is_pair]

(* ****** ****** *)

fun{}
list_vt_unnil{x:vt0p} (xs: list_vt (x, 0)):<> void

(* ****** ****** *)

fun{x:vt0p}
list_vt_uncons{n:pos}
  (xs: &list_vt (INV(x), n) >> list_vt (x, n-1)):<!wrt> x
// end of [list_vt_uncons]

(* ****** ****** *)

fun{x:vt0p}
list_vt_length{n:int} (xs: !list_vt (INV(x), n)):<> int n

(* ****** ****** *)

fun{x:vt0p}
list_vt_getref_at
  {n:int}{i:nat | i <= n}
  (xs: &list_vt (INV(x), n), i: int i):<> cPtr1 (list_vt (x, n-i))
// end of [list_vt_getref_at]

(* ****** ****** *)
//
fun{x:t0p}
list_vt_get_at{n:int}
  (xs: !list_vt (INV(x), n), i: natLt n):<> x
//
fun{x:t0p}
list_vt_set_at{n:int}
  (xs: !list_vt (INV(x), n), i: natLt n, x: x):<!wrt> void
//
(* ****** ****** *)

fun{x:vt0p}
list_vt_exch_at{n:int}
  (xs: !list_vt (INV(x), n), i: natLt n, x: &x >> _):<!wrt> void
// end of [list_vt_exch_at]

(* ****** ****** *)

fun{x:vt0p}
list_vt_insert_at{n:int}
(
  xs: &list_vt (INV(x), n) >> list_vt (x, n+1), i: natLte n, x: x
) :<!wrt> void // end of [list_vt_insert_at]

fun{x:vt0p}
list_vt_takeout_at{n:int}
  (xs: &list_vt (INV(x), n) >> list_vt (x, n-1), i: natLt n):<!wrt> x
// end of [list_vt_takeout_at]

(* ****** ****** *)

fun{x:t0p}
list_vt_copy{n:int}
  (xs: !list_vt (INV(x), n)):<!wrt> list_vt (x, n)
// end of [list_vt_copy]

(* ****** ****** *)
//
fun{x:vt0p}
list_vt_copylin{n:int}
  (xs: !list_vt (INV(x), n)):<!wrt> list_vt (x, n)
fun{x:vt0p}
list_vt_copylin$copy (x: &RD(x)): (x)
//
fun{x:vt0p}
list_vt_copylin_fun{n:int}{fe:eff}
  (xs: !list_vt (INV(x), n), f: (&RD(x)) -<fe> x):<!wrt,fe> list_vt (x, n)
//
(* ****** ****** *)

fun{x:t0p}
list_vt_free (xs: List_vt (INV(x))):<!wrt> void

(* ****** ****** *)
//
fun{x:vt0p}
list_vt_freelin
  (xs: List_vt (INV(x))):<!wrt> void
fun{x:vt0p}
list_vt_freelin$clear (x: &x >> x?):<!wrt> void
//
fun{x:vt0p}
list_vt_freelin_fun{fe:eff}
  (xs: List_vt (INV(x)), f: (&x>>x?) -<fe> void):<!wrt,fe> void
//
(* ****** ****** *)
//
fun{
x:vt0p
} list_vt_uninitize
  {n:int} (
  xs: !list_vt (INV(x), n) >> list_vt (x?, n)
) :<!wrt> void // end of [list_vt_uninitize]
//
fun{x:vt0p}
list_vt_uninitize$clear (x: &(x) >> x?):<!wrt> void
//
fun{
x:vt0p
} list_vt_uninitize_fun
  {n:int}{fe:eff}
(
  xs: !list_vt (INV(x), n) >> list_vt (x?, n), f: (&x>>x?) -<fe> void
) :<!wrt,fe> void // end of [list_vt_uninitize_fun]
//
(* ****** ****** *)

fun{
a:vt0p
} list_vt_append
  {n1,n2:int} (
  xs1: list_vt (INV(a), n1), xs2: list_vt (a, n2)
) :<!wrt> list_vt (a, n1+n2) // endfun

(* ****** ****** *)

fun{
x:vt0p
} list_vt_extend{n:int}
  (xs1: list_vt (INV(x), n), x2: x):<!wrt> list_vt (x, n+1)
// end of [list_vt_extend]

fun{x:vt0p}
list_vt_unextend{n:pos}
  (xs: &list_vt (INV(x), n) >> list_vt (x, n-1)):<!wrt> (x)
// end of [list_vt_unextend]

(* ****** ****** *)

macdef list_vt_snoc = list_vt_extend
macdef list_vt_unsnoc = list_vt_unextend

(* ****** ****** *)

fun{x:vt0p}
list_vt_reverse{n:int}
  (xs: list_vt (INV(x), n)):<!wrt> list_vt (x, n)
// end of [list_vt_reverse]

fun{a:vt0p}
list_vt_reverse_append{m,n:int}
  (list_vt (INV(a), m), list_vt (a, n)):<!wrt> list_vt (a, m+n)
// end of [list_vt_reverse_append]

(* ****** ****** *)

fun{x:vt0p}
list_vt_split_at
  {n:int}{i:nat | i <= n}
  (list_vt (INV(x), n), int i):<!wrt> (list_vt (x, i), list_vt (x, n-i))
// end of [list_vt_split_at]

(* ****** ****** *)

fun{x:vt0p}
list_vt_concat
  (xss: List_vt (List_vt (INV(x)))):<!wrt> List0_vt (x)
// end of [list_vt_concat]

(* ****** ****** *)

fun{x:vt0p}
list_vt_separate{n:int}
(
  xs: &list_vt (INV(x), n) >> list_vt (x, n1)
) : #[n1:nat|n1 <= n] list_vt (x, n-n1)

fun{x:vt0p}
list_vt_separate$pred (x: &RD(x)): bool

(* ****** ****** *)

fun{x:t0p}
list_vt_filter{n:int}
  (x: list_vt (INV(x), n)):<!wrt> listLte_vt (x, n)
// end of [list_vt_filter]

fun{x:t0p}
list_vt_filter$pred (x: &RD(x)):<> bool

(* ****** ****** *)
//
fun{x:vt0p}
list_vt_filterlin
  {n:int} (list_vt (INV(x), n)):<!wrt> listLte_vt (x, n)
//
fun{x:vt0p}
list_vt_filterlin$pred (x: &RD(x)):<> bool
fun{x:vt0p}
list_vt_filterlin$clear (x: &x >> x?):<!wrt> void
//
(* ****** ****** *)

fun{x:vt0p}
list_vt_app (xs: !List_vt (INV(x))): void
fun{x:vt0p}
list_vt_app$fwork (x: &x >> _): void

(* ****** ****** *)

fun{x:vt0p}
list_vt_appfree (xs: List_vt (INV(x))): void
fun{x:vt0p}
list_vt_appfree$fwork (x: &x >> x?): void

(* ****** ****** *)
//
fun{
x:vt0p}{y:vt0p
} list_vt_map{n:int}
(
  xs: !list_vt (INV(x), n)
) : list_vt (y, n)
//
fun{
x:vt0p}{y:vt0p
} list_vt_map$fopr (x: &x >> _): (y)
//
(* ****** ****** *)

fun{
x:vt0p}{y:vt0p
} list_vt_map_fun{n:int}
  (xs: !list_vt (INV(x), n), f: (&x) -<fun1> y): list_vt(y, n)
fun{
x:vt0p}{y:vt0p
} list_vt_map_clo{n:int}
  (xs: !list_vt (INV(x), n), f: &(&x) -<clo1> y): list_vt(y, n)
fun{
x:vt0p}{y:vt0p
} list_vt_map_cloref{n:int}
  (xs: !list_vt (INV(x), n), f: (&x) -<cloref1> y): list_vt(y, n)

(* ****** ****** *)
//
fun{
x:vt0p}{y:vt0p
} list_vt_mapfree{n:int}
(
  xs: list_vt (INV(x), n)
) : list_vt (y, n)
//
fun{
x:vt0p}{y:vt0p
} list_vt_mapfree$fopr (x: &(x) >> x?): (y)
//
(* ****** ****** *)

fun{
x:vt0p}{y:vt0p
} list_vt_mapfree_fun{n:int}
  (xs: list_vt (INV(x), n), f: (&x>>_?) -<fun1> y): list_vt(y, n)
fun{
x:vt0p}{y:vt0p
} list_vt_mapfree_clo{n:int}
  (xs: list_vt (INV(x), n), f: &(&x>>_?) -<clo1> y): list_vt(y, n)
fun{
x:vt0p}{y:vt0p
} list_vt_mapfree_cloref{n:int}
  (xs: list_vt (INV(x), n), f: (&x>>_?) -<cloref1> y): list_vt(y, n)

(* ****** ****** *)
//
fun{
x:vt0p
} list_vt_foreach (xs: !List_vt (INV(x))): void
//
fun{
x:vt0p}{env:vt0p
} list_vt_foreach_env (xs: !List_vt (INV(x)), env: &(env) >> _): void
//
fun{
x:vt0p}{env:vt0p
} list_vt_foreach$cont (x: &x, env: &env): bool
fun{
x:vt0p}{env:vt0p
} list_vt_foreach$fwork (x: &x >> _, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
x:vt0p
} list_vt_foreach_fun
  {fe:eff} (
  xs: !List_vt (INV(x)), f: (&x) -<fe> void
) :<fe> void // end of [list_vt_foreach_fun]
fun{
x:vt0p
} list_vt_foreach_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v
| xs: !List_vt (INV(x)), f: (!v | &x, !vt) -<fe> void, env: !vt
) :<fe> void // end of [list_vt_foreach_funenv]

(* ****** ****** *)
//
fun{
x:vt0p
} list_vt_iforeach
  {n:int} (xs: !list_vt (INV(x), n)): natLte(n)
//
fun{
x:vt0p}{env:vt0p
} list_vt_iforeach_env
  {n:int} (xs: !list_vt (INV(x), n), env: &(env) >> _): natLte(n)
//
fun{
x:vt0p}{env:vt0p
} list_vt_iforeach$cont
  (i: intGte(0), x: &x, env: &env): bool
fun{
x:vt0p}{env:vt0p
} list_vt_iforeach$fwork
  (i: intGte(0), x: &x >> _, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{
a:vt0p
} list_vt_mergesort
  {n:int} (xs: list_vt (INV(a), n)):<!wrt> list_vt (a, n)
fun{
a:vt0p
} list_vt_mergesort$cmp (x1: &RD(a), x2: &RD(a)):<> int(*sgn*)
//
fun{
a:vt0p
} list_vt_mergesort_fun
  {n:int} (
  xs: list_vt (INV(a), n), cmp: cmpref (a)
) :<!wrt> list_vt (a, n) // end of [list_vt_mergesort_fun]
//
(* ****** ****** *)
//
fun{
a:vt0p
} list_vt_quicksort
  {n:int} (xs: list_vt (INV(a), n)):<!wrt> list_vt (a, n)
fun{
a:vt0p
} list_vt_quicksort$cmp (x1: &RD(a), x2: &RD(a)):<> int(*sgn*)
//
fun{
a:vt0p
} list_vt_quicksort_fun
  {n:int} (
  xs: list_vt (INV(a), n), cmp: cmpref (a)
) :<!wrt> list_vt (a, n) // end of [list_vt_quicksort_fun]
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)
//
overload [] with list_vt_get_at
overload [] with list_vt_set_at
//
overload iseqz with list_vt_is_nil
overload isneqz with list_vt_is_cons
//
overload length with list_vt_length
//
overload copy with list_vt_free
overload free with list_vt_free
//
overload print with print_list_vt
overload prerr with prerr_list_vt
overload fprint with fprint_list_vt
overload fprint with fprint_list_vt_sep
//
(* ****** ****** *)

(* end of [list_vt.sats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/list.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_LIST
#define ATSLIB_PRELUDE_CATS_LIST

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_LIST

/* ****** ****** */

/* end of [list.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/strptr.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_STRPTR
#define ATSLIB_PRELUDE_CATS_STRPTR

/* ****** ****** */
//
// [string.h]
//
extern
int // (sign)
strcmp (const char *x1, const char *x2) ;

/* ****** ****** */

#define atspre_strptr_null() atsptr_null

/* ****** ****** */

#define atspre_strptr_free atspre_mfree_gc
#define atspre_strnptr_free atspre_mfree_gc

/* ****** ****** */

ATSinline()
atstype_int
atspre_compare_strptr_strptr
(
  atstype_strptr x1, atstype_strptr x2
) {
  if (x1==0) {
    return (x2==0 ? 0 : -1) ;
  } else {
    return (x2==0 ? 1 : strcmp((char*)x1, (char*)x2)) ;
  } // end of [if]
} // end of [atspre_compare_strptr_strptr]

/* ****** ****** */

#define atspre_eq_strptr_string atspre_eq_string_string 
#define atspre_neq_strptr_string atspre_neq_string_string 
#define atspre_compare_strptr_string atspre_compare_string_string 

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_STRPTR

/* ****** ****** */

/* end of [strptr.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/basics.atxt
** Time of generation: Sat Oct 17 15:20:01 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_BASICS
#define ATSLIB_PRELUDE_CATS_BASICS

/* ****** ****** */

#include <stdio.h>
#include <stdlib.h>

/* ****** ****** */

ATSinline()
atstype_int
atspre_lor_int_int
(
  atstype_int x1
, atstype_int x2
) {
  return ((x1)|(x2)) ;
} /* [atspre_lor_int_int] */

ATSinline()
atstype_int
atspre_land_int_int
(
  atstype_int x1
, atstype_int x2
) {
  return ((x1)&(x2)) ;
} /* [atspre_land_int_int] */

ATSinline()
atstype_int
atspre_lxor_int_int
(
  atstype_int x1
, atstype_int x2
) {
  return ((x1)^(x2)) ;
} /* [atspre_lxor_int_int] */

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_cloptr_free
(
  atstype_cloptr pclo
) {
  ATS_MFREE (pclo) ; return ;
} /* [atspre_cloptr_free] */

/* ****** ****** */

ATSinline()
atstype_string
atspre_argv_get_at
(
  atstype_arrptr argv, atstype_int i
)
{
  return (((atstype_string*)argv)[i]) ;
} /* end of [atspre_argv_get_at] */

ATSinline()
atsvoid_t0ype
atspre_argv_set_at
(
  atstype_arrptr argv
, atstype_int i, atstype_string x
)
{
  ((atstype_string*)argv)[i] = x ; return ;
} /* end of [atspre_argv_set_at] */

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_exit
 (atstype_int ecode) { exit(ecode) ; return ; }
// end of [atspre_exit]

ATSinline()
atsvoid_t0ype
atspre_exit_errmsg
(
  atstype_int ecode, atstype_string msg
)
{
  fprintf(stderr, "exit(ATS): %s", (char*)msg); exit(ecode); return;
} // end of [atspre_exit_errmsg]

/* ****** ****** */

#define atspre_exit_void atspre_exit
#define atspre_exit_errmsg_void atspre_exit_errmsg

/* ****** ****** */
//
ATSinline()
atsvoid_t0ype
atspre_assert_bool
  (atstype_bool b)
{
  if (!b) exit(1) ; return ;
} /* endfun */
//
#define atspre_assert_bool0 atspre_assert_bool
#define atspre_assert_bool1 atspre_assert_bool
//
/* ****** ****** */
//
ATSinline()
atsvoid_t0ype
atspre_assert_errmsg_bool
(
  atstype_bool b, atstype_string msg
)
{
  if (!b) {
    fprintf(stderr, "%s", (char*)msg) ; exit(1) ;
  } // end of [if]
  return ;
} /* endfun */
//
#define atspre_assert_errmsg_bool0 atspre_assert_errmsg_bool
#define atspre_assert_errmsg_bool1 atspre_assert_errmsg_bool
//
/* ****** ****** */
//
ATSinline()
atsvoid_t0ype
atspre_assert_errmsg2_bool
(
  atstype_bool b
, atstype_string msg1, atstype_string msg2
)
{
  if (!b) {
    fprintf(stderr, "%s%s", (char*)msg1, (char*)msg2) ; exit(1) ;
  } // end of [if]
  return ;
} /* endfun */
//
#define atspre_assert_errmsg2_bool0 atspre_assert_errmsg2_bool
#define atspre_assert_errmsg2_bool1 atspre_assert_errmsg2_bool
//
/* ****** ****** */
//
ATSinline()
atsvoid_t0ype
atspre_fprint_newline
  (atstype_ref out)
{
  int n ;
  int err = -1 ;
  n = fprintf((FILE*)out, "\n") ;
  if (n > 0) err = fflush((FILE*)out) ;
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_newline] failed.") ; exit(1) ;
  } // end of [if]
  return ;
} /* endfun */
//
#define atspre_print_newline() atspre_fprint_newline(stdout)
#define atspre_prerr_newline() atspre_fprint_newline(stderr)
//
/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_BASICS

/* ****** ****** */

/* end of [basics.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/char.atxt
** Time of generation: Sat Oct 17 15:20:02 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_CHAR
#define ATSLIB_PRELUDE_CATS_CHAR

/* ****** ****** */

#include <ctype.h>

/* ****** ****** */

#ifdef __CYGWIN__
//
#ifndef isascii
extern int isascii (int c) ; // _XOPEN_SOURCE
#endif // end of [isascii]

#ifndef isblank
extern int isblank (int c) ; // _XOPEN_SOURCE >= 600
#endif // end of [isblank]

#ifndef toascii
extern int toascii (int c) ; // _XOPEN_SOURCE
#endif // end of [toascii]
//
#endif // end of [#ifdef(__CYGWIN__)]

/* ****** ****** */
//
ATSinline()
atstype_char
atspre_int2char
  (atstype_int i) { return ((atstype_char)i) ; }
ATSinline()
atstype_schar
atspre_int2schar
  (atstype_int i) { return ((atstype_schar)i) ; }
ATSinline()
atstype_uchar
atspre_int2uchar
  (atstype_int i) { return ((atstype_uchar)i) ; }
//
#define atspre_int2char0 atspre_int2char
#define atspre_int2schar0 atspre_int2schar
#define atspre_int2uchar0 atspre_int2uchar
//
/* ****** ****** */
//
ATSinline()
atstype_int
atspre_char2int
  (atstype_char c) { return ((atstype_int)c) ; }
ATSinline()
atstype_int
atspre_schar2int
  (atstype_schar c) { return ((atstype_int)c) ; }
ATSinline()
atstype_int
atspre_uchar2int
  (atstype_uchar c) { return ((atstype_int)c) ; }
//
#define atspre_char2int0 atspre_char2int
#define atspre_schar2int0 atspre_schar2int
#define atspre_uchar2int0 atspre_uchar2int
//
/* ****** ****** */
//
ATSinline()
atstype_uint
atspre_char2uint
  (atstype_char c) { return ((atstype_uint)c) ; }
ATSinline()
atstype_uint
atspre_schar2uint
  (atstype_schar c) { return ((atstype_uint)c) ; }
ATSinline()
atstype_uint
atspre_uchar2uint
  (atstype_uchar c) { return ((atstype_uint)c) ; }
//
#define atspre_char2uint0 atspre_char2uint
#define atspre_schar2uint0 atspre_schar2uint
#define atspre_uchar2uint0 atspre_uchar2uint
//
/* ****** ****** */
//
ATSinline()
atstype_int
atspre_char2u2int
  (atstype_char c)
  { return ((atstype_int)((atstype_uchar)c)) ; }
ATSinline()
atstype_uint
atspre_char2u2uint
  (atstype_char c)
  { return ((atstype_uint)((atstype_uchar)c)) ; }
//
#define atspre_char2u2int0 atspre_char2u2int
#define atspre_char2u2uint0 atspre_char2u2uint
//
/* ****** ****** */

ATSinline()
atstype_bool
atspre_char_iseqz
  (atstype_char c)
{
  return ((c == 0) ? atsbool_true : atsbool_false) ;
} // end of [atspre_char_iseqz]
#define atspre_char0_iseqz(c) atspre_char_iseqz(c) 
#define atspre_char1_iseqz(c) atspre_char_iseqz(c) 

ATSinline()
atstype_bool
atspre_char_isneqz
  (atstype_char c)
{
  return ((c != 0) ? atsbool_true : atsbool_false) ;
} // end of [atspre_char_isneqz]
#define atspre_char0_isneqz(c) atspre_char_isneqz(c) 
#define atspre_char1_isneqz(c) atspre_char_isneqz(c) 

/* ****** ****** */
//
ATSinline()
atstype_char
atspre_add_char_int
(
  atstype_char c1, atstype_int i2
) { return (c1 + i2) ; }
//
#define atspre_add_char0_int0 atspre_add_char_int
//
/* ****** ****** */
//
ATSinline()
atstype_char
atspre_sub_char_int
(
  atstype_char c1, atstype_int i2
) { return (c1 - i2) ; }
//
#define atspre_sub_char0_int0 atspre_sub_char_int
//
/* ****** ****** */
//
ATSinline()
atstype_int
atspre_sub_char_char
(
  atstype_char c1, atstype_char c2
) { return (c1 - c2) ; }
//
#define atspre_sub_char0_char0 atspre_sub_char_char
//
/* ****** ****** */

ATSinline()
atstype_bool
atspre_lt_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 < i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lt_int_int]
#define atspre_lt_char0_char0 atspre_lt_int_int
#define atspre_lt_char1_char1 atspre_lt_int_int

ATSinline()
atstype_bool
atspre_lte_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 <= i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lte_int_int]
#define atspre_lte_char0_char0 atspre_lte_int_int
#define atspre_lte_char1_char1 atspre_lte_int_int

ATSinline()
atstype_bool
atspre_gt_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 > i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gt_int_int]
#define atspre_gt_char0_char0 atspre_gt_int_int
#define atspre_gt_char1_char1 atspre_gt_int_int

ATSinline()
atstype_bool
atspre_gte_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 >= i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gte_int_int]
#define atspre_gte_char0_char0 atspre_gte_int_int
#define atspre_gte_char1_char1 atspre_gte_int_int

ATSinline()
atstype_bool
atspre_eq_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 == i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_eq_int_int]
#define atspre_eq_char0_char0 atspre_eq_int_int
#define atspre_eq_char1_char1 atspre_eq_int_int

ATSinline()
atstype_bool
atspre_neq_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 != i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_neq_int_int]
#define atspre_neq_char0_char0 atspre_neq_int_int
#define atspre_neq_char1_char1 atspre_neq_int_int


/* ****** ****** */

ATSinline()
atstype_int
atspre_compare_int_int
  (atstype_int i1, atstype_int i2)
{
  return (i1 - i2) ;
} // end of [atspre_compare_int_int]
#define atspre_compare_char0_char0(c1, c2) atspre_compare_int_int(c1, c2)
#define atspre_compare_char1_char1(c1, c2) atspre_compare_int_int(c1, c2)

/* ****** ****** */

#define atspre_eq_char0_int0(c, i) atspre_eq_int_int(c, i)
#define atspre_eq_int0_char0(i, c) atspre_eq_int_int(i, c)
#define atspre_neq_char0_int0(c, i) atspre_neq_int_int(c, i)
#define atspre_neq_int0_char0(i, c) atspre_neq_int_int(i, c)

/* ****** ****** */

#define atspre_compare_char0_int0(c, i) atspre_compare_int_int(c, i)
#define atspre_compare_int0_char0(i, c) atspre_compare_int_int(i, c)

/* ****** ****** */
//
// unsigned characters
//
/* ****** ****** */

ATSinline()
atstype_bool
atspre_lt_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 < c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lt_uchar_uchar]
#define atspre_lt_uchar0_uchar0 atspre_lt_uchar_uchar
#define atspre_lt_uchar1_uchar1 atspre_lt_uchar_uchar

ATSinline()
atstype_bool
atspre_lte_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 <= c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lte_uchar_uchar]
#define atspre_lte_uchar0_uchar0 atspre_lte_uchar_uchar
#define atspre_lte_uchar1_uchar1 atspre_lte_uchar_uchar

ATSinline()
atstype_bool
atspre_gt_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 > c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gt_uchar_uchar]
#define atspre_gt_uchar0_uchar0 atspre_gt_uchar_uchar
#define atspre_gt_uchar1_uchar1 atspre_gt_uchar_uchar

ATSinline()
atstype_bool
atspre_gte_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 >= c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gte_uchar_uchar]
#define atspre_gte_uchar0_uchar0 atspre_gte_uchar_uchar
#define atspre_gte_uchar1_uchar1 atspre_gte_uchar_uchar

ATSinline()
atstype_bool
atspre_eq_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 == c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_eq_uchar_uchar]
#define atspre_eq_uchar0_uchar0 atspre_eq_uchar_uchar
#define atspre_eq_uchar1_uchar1 atspre_eq_uchar_uchar

ATSinline()
atstype_bool
atspre_neq_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 != c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_neq_uchar_uchar]
#define atspre_neq_uchar0_uchar0 atspre_neq_uchar_uchar
#define atspre_neq_uchar1_uchar1 atspre_neq_uchar_uchar


/* ****** ****** */

ATSinline()
atstype_int
atspre_compare_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return ((atstype_int)c1 - (atstype_int)c2) ;
} // end of [atspre_compare_uchar_uchar]
#define atspre_compare_uchar0_uchar0 atspre_compare_uchar_uchar
#define atspre_compare_uchar1_uchar1 atspre_compare_uchar_uchar

/* ****** ****** */

ATSinline()
atstype_bool
atspre_isalpha_int
  (atstype_int c) {
  return (isalpha(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isalpha_int]
#define atspre_isalpha_char(c) atspre_isalpha_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_isalnum_int
  (atstype_int c) {
  return (isalnum(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isalnum_int]
#define atspre_isalnum_char(c) atspre_isalnum_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_isascii_int
  (atstype_int c) {
  return (isascii(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isascii_int]
#define atspre_isascii_char(c) atspre_isascii_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_isblank_int
  (atstype_int c) {
  return (isblank(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isblank_int]
#define atspre_isblank_char(c) atspre_isblank_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_isspace_int
  (atstype_int c) {
  return (isspace(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isspace_int]
#define atspre_isspace_char(c) atspre_isspace_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_iscntrl_int
  (atstype_int c) {
  return (iscntrl(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_iscntrl_int]
#define atspre_iscntrl_char(c) atspre_iscntrl_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_isdigit_int
  (atstype_int c) {
  return (isdigit(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isdigit_int]
#define atspre_isdigit_char(c) atspre_isdigit_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_isxdigit_int
  (atstype_int c) {
  return (isxdigit(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isxdigit_int]
#define atspre_isxdigit_char(c) atspre_isxdigit_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_isgraph_int
  (atstype_int c) {
  return (isgraph(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isgraph_int]
#define atspre_isgraph_char(c) atspre_isgraph_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_isprint_int
  (atstype_int c) {
  return (isprint(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isprint_int]
#define atspre_isprint_char(c) atspre_isprint_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_ispunct_int
  (atstype_int c) {
  return (ispunct(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_ispunct_int]
#define atspre_ispunct_char(c) atspre_ispunct_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_islower_int
  (atstype_int c) {
  return (islower(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_islower_int]
#define atspre_islower_char(c) atspre_islower_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_isupper_int
  (atstype_int c) {
  return (isupper(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isupper_int]
#define atspre_isupper_char(c) atspre_isupper_int((atstype_int)(c))

/* ****** ****** */

#define atspre_toascii toascii

/* ****** ****** */

ATSinline()
atstype_int
atspre_tolower_int
  (atstype_int c) { return tolower(c) ; }
ATSinline()
atstype_char
atspre_tolower_char
  (atstype_char c) { return tolower(c) ; }
//
ATSinline()
atstype_int
atspre_toupper_int
  (atstype_int c) { return toupper(c) ; }
ATSinline()
atstype_char
atspre_toupper_char
  (atstype_char c) { return toupper(c) ; }
//
/* ****** ****** */

ATSinline()
atstype_char
atspre_int2digit
  (atstype_int i) { return ('0' + i) ; }
// end of [atspre_int2digit]
ATSinline()
atstype_char
atspre_int2xdigit
  (atstype_int i) {
  return (i < 10) ? ('0' + i) : ('a' + (i - 10)) ;
} // end of [atspre_int2xdigit]
ATSinline()
atstype_char
atspre_int2xxdigit
  (atstype_int i) {
  return (i < 10) ? ('0' + i) : ('A' + (i - 10)) ;
} // end of [atspre_int2xxdigit]

/* ****** ****** */

ATSinline()
atstype_int
atspre_byte2int (atstype_byte b) { return ((atstype_int)b) ; }
ATSinline()
atstype_byte
atspre_int2byte (atstype_int i) { return ((atstype_byte)i) ; }

ATSinline()
atstype_uint
atspre_byte2uint (atstype_byte b) { return ((atstype_uint)b) ; }
ATSinline()
atstype_byte
atspre_uint2byte (atstype_uint u) { return ((atstype_byte)u) ; }

/* ****** ****** */

#define atspre_byte2int0 atspre_byte2int
#define atspre_int2byte0 atspre_int2byte
#define atspre_byte2uint0 atspre_byte2uint
#define atspre_uint2byte0 atspre_uint2byte

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_CHAR

/* ****** ****** */

/* end of [char.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/memory.atxt
** Time of generation: Sat Oct 17 15:20:02 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_MEMORY
#define ATSLIB_PRELUDE_CATS_MEMORY

/* ****** ****** */

#define atspre_minit_gc ATS_MINIT

/* ****** ****** */

#define atspre_mfree_gc ATS_MFREE

/* ****** ****** */

#define atspre_malloc_gc ATS_MALLOC

/* ****** ****** */

#define atspre_calloc_gc ATS_CALLOC
#define atspre_realloc_gc ATS_REALLOC

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_MEMORY

/* ****** ****** */

/* end of [memory.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/bool.atxt
** Time of generation: Sat Oct 17 15:20:01 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_BOOL
#define ATSLIB_PRELUDE_CATS_BOOL

/* ****** ****** */

ATSinline()
atstype_bool
atspre_int2bool (atstype_int x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
}
#define atspre_int2bool0 atspre_int2bool
#define atspre_int2bool1 atspre_int2bool

/* ****** ****** */

#define atspre_bool2int0(x) x
#define atspre_bool2int1(x) x

/* ****** ****** */

ATSinline()
atstype_bool
atspre_neg_bool
  (atstype_bool b) {
  return (b) ? atsbool_false : atsbool_true ;
} // end of [atspre_neg_bool]
#define atspre_neg_bool0 atspre_neg_bool
#define atspre_neg_bool1 atspre_neg_bool

ATSinline()
atstype_bool
atspre_add_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1) ? atsbool_true : (b2) ;
} // end of [atspre_add_bool_bool]
#define atspre_add_bool0_bool0 atspre_add_bool_bool
#define atspre_add_bool1_bool1 atspre_add_bool_bool

ATSinline()
atstype_bool
atspre_mul_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1) ? (b2) : atsbool_false ;
} // end of [atspre_mul_bool_bool]
#define atspre_mul_bool0_bool0 atspre_mul_bool_bool
#define atspre_mul_bool1_bool1 atspre_mul_bool_bool

/* ****** ****** */

ATSinline()
atstype_bool
atspre_xor_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1) ? (!b2) : (b2) ;
} // end of [atspre_xor_bool_bool]
#define atspre_xor_bool0_bool0 atspre_xor_bool_bool
#define atspre_xor_bool1_bool1 atspre_xor_bool_bool

/* ****** ****** */

ATSinline()
atstype_bool
atspre_lt_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1) ? atsbool_false : (b2) ;
} // end of [atspre_lt_bool_bool]
#define atspre_lt_bool0_bool0 atspre_lt_bool_bool
#define atspre_lt_bool1_bool1 atspre_lt_bool_bool
ATSinline()
atstype_bool
atspre_lte_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1) ? (b2) : atsbool_true ;
} // end of [atspre_lte_bool_bool]
#define atspre_lte_bool0_bool0 atspre_lte_bool_bool
#define atspre_lte_bool1_bool1 atspre_lte_bool_bool

ATSinline()
atstype_bool
atspre_gt_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b2) ? atsbool_false : (b1) ;
} // end of [atspre_gt_bool_bool]
#define atspre_gt_bool0_bool0 atspre_gt_bool_bool
#define atspre_gt_bool1_bool1 atspre_gt_bool_bool
ATSinline()
atstype_bool
atspre_gte_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b2) ? (b1) : atsbool_true ;
} // end of [atspre_gte_bool_bool]
#define atspre_gte_bool0_bool0 atspre_gte_bool_bool
#define atspre_gte_bool1_bool1 atspre_gte_bool_bool

ATSinline()
atstype_bool
atspre_eq_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1 == b2) ;
} // end of [atspre_eq_bool_bool]
#define atspre_eq_bool0_bool0 atspre_eq_bool_bool
#define atspre_eq_bool1_bool1 atspre_eq_bool_bool
ATSinline()
atstype_bool
atspre_neq_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1 != b2) ;
} // end of [atspre_neq_bool_bool]
#define atspre_neq_bool0_bool0 atspre_neq_bool_bool
#define atspre_neq_bool1_bool1 atspre_neq_bool_bool

/* ****** ****** */

ATSinline()
atstype_int
atspre_compare_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1 - b2) ;
} // end of [atspre_compare_bool_bool]
#define atspre_compare_bool0_bool0 atspre_compare_bool_bool
#define atspre_compare_bool1_bool1 atspre_compare_bool_bool

/* ****** ****** */

ATSinline()
atstype_string
atspre_bool2string (
  atstype_bool x
) {
  return (x) ? "true" : "false" ;
} // end of [atspre_bool2string]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_BOOL

/* ****** ****** */

/* end of [bool.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/integer_ptr.atxt
** Time of generation: Sat Oct 17 15:20:02 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_INTEGER_PTR
#define ATSLIB_PRELUDE_CATS_INTEGER_PTR

/* ****** ****** */

#include <stdint.h>

/* ****** ****** */

typedef intptr_t atstype_intptr ;
typedef uintptr_t atstype_uintptr ;

/* ****** ****** */
//
#define atspre_g0int2int_int_intptr(x) ((atstype_intptr)(x))
#define atspre_g0int2int_lint_intptr(x) ((atstype_intptr)(x))
//
#define atspre_g0int2uint_int_uintptr(x) ((atstype_uintptr)(x))
//
#define atspre_g0uint2uint_uint_uintptr(x) ((atstype_uintptr)(x))
#define atspre_g0uint2uint_ulint_uintptr(x) ((atstype_uintptr)(x))
//
/* ****** ****** */
//
#define atspre_g1int2int_int_intptr atspre_g0int2int_int_intptr
#define atspre_g1int2int_lint_intptr atspre_g0int2int_lint_intptr
//
#define atspre_g1int2uint_int_uintptr atspre_g0int2uint_int_uintptr
//
#define atspre_g1uint2uint_uint_uintptr atspre_g0uint2uint_uint_uintptr
#define atspre_g1uint2uint_ulint_uintptr atspre_g0uint2uint_ulint_uintptr
//
/* ****** ****** */

ATSinline()
atstype_intptr
atspre_g0int_neg_intptr
  (atstype_intptr x) { return (-x) ; }
// end of [atspre_g0int_neg_intptr]
ATSinline()
atstype_intptr
atspre_g0int_succ_intptr
  (atstype_intptr x) { return (x + 1) ; }
// end of [atspre_g0int_succ_intptr]
ATSinline()
atstype_intptr
atspre_g0int_pred_intptr
  (atstype_intptr x) { return (x - 1) ; }
// end of [atspre_g0int_pred_intptr]
ATSinline()
atstype_intptr
atspre_g0int_half_intptr
  (atstype_intptr x) { return (x / 2) ; }
// end of [atspre_g0int_half_intptr]
ATSinline()
atstype_intptr
atspre_g0int_add_intptr
  (atstype_intptr x1, atstype_intptr x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_intptr]
ATSinline()
atstype_intptr
atspre_g0int_sub_intptr
  (atstype_intptr x1, atstype_intptr x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_intptr]
ATSinline()
atstype_intptr
atspre_g0int_mul_intptr
  (atstype_intptr x1, atstype_intptr x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_intptr]
ATSinline()
atstype_intptr
atspre_g0int_div_intptr
  (atstype_intptr x1, atstype_intptr x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_intptr]
ATSinline()
atstype_intptr
atspre_g0int_mod_intptr
  (atstype_intptr x1, atstype_intptr x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_intptr]
ATSinline()
atstype_bool
atspre_g0int_isltz_intptr (atstype_intptr x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_intptr]
ATSinline()
atstype_bool
atspre_g0int_isltez_intptr (atstype_intptr x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_intptr]
ATSinline()
atstype_bool
atspre_g0int_isgtz_intptr (atstype_intptr x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_intptr]
ATSinline()
atstype_bool
atspre_g0int_isgtez_intptr (atstype_intptr x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_intptr]
ATSinline()
atstype_bool
atspre_g0int_iseqz_intptr (atstype_intptr x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_intptr]
ATSinline()
atstype_bool
atspre_g0int_isneqz_intptr (atstype_intptr x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_intptr]
ATSinline()
atstype_bool
atspre_g0int_lt_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_intptr]
ATSinline()
atstype_bool
atspre_g0int_lte_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_intptr]
ATSinline()
atstype_bool
atspre_g0int_gt_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_intptr]
ATSinline()
atstype_bool
atspre_g0int_gte_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_intptr]
ATSinline()
atstype_bool
atspre_g0int_eq_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_intptr]
ATSinline()
atstype_bool
atspre_g0int_neq_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_intptr]
//
/* ****** ****** */

ATSinline()
atstype_uintptr
atspre_g0uint_succ_uintptr
  (atstype_uintptr x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_pred_uintptr
  (atstype_uintptr x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_half_uintptr
  (atstype_uintptr x) { return (x >> 1) ; }
// end of [atspre_g0uint_pred_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_add_uintptr
  (atstype_uintptr x1, atstype_uintptr x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_sub_uintptr
  (atstype_uintptr x1, atstype_uintptr x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_mul_uintptr
  (atstype_uintptr x1, atstype_uintptr x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_div_uintptr
  (atstype_uintptr x1, atstype_uintptr x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_mod_uintptr
  (atstype_uintptr x1, atstype_uintptr x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_lsl_uintptr
  (atstype_uintptr x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_lsr_uintptr
  (atstype_uintptr x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_lnot_uintptr
  (atstype_uintptr x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_lor_uintptr
  (atstype_uintptr x, atstype_uintptr y) { return (x | y) ; }
// end of [atspre_g0uint_uintptr_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_land_uintptr
  (atstype_uintptr x, atstype_uintptr y) { return (x & y) ; }
// end of [atspre_g0uint_uintptr_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_lxor_uintptr
  (atstype_uintptr x, atstype_uintptr y) { return (x ^ y) ; }
// end of [atspre_g0uint_uintptr_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uintptr (atstype_uintptr x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uintptr (atstype_uintptr x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uintptr (atstype_uintptr x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_lt_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_lte_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_gt_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_gte_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_eq_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_neq_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uintptr]
//
/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_INTEGER_PTR

/* ****** ****** */

/* end of [integer_ptr.cats] */

/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/matrixptr.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_MATRIXPTR
#define ATSLIB_PRELUDE_CATS_MATRIXPTR

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_matrixptr_free
  (atstype_arrptr ptr) { ATS_MFREE (ptr) ; return ; }
// end of [atspre_matrixptr_free]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_MATRIXPTR

/* ****** ****** */

/* end of [matrixptr.cats] */

/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/fprintf.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2015 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_FPRINTF
#define ATSLIB_PRELUDE_CATS_FPRINTF

/* ****** ****** */
//
// HX-2013-09: declared in [stdio.h]
//
#ifndef fprintf
extern
int fprintf (FILE *stream, const char *format, ...) ;
#endif // end of [ifndef]
//
/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_bool (
  atstype_ref out, atstype_bool x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%s", atspre_bool2string(x)) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_bool] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_bool]
#define atspre_print_bool(x) atspre_fprint_bool(stdout, (x))
#define atspre_prerr_bool(x) atspre_fprint_bool(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_char
(
  atstype_ref out, atstype_char c
) {
  int err = 0 ;
  err += fprintf ((FILE*)out, "%c", c) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_char] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end of [atspre_fprint_char]
#define atspre_print_char(c) atspre_fprint_char(stdout, (c))
#define atspre_prerr_char(c) atspre_fprint_char(stderr, (c))

ATSinline()
atsvoid_t0ype
atspre_fprint_uchar
(
  atstype_ref out, atstype_uchar c
) {
  atspre_fprint_char (out, (atstype_char)c) ; return ;
} // end of [atspre_fprint_uchar]
#define atspre_print_uchar(c) atspre_fprint_uchar(stdout, (c))
#define atspre_prerr_uchar(c) atspre_fprint_uchar(stderr, (c))

ATSinline()
atsvoid_t0ype
atspre_fprint_schar
(
  atstype_ref out, atstype_schar c
) {
  atspre_fprint_char (out, (atstype_char)c) ; return ;
} // end of [atspre_fprint_schar]
#define atspre_print_schar(c) atspre_fprint_schar(stdout, (c))
#define atspre_prerr_schar(c) atspre_fprint_schar(stderr, (c))

/* ****** ****** */
  
ATSinline()
atsvoid_t0ype
atspre_fprint_int
(
  atstype_ref out, atstype_int x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%i", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_int] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_int]
#define atspre_print_int(x) atspre_fprint_int(stdout, (x))
#define atspre_prerr_int(x) atspre_fprint_int(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_lint
(
  atstype_ref out, atstype_lint x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%li", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_lint] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_lint]
#define atspre_print_lint(x) atspre_fprint_lint(stdout, (x))
#define atspre_prerr_lint(x) atspre_fprint_lint(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_llint
(
  atstype_ref out, atstype_llint x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%lli", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_llint] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_llint]
#define atspre_print_llint(x) atspre_fprint_llint(stdout, (x))
#define atspre_prerr_llint(x) atspre_fprint_llint(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_ssize
(
  atstype_ref out, atstype_ssize x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%li", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_ssize] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_ssize]
#define atspre_print_ssize(x) atspre_fprint_ssize(stdout, (x))
#define atspre_prerr_ssize(x) atspre_fprint_ssize(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_uint
(
  atstype_ref out, atstype_uint x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%u", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_uint] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_uint]
#define atspre_print_uint(x) atspre_fprint_uint(stdout, (x))
#define atspre_prerr_uint(x) atspre_fprint_uint(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_ulint
(
  atstype_ref out, atstype_ulint x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%lu", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_ulint] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_ulint]
#define atspre_print_ulint(x) atspre_fprint_ulint(stdout, (x))
#define atspre_prerr_ulint(x) atspre_fprint_ulint(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_ullint
(
  atstype_ref out, atstype_ullint x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%llu", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_ullint] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_ullint]
#define atspre_print_ullint(x) atspre_fprint_ullint(stdout, (x))
#define atspre_prerr_ullint(x) atspre_fprint_ullint(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_size
(
  atstype_ref out, atstype_size x
) {
  int err = 0 ;
  atstype_ulint x2 = x ;
  err += fprintf((FILE*)out, "%lu", x2) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_size] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_size]
#define atspre_print_size(x) atspre_fprint_size(stdout, (x))
#define atspre_prerr_size(x) atspre_fprint_size(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_ptr (
  atstype_ref out, atstype_ptr x
) {
  int err ;
  err = fprintf((FILE*)out, "%p", x) ;
  return ;
} // end [atspre_fprint_ptr]
#define atspre_print_ptr(x) atspre_fprint_ptr(stdout, (x))
#define atspre_prerr_ptr(x) atspre_fprint_ptr(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_float (
  atstype_ref r, atstype_float x
) {
  int err = 0 ;
  err += fprintf((FILE*)r, "%f", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_float] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_float]
#define atspre_print_float(x) atspre_fprint_float(stdout, (x))
#define atspre_prerr_float(x) atspre_fprint_float(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_double (
  atstype_ref r, atstype_double x
) {
  int err = 0 ;
  err += fprintf((FILE*)r, "%f", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_double] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_double]
#define atspre_print_double(x) atspre_fprint_double(stdout, (x))
#define atspre_prerr_double(x) atspre_fprint_double(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_ldouble (
  atstype_ref r, atstype_ldouble x
) {
  int err = 0 ;
  err += fprintf((FILE*)r, "%Lf", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_ldouble] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_ldouble]
#define atspre_print_ldouble(x) atspre_fprint_ldouble(stdout, (x))
#define atspre_prerr_ldouble(x) atspre_fprint_ldouble(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_intptr
(
  atstype_ref r, atstype_intptr x
) {
  int err ;
  err = fprintf((FILE*)r, "%lli", (atstype_llint)x) ;
  return ;
} // end [atspre_fprint_intptr]
#define atspre_print_intptr(x) atspre_fprint_intptr(stdout, (x))
#define atspre_prerr_intptr(x) atspre_fprint_intptr(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_uintptr
(
  atstype_ref r, atstype_uintptr x
) {
  int err ;
  err = fprintf((FILE*)r, "%llu", (atstype_ullint)x) ;
  return ;
} // end [atspre_fprint_uintptr]
#define atspre_print_uintptr(x) atspre_fprint_uintptr(stdout, (x))
#define atspre_prerr_uintptr(x) atspre_fprint_uintptr(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_int8
(
  atstype_ref r, atstype_int8 x
) {
  int err ;
  err = fprintf((FILE*)r, "%i", (atstype_int)x) ;
  return ;
} // end [atspre_fprint_int8]
#define atspre_print_int8(x) atspre_fprint_int8(stdout, (x))
#define atspre_prerr_int8(x) atspre_fprint_int8(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_int16
(
  atstype_ref r, atstype_int16 x
) {
  int err ;
  err = fprintf((FILE*)r, "%i", (atstype_int)x) ;
  return ;
} // end [atspre_fprint_int16]
#define atspre_print_int16(x) atspre_fprint_int16(stdout, (x))
#define atspre_prerr_int16(x) atspre_fprint_int16(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_int32
(
  atstype_ref r, atstype_int32 x
) {
  int err ;
  err = fprintf((FILE*)r, "%li", (atstype_lint)x) ;
  return ;
} // end [atspre_fprint_int32]
#define atspre_print_int32(x) atspre_fprint_int32(stdout, (x))
#define atspre_prerr_int32(x) atspre_fprint_int32(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_int64
(
  atstype_ref r, atstype_int64 x
) {
  int err ;
  err = fprintf((FILE*)r, "%lli", (atstype_llint)x) ;
  return ;
} // end [atspre_fprint_int64]
#define atspre_print_int64(x) atspre_fprint_int64(stdout, (x))
#define atspre_prerr_int64(x) atspre_fprint_int64(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_uint8
(
  atstype_ref r, atstype_uint8 x
) {
  int err ;
  err = fprintf((FILE*)r, "%u", (atstype_uint)x) ;
  return ;
} // end [atspre_fprint_uint8]
#define atspre_print_uint8(x) atspre_fprint_uint8(stdout, (x))
#define atspre_prerr_uint8(x) atspre_fprint_uint8(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_uint16
(
  atstype_ref r, atstype_uint16 x
) {
  int err ;
  err = fprintf((FILE*)r, "%u", (atstype_uint)x) ;
  return ;
} // end [atspre_fprint_uint16]
#define atspre_print_uint16(x) atspre_fprint_uint16(stdout, (x))
#define atspre_prerr_uint16(x) atspre_fprint_uint16(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_uint32
(
  atstype_ref r, atstype_uint32 x
) {
  int err ;
  err = fprintf((FILE*)r, "%lu", (atstype_ulint)x) ;
  return ;
} // end [atspre_fprint_uint32]
#define atspre_print_uint32(x) atspre_fprint_uint32(stdout, (x))
#define atspre_prerr_uint32(x) atspre_fprint_uint32(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_uint64
(
  atstype_ref r, atstype_uint64 x
) {
  int err ;
  err = fprintf((FILE*)r, "%llu", (atstype_ullint)x) ;
  return ;
} // end [atspre_fprint_uint64]
#define atspre_print_uint64(x) atspre_fprint_uint64(stdout, (x))
#define atspre_prerr_uint64(x) atspre_fprint_uint64(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_string
(
  atstype_ref out, atstype_string x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%s", (char*)x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_string] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end of [atspre_fprint_string]
#define atspre_print_string(x) atspre_fprint_string(stdout, (x))
#define atspre_prerr_string(x) atspre_fprint_string(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_substring
(
  atstype_ref out
, atstype_string x
, atstype_size st, atstype_size ln  
) {
  int err = 0 ;
  err += fwrite(((char*)x)+st, 1, ln, out) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_substring] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end of [atspre_fprint_substring]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_stropt
(
  atstype_ref out, atstype_stropt x
) {
  int err = 0 ;
  if (!x)
  {
    err += fprintf((FILE*)out, "strnone()") ;
  } else {
    err += fprintf((FILE*)out, "strsome(%s)", (char*)x) ;
  }
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_stropt] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end of [atspre_fprint_stropt]
#define atspre_print_stropt(x) atspre_fprint_stropt(stdout, (x))
#define atspre_prerr_stropt(x) atspre_fprint_stropt(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_strptr
(
  atstype_ref out, atstype_strptr x
) {
  int err = 0 ;
  if (x != 0) {
    err += fprintf((FILE*)out, "%s", (char*)x) ;
  } else {
    err += fprintf((FILE*)out, "%s", "(strnull)") ;
  } // end of [if]
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_strptr] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end of [atspre_fprint_strptr]
#define atspre_print_strptr(x) atspre_fprint_strptr(stdout, (x))
#define atspre_prerr_strptr(x) atspre_fprint_strptr(stderr, (x))

/* ****** ****** */

#define atspre_fprint_strbuf atspre_fprint_strptr
#define atspre_print_strbuf(x) atspre_fprint_strbuf(stdout, (x))
#define atspre_prerr_strbuf(x) atspre_fprint_strbuf(stderr, (x))

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_FPRINTF

/* ****** ****** */

/* end of [fprintf.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/arrayptr.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_ARRAYPTR
#define ATSLIB_PRELUDE_CATS_ARRAYPTR

/* ****** ****** */

ATSinline()
atstype_arrptr
atspre_arrpsz_get_ptrsize
(
  atstype_arrpsz psz, atstype_ref asz
) {
  *(size_t*)asz = psz.size ; return (psz.ptr) ;
} // en of [atspre_arrpsz_get_ptrsize]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_arrayptr_free
  (atstype_arrptr p0) { ATS_MFREE (p0) ; return ; }
// end of [atspre_arrayptr_free]

/* ****** ****** */

ATSinline()
atstype_arrptr
atspre_arrayptr_make_arrpsz
  (atstype_arrpsz psz) { return (psz).ptr ; }
// end of [atspre_arrayptr_make_arrpsz]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_ARRAYPTR

/* ****** ****** */

/* end of [arrayptr.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/pointer.atxt
** Time of generation: Sat Oct 17 15:20:01 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_POINTER
#define ATSLIB_PRELUDE_CATS_POINTER

/* ****** ****** */

#ifndef memset
extern
void *memset(void *bufp, int c, size_t n) ;
#endif // #ifndef

/* ****** ****** */

ATSinline()
atstype_ptr
atspre_ptr_null () { return (void*)0 ; }

/* ****** ****** */

ATSinline()
atstype_bool
atspre_ptr_is_null
  (atstype_ptr p) {
  return (p == (void*)0) ? atsbool_true : atsbool_false ;
} // end of [atspre_ptr_is_null]
#define atspre_ptr0_is_null atspre_ptr_is_null
#define atspre_ptr1_is_null atspre_ptr_is_null

ATSinline()
atstype_bool
atspre_ptr_isnot_null
  (atstype_ptr p) {
  return (p != (void*)0) ? atsbool_true : atsbool_false ;
} // end of [atspre_ptr_isnot_null]
#define atspre_ptr0_isnot_null atspre_ptr_isnot_null
#define atspre_ptr1_isnot_null atspre_ptr_isnot_null

/* ****** ****** */

ATSinline()
atstype_ptr
atspre_add_ptr_bsz
  (atstype_ptr p, atstype_size ofs) { return ((char*)p + ofs) ; }
// end of [atspre_add_ptr_bsz]
#define atspre_add_ptr0_bsz atspre_add_ptr_bsz
#define atspre_add_ptr1_bsz atspre_add_ptr_bsz

ATSinline()
atstype_ptr
atspre_sub_ptr_bsz
  (atstype_ptr p, atstype_size ofs) { return ((char*)p - ofs) ; }
// end of [atspre_sub_ptr_bsz]
#define atspre_sub_ptr0_bsz atspre_sub_ptr_bsz
#define atspre_sub_ptr1_bsz atspre_sub_ptr_bsz

/* ****** ****** */

ATSinline()
atstype_ssize
atspre_sub_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) { return ((char*)p1 - (char*)p2) ; }
// end of [atspre_sub_ptr_ptr]
#define atspre_sub_ptr0_ptr0 atspre_sub_ptr_ptr
#define atspre_sub_ptr1_ptr1 atspre_sub_ptr_ptr

/* ****** ****** */

ATSinline()
atstype_bool
atspre_lt_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 < p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lt_ptr_ptr]
#define atspre_lt_ptr0_ptr0 atspre_lt_ptr_ptr
#define atspre_lt_ptr1_ptr1 atspre_lt_ptr_ptr

ATSinline()
atstype_bool
atspre_lte_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 <= p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lte_ptr_ptr]
#define atspre_lte_ptr0_ptr0 atspre_lte_ptr_ptr
#define atspre_lte_ptr1_ptr1 atspre_lte_ptr_ptr

ATSinline()
atstype_bool
atspre_gt_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 > p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gt_ptr_ptr]
#define atspre_gt_ptr0_ptr0 atspre_gt_ptr_ptr
#define atspre_gt_ptr1_ptr1 atspre_gt_ptr_ptr

ATSinline()
atstype_bool
atspre_gte_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 >= p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gte_ptr_ptr]
#define atspre_gte_ptr0_ptr0 atspre_gte_ptr_ptr
#define atspre_gte_ptr1_ptr1 atspre_gte_ptr_ptr

ATSinline()
atstype_bool
atspre_eq_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 == p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_eq_ptr_ptr]
#define atspre_eq_ptr0_ptr0 atspre_eq_ptr_ptr
#define atspre_eq_ptr1_ptr1 atspre_eq_ptr_ptr

ATSinline()
atstype_bool
atspre_neq_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 != p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_neq_ptr_ptr]
#define atspre_neq_ptr0_ptr0 atspre_neq_ptr_ptr
#define atspre_neq_ptr1_ptr1 atspre_neq_ptr_ptr


ATSinline()
atstype_int
atspre_compare_ptr_ptr
(
  atstype_ptr p1, atstype_ptr p2
) {
  if (p1 >= p2) {
    if (p1 > p2) return 1 ; else return 0 ;
  } else return (-1) ;
} // end of [atspre_compare_ptr_ptr]
#define atspre_compare_ptr0_ptr0 atspre_compare_ptr_ptr
#define atspre_compare_ptr1_ptr1 atspre_compare_ptr_ptr

/* ****** ****** */

ATSinline()
atstype_bool
atspre_gt_ptr_intz
  (atstype_ptr p, atstype_int _)
{
  return (p > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gt_ptr_intz]
#define atspre_gt_ptr0_intz atspre_gt_ptr_intz
#define atspre_gt_ptr1_intz atspre_gt_ptr_intz

ATSinline()
atstype_bool
atspre_eq_ptr_intz
  (atstype_ptr p, atstype_int _)
{
  return (p == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_eq_ptr_intz]
#define atspre_eq_ptr0_intz atspre_eq_ptr_intz
#define atspre_eq_ptr1_intz atspre_eq_ptr_intz

ATSinline()
atstype_bool
atspre_neq_ptr_intz
  (atstype_ptr p, atstype_int _)
{
  return (p != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_neq_ptr_intz]
#define atspre_neq_ptr0_intz atspre_neq_ptr_intz
#define atspre_neq_ptr1_intz atspre_neq_ptr_intz

/* ****** ****** */
//
#define atspre_cptr_null() atsptr_null
//
#define atspre_cptr_is_null atspre_ptr_is_null
#define atspre_cptr_isnot_null atspre_ptr_isnot_null
//
/* ****** ****** */
//
#define atspre_ptr_free atspre_mfree_gc
#define atspre_ptr_alloc_tsz atspre_malloc_gc
//
/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_ptr_nullize_tsz
(
  atstype_ptr p, atstype_size tsz
) {
  memset (p, 0, tsz) ; return /*void*/ ;
} // end of [atspre_ptr_nullize_tsz]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_POINTER

/* ****** ****** */

/* end of [pointer.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/matrix.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_MATRIX
#define ATSLIB_PRELUDE_CATS_MATRIX

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_MATRIX

/* ****** ****** */

/* end of [matrix.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/integer.atxt
** Time of generation: Sat Oct 17 15:20:01 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_INTEGER
#define ATSLIB_PRELUDE_CATS_INTEGER

/* ****** ****** */
//
#define atspre_g0int2int_int_int(x) ((atstype_int)(x))
#define atspre_g0int2int_int_lint(x) ((atstype_lint)(x))
#define atspre_g0int2int_int_llint(x) ((atstype_llint)(x))
#define atspre_g0int2int_int_ssize(x) ((atstype_ssize)(x))
#define atspre_g1int2int_int_int atspre_g0int2int_int_int
#define atspre_g1int2int_int_lint atspre_g0int2int_int_lint
#define atspre_g1int2int_int_llint atspre_g0int2int_int_llint
#define atspre_g1int2int_int_ssize atspre_g0int2int_int_ssize
//
#define atspre_g0int2int_lint_int(x) ((atstype_int)(x))
#define atspre_g0int2int_lint_lint(x) ((atstype_lint)(x))
#define atspre_g0int2int_lint_llint(x) ((atstype_llint)(x))
#define atspre_g0int2int_lint_ssize(x) ((atstype_ssize)(x))
#define atspre_g1int2int_lint_int atspre_g0int2int_lint_int
#define atspre_g1int2int_lint_lint atspre_g0int2int_lint_lint
#define atspre_g1int2int_lint_llint atspre_g0int2int_lint_llint
#define atspre_g1int2int_lint_ssize atspre_g0int2int_lint_ssize
//
#define atspre_g0int2int_ssize_int(x) ((atstype_int)(x))
#define atspre_g0int2int_ssize_lint(x) ((atstype_lint)(x))
#define atspre_g0int2int_ssize_llint(x) ((atstype_llint)(x))
#define atspre_g0int2int_ssize_ssize(x) ((atstype_ssize)(x))
#define atspre_g1int2int_ssize_int atspre_g0int2int_ssize_int
#define atspre_g1int2int_ssize_lint atspre_g0int2int_ssize_lint
#define atspre_g1int2int_ssize_llint atspre_g0int2int_ssize_llint
#define atspre_g1int2int_ssize_ssize atspre_g0int2int_ssize_ssize
//
/* ****** ****** */
//
#define atspre_g0int2int_sint_int(x) ((atstype_int)(x))
//
/* ****** ****** */
//
#define atspre_g0int2uint_int_uint(x) ((atstype_uint)(x))
#define atspre_g0int2uint_int_ulint(x) ((atstype_ulint)(x))
#define atspre_g0int2uint_int_ullint(x) ((atstype_ullint)(x))
#define atspre_g0int2uint_int_size(x) ((atstype_size)(x))
#define atspre_g1int2uint_int_uint atspre_g0int2uint_int_uint
#define atspre_g1int2uint_int_ulint atspre_g0int2uint_int_ulint
#define atspre_g1int2uint_int_ullint atspre_g0int2uint_int_ullint
#define atspre_g1int2uint_int_size atspre_g0int2uint_int_size
//
#define atspre_g0int2uint_lint_ulint(x) ((atstype_ulint)(x))
#define atspre_g0int2uint_lint_ullint(x) ((atstype_ullint)(x))
#define atspre_g0int2uint_lint_size(x) ((atstype_size)(x))
#define atspre_g1int2uint_lint_ulint atspre_g0int2uint_lint_ulint
#define atspre_g1int2uint_lint_ullint atspre_g0int2uint_lint_ullint
#define atspre_g1int2uint_lint_size atspre_g0int2uint_lint_size
//
#define atspre_g0int2uint_llint_ullint(x) ((atstype_ullint)(x))
#define atspre_g1int2uint_llint_ullint atspre_g0int2uint_llint_ullint
//
#define atspre_g0int2uint_ssize_size(x) ((atstype_size)(x))
#define atspre_g1int2uint_ssize_size atspre_g0int2uint_ssize_size
//
/* ****** ****** */
//
#define atspre_g0uint2int_uint_int(x) ((atstype_int)(x))
#define atspre_g0uint2int_uint_lint(x) ((atstype_lint)(x))
#define atspre_g0uint2int_uint_llint(x) ((atstype_llint)(x))
#define atspre_g0uint2int_uint_ssize(x) ((atstype_ssize)(x))
#define atspre_g1uint2int_uint_int atspre_g0uint2int_uint_int
#define atspre_g1uint2int_uint_lint atspre_g0uint2int_uint_lint
#define atspre_g1uint2int_uint_llint atspre_g0uint2int_uint_llint
#define atspre_g1uint2int_uint_ssize atspre_g0uint2int_uint_ssize
//
/* ****** ****** */
//
#define atspre_g0uint2int_size_int(x) ((atstype_int)(x))
#define atspre_g0uint2int_size_lint(x) ((atstype_lint)(x))
#define atspre_g0uint2int_size_llint(x) ((atstype_llint)(x))
#define atspre_g0uint2int_size_ssize(x) ((atstype_ssize)(x))
#define atspre_g1uint2int_size_int atspre_g0uint2int_size_int
#define atspre_g1uint2int_size_lint atspre_g0uint2int_size_lint
#define atspre_g1uint2int_size_llint atspre_g0uint2int_size_llint
#define atspre_g1uint2int_size_ssize atspre_g0uint2int_size_ssize
//
/* ****** ****** */
//
#define atspre_g0uint2uint_uint_uint(x) (x)
#define atspre_g0uint2uint_uint_ulint(x) ((atstype_ulint)(x))
#define atspre_g0uint2uint_uint_ullint(x) ((atstype_ullint)(x))
#define atspre_g0uint2uint_uint_size(x) ((atstype_size)(x))
#define atspre_g1uint2uint_uint_uint atspre_g0uint2uint_uint_uint
#define atspre_g1uint2uint_uint_ulint atspre_g0uint2uint_uint_ulint
#define atspre_g1uint2uint_uint_ullint atspre_g0uint2uint_uint_ullint
#define atspre_g1uint2uint_uint_size atspre_g0uint2uint_uint_size
//
/* ****** ****** */
//
#define atspre_g0uint2uint_ulint_uint(x) ((atstype_uint)(x))
#define atspre_g0uint2uint_ulint_ulint(x) (x)
#define atspre_g0uint2uint_ulint_ullint(x) ((atstype_ullint)(x))
#define atspre_g0uint2uint_ulint_size(x) ((atstype_size)(x))
#define atspre_g1uint2uint_ulint_uint atspre_g0uint2uint_ulint_uint
#define atspre_g1uint2uint_ulint_ulint atspre_g0uint2uint_ulint_ulint
#define atspre_g1uint2uint_ulint_ullint atspre_g0uint2uint_ulint_ullint
#define atspre_g1uint2uint_ulint_size atspre_g0uint2uint_ulint_size
//
/* ****** ****** */
//
#define atspre_g0uint2uint_size_uint(x) ((atstype_uint)(x))
#define atspre_g0uint2uint_size_ulint(x) ((atstype_ulint)(x))
#define atspre_g0uint2uint_size_ullint(x) ((atstype_ullint)(x))
#define atspre_g0uint2uint_size_size(x) (x)
#define atspre_g1uint2uint_size_uint atspre_g0uint2uint_size_uint
#define atspre_g1uint2uint_size_ulint atspre_g0uint2uint_size_ulint
#define atspre_g1uint2uint_size_ullint atspre_g0uint2uint_size_ullint
#define atspre_g1uint2uint_size_size atspre_g0uint2uint_size_size
//
/* ****** ****** */
//
#define atspre_g0uint2uint_usint_uint(x) ((atstype_uint)(x))
//
/* ****** ****** */
//
extern int atoi (const char *inp) ;
extern long int atol (const char *inp) ;
extern long long int atoll (const char *inp) ;
//
ATSinline()
atstype_int
atspre_g0string2int_int
  (atstype_string inp) { return atoi((char*)inp) ; }
ATSinline()
atstype_lint
atspre_g0string2int_lint
  (atstype_string inp) { return atol((char*)inp) ; }
ATSinline()
atstype_llint
atspre_g0string2int_llint
  (atstype_string inp) { return atoll((char*)inp) ; }
ATSinline()
atstype_ssize
atspre_g0string2int_ssize
  (atstype_string inp) { return atol((char*)inp) ; }
//
/* ****** ****** */
//
extern
unsigned long int
strtoul(const char *nptr, char **endptr, int base);
extern
unsigned long long int
strtoull(const char *nptr, char **endptr, int base);
//
ATSinline()
atstype_uint
atspre_g0string2uint_uint
  (atstype_string inp) { return strtoul((char*)inp, NULL, 10) ; }
ATSinline()
atstype_ulint
atspre_g0string2uint_ulint
  (atstype_string inp) { return strtoul((char*)inp, NULL, 10) ; }
ATSinline()
atstype_ullint
atspre_g0string2uint_ullint
  (atstype_string inp) { return strtoull((char*)inp, NULL, 10) ; }
ATSinline()
atstype_size
atspre_g0string2uint_size
  (atstype_string inp) { return strtoul((char*)inp, NULL, 10) ; }
//
/* ****** ****** */

ATSinline()
atstype_int
atspre_g0int_neg_int
  (atstype_int x) { return (-x) ; }
// end of [atspre_g0int_neg_int]
ATSinline()
atstype_int
atspre_g0int_abs_int
  (atstype_int x) { return (x >= 0 ? x : -x) ; }
// end of [atspre_g0int_abs_int]
ATSinline()
atstype_int
atspre_g0int_succ_int
  (atstype_int x) { return (x + 1) ; }
// end of [atspre_g0int_succ_int]
ATSinline()
atstype_int
atspre_g0int_pred_int
  (atstype_int x) { return (x - 1) ; }
// end of [atspre_g0int_pred_int]
ATSinline()
atstype_int
atspre_g0int_half_int
  (atstype_int x) { return (x / 2) ; }
// end of [atspre_g0int_half_int]
ATSinline()
atstype_int
atspre_g0int_add_int
  (atstype_int x1, atstype_int x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_int]
ATSinline()
atstype_int
atspre_g0int_sub_int
  (atstype_int x1, atstype_int x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_int]
ATSinline()
atstype_int
atspre_g0int_mul_int
  (atstype_int x1, atstype_int x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_int]
ATSinline()
atstype_int
atspre_g0int_div_int
  (atstype_int x1, atstype_int x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_int]
ATSinline()
atstype_int
atspre_g0int_mod_int
  (atstype_int x1, atstype_int x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_int]
ATSinline()
atstype_int
atspre_g0int_nmod_int
  (atstype_int x1, atstype_int x2) { return (x1 % x2) ; }
// end of [atspre_g0int_nmod_int]
ATSinline()
atstype_int
atspre_g0int_asl_int
  (atstype_int x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0int_asl_int]
ATSinline()
atstype_int
atspre_g0int_asr_int
  (atstype_int x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0int_asr_int]
ATSinline()
atstype_bool
atspre_g0int_isltz_int (atstype_int x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_int]
ATSinline()
atstype_bool
atspre_g0int_isltez_int (atstype_int x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_int]
ATSinline()
atstype_bool
atspre_g0int_isgtz_int (atstype_int x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_int]
ATSinline()
atstype_bool
atspre_g0int_isgtez_int (atstype_int x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_int]
ATSinline()
atstype_bool
atspre_g0int_iseqz_int (atstype_int x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_int]
ATSinline()
atstype_bool
atspre_g0int_isneqz_int (atstype_int x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_int]
ATSinline()
atstype_bool
atspre_g0int_lt_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_int]
ATSinline()
atstype_bool
atspre_g0int_lte_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_int]
ATSinline()
atstype_bool
atspre_g0int_gt_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_int]
ATSinline()
atstype_bool
atspre_g0int_gte_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_int]
ATSinline()
atstype_bool
atspre_g0int_eq_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_int]
ATSinline()
atstype_bool
atspre_g0int_neq_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_int]
ATSinline()
atstype_int
atspre_g0int_compare_int
(
  atstype_int x1, atstype_int x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0int_compare_int]
ATSinline()
atstype_int
atspre_g0int_max_int
  (atstype_int x1, atstype_int x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0int_max_int]
ATSinline()
atstype_int
atspre_g0int_min_int
  (atstype_int x1, atstype_int x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0int_min_int]
//
ATSinline()
atstype_lint
atspre_g0int_neg_lint
  (atstype_lint x) { return (-x) ; }
// end of [atspre_g0int_neg_lint]
ATSinline()
atstype_lint
atspre_g0int_abs_lint
  (atstype_lint x) { return (x >= 0 ? x : -x) ; }
// end of [atspre_g0int_abs_lint]
ATSinline()
atstype_lint
atspre_g0int_succ_lint
  (atstype_lint x) { return (x + 1) ; }
// end of [atspre_g0int_succ_lint]
ATSinline()
atstype_lint
atspre_g0int_pred_lint
  (atstype_lint x) { return (x - 1) ; }
// end of [atspre_g0int_pred_lint]
ATSinline()
atstype_lint
atspre_g0int_half_lint
  (atstype_lint x) { return (x / 2) ; }
// end of [atspre_g0int_half_lint]
ATSinline()
atstype_lint
atspre_g0int_add_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_lint]
ATSinline()
atstype_lint
atspre_g0int_sub_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_lint]
ATSinline()
atstype_lint
atspre_g0int_mul_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_lint]
ATSinline()
atstype_lint
atspre_g0int_div_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_lint]
ATSinline()
atstype_lint
atspre_g0int_mod_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_lint]
ATSinline()
atstype_lint
atspre_g0int_nmod_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 % x2) ; }
// end of [atspre_g0int_nmod_lint]
ATSinline()
atstype_lint
atspre_g0int_asl_lint
  (atstype_lint x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0int_asl_lint]
ATSinline()
atstype_lint
atspre_g0int_asr_lint
  (atstype_lint x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0int_asr_lint]
ATSinline()
atstype_bool
atspre_g0int_isltz_lint (atstype_lint x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_lint]
ATSinline()
atstype_bool
atspre_g0int_isltez_lint (atstype_lint x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_lint]
ATSinline()
atstype_bool
atspre_g0int_isgtz_lint (atstype_lint x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_lint]
ATSinline()
atstype_bool
atspre_g0int_isgtez_lint (atstype_lint x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_lint]
ATSinline()
atstype_bool
atspre_g0int_iseqz_lint (atstype_lint x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_lint]
ATSinline()
atstype_bool
atspre_g0int_isneqz_lint (atstype_lint x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_lint]
ATSinline()
atstype_bool
atspre_g0int_lt_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_lint]
ATSinline()
atstype_bool
atspre_g0int_lte_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_lint]
ATSinline()
atstype_bool
atspre_g0int_gt_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_lint]
ATSinline()
atstype_bool
atspre_g0int_gte_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_lint]
ATSinline()
atstype_bool
atspre_g0int_eq_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_lint]
ATSinline()
atstype_bool
atspre_g0int_neq_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_lint]
ATSinline()
atstype_int
atspre_g0int_compare_lint
(
  atstype_lint x1, atstype_lint x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0int_compare_lint]
ATSinline()
atstype_lint
atspre_g0int_max_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0int_max_lint]
ATSinline()
atstype_lint
atspre_g0int_min_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0int_min_lint]
//
ATSinline()
atstype_llint
atspre_g0int_neg_llint
  (atstype_llint x) { return (-x) ; }
// end of [atspre_g0int_neg_llint]
ATSinline()
atstype_llint
atspre_g0int_abs_llint
  (atstype_llint x) { return (x >= 0 ? x : -x) ; }
// end of [atspre_g0int_abs_llint]
ATSinline()
atstype_llint
atspre_g0int_succ_llint
  (atstype_llint x) { return (x + 1) ; }
// end of [atspre_g0int_succ_llint]
ATSinline()
atstype_llint
atspre_g0int_pred_llint
  (atstype_llint x) { return (x - 1) ; }
// end of [atspre_g0int_pred_llint]
ATSinline()
atstype_llint
atspre_g0int_half_llint
  (atstype_llint x) { return (x / 2) ; }
// end of [atspre_g0int_half_llint]
ATSinline()
atstype_llint
atspre_g0int_add_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_llint]
ATSinline()
atstype_llint
atspre_g0int_sub_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_llint]
ATSinline()
atstype_llint
atspre_g0int_mul_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_llint]
ATSinline()
atstype_llint
atspre_g0int_div_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_llint]
ATSinline()
atstype_llint
atspre_g0int_mod_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_llint]
ATSinline()
atstype_llint
atspre_g0int_nmod_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 % x2) ; }
// end of [atspre_g0int_nmod_llint]
ATSinline()
atstype_llint
atspre_g0int_asl_llint
  (atstype_llint x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0int_asl_llint]
ATSinline()
atstype_llint
atspre_g0int_asr_llint
  (atstype_llint x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0int_asr_llint]
ATSinline()
atstype_bool
atspre_g0int_isltz_llint (atstype_llint x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_llint]
ATSinline()
atstype_bool
atspre_g0int_isltez_llint (atstype_llint x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_llint]
ATSinline()
atstype_bool
atspre_g0int_isgtz_llint (atstype_llint x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_llint]
ATSinline()
atstype_bool
atspre_g0int_isgtez_llint (atstype_llint x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_llint]
ATSinline()
atstype_bool
atspre_g0int_iseqz_llint (atstype_llint x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_llint]
ATSinline()
atstype_bool
atspre_g0int_isneqz_llint (atstype_llint x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_llint]
ATSinline()
atstype_bool
atspre_g0int_lt_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_llint]
ATSinline()
atstype_bool
atspre_g0int_lte_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_llint]
ATSinline()
atstype_bool
atspre_g0int_gt_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_llint]
ATSinline()
atstype_bool
atspre_g0int_gte_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_llint]
ATSinline()
atstype_bool
atspre_g0int_eq_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_llint]
ATSinline()
atstype_bool
atspre_g0int_neq_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_llint]
ATSinline()
atstype_int
atspre_g0int_compare_llint
(
  atstype_llint x1, atstype_llint x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0int_compare_llint]
ATSinline()
atstype_llint
atspre_g0int_max_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0int_max_llint]
ATSinline()
atstype_llint
atspre_g0int_min_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0int_min_llint]
//
ATSinline()
atstype_ssize
atspre_g0int_neg_ssize
  (atstype_ssize x) { return (-x) ; }
// end of [atspre_g0int_neg_ssize]
ATSinline()
atstype_ssize
atspre_g0int_abs_ssize
  (atstype_ssize x) { return (x >= 0 ? x : -x) ; }
// end of [atspre_g0int_abs_ssize]
ATSinline()
atstype_ssize
atspre_g0int_succ_ssize
  (atstype_ssize x) { return (x + 1) ; }
// end of [atspre_g0int_succ_ssize]
ATSinline()
atstype_ssize
atspre_g0int_pred_ssize
  (atstype_ssize x) { return (x - 1) ; }
// end of [atspre_g0int_pred_ssize]
ATSinline()
atstype_ssize
atspre_g0int_half_ssize
  (atstype_ssize x) { return (x / 2) ; }
// end of [atspre_g0int_half_ssize]
ATSinline()
atstype_ssize
atspre_g0int_add_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_ssize]
ATSinline()
atstype_ssize
atspre_g0int_sub_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_ssize]
ATSinline()
atstype_ssize
atspre_g0int_mul_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_ssize]
ATSinline()
atstype_ssize
atspre_g0int_div_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_ssize]
ATSinline()
atstype_ssize
atspre_g0int_mod_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_ssize]
ATSinline()
atstype_ssize
atspre_g0int_nmod_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 % x2) ; }
// end of [atspre_g0int_nmod_ssize]
ATSinline()
atstype_ssize
atspre_g0int_asl_ssize
  (atstype_ssize x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0int_asl_ssize]
ATSinline()
atstype_ssize
atspre_g0int_asr_ssize
  (atstype_ssize x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0int_asr_ssize]
ATSinline()
atstype_bool
atspre_g0int_isltz_ssize (atstype_ssize x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_ssize]
ATSinline()
atstype_bool
atspre_g0int_isltez_ssize (atstype_ssize x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_ssize]
ATSinline()
atstype_bool
atspre_g0int_isgtz_ssize (atstype_ssize x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_ssize]
ATSinline()
atstype_bool
atspre_g0int_isgtez_ssize (atstype_ssize x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_ssize]
ATSinline()
atstype_bool
atspre_g0int_iseqz_ssize (atstype_ssize x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_ssize]
ATSinline()
atstype_bool
atspre_g0int_isneqz_ssize (atstype_ssize x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_ssize]
ATSinline()
atstype_bool
atspre_g0int_lt_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_ssize]
ATSinline()
atstype_bool
atspre_g0int_lte_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_ssize]
ATSinline()
atstype_bool
atspre_g0int_gt_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_ssize]
ATSinline()
atstype_bool
atspre_g0int_gte_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_ssize]
ATSinline()
atstype_bool
atspre_g0int_eq_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_ssize]
ATSinline()
atstype_bool
atspre_g0int_neq_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_ssize]
ATSinline()
atstype_int
atspre_g0int_compare_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0int_compare_ssize]
ATSinline()
atstype_ssize
atspre_g0int_max_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0int_max_ssize]
ATSinline()
atstype_ssize
atspre_g0int_min_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0int_min_ssize]
//
/* ****** ****** */

#define atspre_g1int_neg_int atspre_g0int_neg_int
#define atspre_g1int_abs_int atspre_g0int_abs_int
#define atspre_g1int_succ_int atspre_g0int_succ_int
#define atspre_g1int_pred_int atspre_g0int_pred_int
#define atspre_g1int_half_int atspre_g0int_half_int
#define atspre_g1int_add_int atspre_g0int_add_int
#define atspre_g1int_sub_int atspre_g0int_sub_int
#define atspre_g1int_mul_int atspre_g0int_mul_int
#define atspre_g1int_div_int atspre_g0int_div_int
#define atspre_g1int_nmod_int atspre_g0int_nmod_int
#define atspre_g1int_isltz_int atspre_g0int_isltz_int
#define atspre_g1int_isltez_int atspre_g0int_isltez_int
#define atspre_g1int_isgtz_int atspre_g0int_isgtz_int
#define atspre_g1int_isgtez_int atspre_g0int_isgtez_int
#define atspre_g1int_iseqz_int atspre_g0int_iseqz_int
#define atspre_g1int_isneqz_int atspre_g0int_isneqz_int
#define atspre_g1int_lt_int atspre_g0int_lt_int
#define atspre_g1int_lte_int atspre_g0int_lte_int
#define atspre_g1int_gt_int atspre_g0int_gt_int
#define atspre_g1int_gte_int atspre_g0int_gte_int
#define atspre_g1int_eq_int atspre_g0int_eq_int
#define atspre_g1int_neq_int atspre_g0int_neq_int
#define atspre_g1int_compare_int atspre_g0int_compare_int
#define atspre_g1int_max_int atspre_g0int_max_int
#define atspre_g1int_min_int atspre_g0int_min_int

/* ****** ****** */

#define atspre_g1int_neg_lint atspre_g0int_neg_lint
#define atspre_g1int_succ_lint atspre_g0int_succ_lint
#define atspre_g1int_pred_lint atspre_g0int_pred_lint
#define atspre_g1int_half_lint atspre_g0int_half_lint
#define atspre_g1int_add_lint atspre_g0int_add_lint
#define atspre_g1int_sub_lint atspre_g0int_sub_lint
#define atspre_g1int_mul_lint atspre_g0int_mul_lint
#define atspre_g1int_div_lint atspre_g0int_div_lint
#define atspre_g1int_nmod_lint atspre_g0int_nmod_lint
#define atspre_g1int_isltz_lint atspre_g0int_isltz_lint
#define atspre_g1int_isltez_lint atspre_g0int_isltez_lint
#define atspre_g1int_isgtz_lint atspre_g0int_isgtz_lint
#define atspre_g1int_isgtez_lint atspre_g0int_isgtez_lint
#define atspre_g1int_iseqz_lint atspre_g0int_iseqz_lint
#define atspre_g1int_isneqz_lint atspre_g0int_isneqz_lint
#define atspre_g1int_lt_lint atspre_g0int_lt_lint
#define atspre_g1int_lte_lint atspre_g0int_lte_lint
#define atspre_g1int_gt_lint atspre_g0int_gt_lint
#define atspre_g1int_gte_lint atspre_g0int_gte_lint
#define atspre_g1int_eq_lint atspre_g0int_eq_lint
#define atspre_g1int_neq_lint atspre_g0int_neq_lint
#define atspre_g1int_compare_lint atspre_g0int_compare_lint
#define atspre_g1int_max_lint atspre_g0int_max_lint
#define atspre_g1int_min_lint atspre_g0int_min_lint

/* ****** ****** */

#define atspre_g1int_neg_llint atspre_g0int_neg_llint
#define atspre_g1int_succ_llint atspre_g0int_succ_llint
#define atspre_g1int_pred_llint atspre_g0int_pred_llint
#define atspre_g1int_half_llint atspre_g0int_half_llint
#define atspre_g1int_add_llint atspre_g0int_add_llint
#define atspre_g1int_sub_llint atspre_g0int_sub_llint
#define atspre_g1int_mul_llint atspre_g0int_mul_llint
#define atspre_g1int_div_llint atspre_g0int_div_llint
#define atspre_g1int_nmod_llint atspre_g0int_nmod_llint
#define atspre_g1int_isltz_llint atspre_g0int_isltz_llint
#define atspre_g1int_isltez_llint atspre_g0int_isltez_llint
#define atspre_g1int_isgtz_llint atspre_g0int_isgtz_llint
#define atspre_g1int_isgtez_llint atspre_g0int_isgtez_llint
#define atspre_g1int_iseqz_llint atspre_g0int_iseqz_llint
#define atspre_g1int_isneqz_llint atspre_g0int_isneqz_llint
#define atspre_g1int_lt_llint atspre_g0int_lt_llint
#define atspre_g1int_lte_llint atspre_g0int_lte_llint
#define atspre_g1int_gt_llint atspre_g0int_gt_llint
#define atspre_g1int_gte_llint atspre_g0int_gte_llint
#define atspre_g1int_eq_llint atspre_g0int_eq_llint
#define atspre_g1int_neq_llint atspre_g0int_neq_llint
#define atspre_g1int_compare_llint atspre_g0int_compare_llint
#define atspre_g1int_max_llint atspre_g0int_max_llint
#define atspre_g1int_min_llint atspre_g0int_min_llint

/* ****** ****** */

#define atspre_g1int_neg_ssize atspre_g0int_neg_ssize
#define atspre_g1int_succ_ssize atspre_g0int_succ_ssize
#define atspre_g1int_pred_ssize atspre_g0int_pred_ssize
#define atspre_g1int_half_ssize atspre_g0int_half_ssize
#define atspre_g1int_add_ssize atspre_g0int_add_ssize
#define atspre_g1int_sub_ssize atspre_g0int_sub_ssize
#define atspre_g1int_mul_ssize atspre_g0int_mul_ssize
#define atspre_g1int_div_ssize atspre_g0int_div_ssize
#define atspre_g1int_nmod_ssize atspre_g0int_nmod_ssize
#define atspre_g1int_isltz_ssize atspre_g0int_isltz_ssize
#define atspre_g1int_isltez_ssize atspre_g0int_isltez_ssize
#define atspre_g1int_isgtz_ssize atspre_g0int_isgtz_ssize
#define atspre_g1int_isgtez_ssize atspre_g0int_isgtez_ssize
#define atspre_g1int_iseqz_ssize atspre_g0int_iseqz_ssize
#define atspre_g1int_isneqz_ssize atspre_g0int_isneqz_ssize
#define atspre_g1int_lt_ssize atspre_g0int_lt_ssize
#define atspre_g1int_lte_ssize atspre_g0int_lte_ssize
#define atspre_g1int_gt_ssize atspre_g0int_gt_ssize
#define atspre_g1int_gte_ssize atspre_g0int_gte_ssize
#define atspre_g1int_eq_ssize atspre_g0int_eq_ssize
#define atspre_g1int_neq_ssize atspre_g0int_neq_ssize
#define atspre_g1int_compare_ssize atspre_g0int_compare_ssize
#define atspre_g1int_max_ssize atspre_g0int_max_ssize
#define atspre_g1int_min_ssize atspre_g0int_min_ssize

/* ****** ****** */

ATSinline()
atstype_uint
atspre_g0uint_succ_uint
  (atstype_uint x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uint]
ATSinline()
atstype_uint
atspre_g0uint_pred_uint
  (atstype_uint x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uint]
ATSinline()
atstype_uint
atspre_g0uint_half_uint
  (atstype_uint x) { return (x >> 1) ; }
// end of [atspre_g0uint_half_uint]
ATSinline()
atstype_uint
atspre_g0uint_add_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uint]
ATSinline()
atstype_uint
atspre_g0uint_sub_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uint]
ATSinline()
atstype_uint
atspre_g0uint_mul_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uint]
ATSinline()
atstype_uint
atspre_g0uint_div_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uint]
ATSinline()
atstype_uint
atspre_g0uint_mod_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uint]
ATSinline()
atstype_uint
atspre_g0uint_lsl_uint
  (atstype_uint x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uint]
ATSinline()
atstype_uint
atspre_g0uint_lsr_uint
  (atstype_uint x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uint]
ATSinline()
atstype_uint
atspre_g0uint_lnot_uint
  (atstype_uint x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uint]
ATSinline()
atstype_uint
atspre_g0uint_lor_uint
  (atstype_uint x, atstype_uint y) { return (x | y) ; }
// end of [atspre_g0uint_uint_uint]
ATSinline()
atstype_uint
atspre_g0uint_land_uint
  (atstype_uint x, atstype_uint y) { return (x & y) ; }
// end of [atspre_g0uint_uint_uint]
ATSinline()
atstype_uint
atspre_g0uint_lxor_uint
  (atstype_uint x, atstype_uint y) { return (x ^ y) ; }
// end of [atspre_g0uint_uint_uint]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uint (atstype_uint x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uint]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uint (atstype_uint x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uint]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uint (atstype_uint x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uint]
ATSinline()
atstype_bool
atspre_g0uint_lt_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uint]
ATSinline()
atstype_bool
atspre_g0uint_lte_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uint]
ATSinline()
atstype_bool
atspre_g0uint_gt_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uint]
ATSinline()
atstype_bool
atspre_g0uint_gte_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uint]
ATSinline()
atstype_bool
atspre_g0uint_eq_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uint]
ATSinline()
atstype_bool
atspre_g0uint_neq_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uint]
ATSinline()
atstype_int
atspre_g0uint_compare_uint
(
  atstype_uint x1, atstype_uint x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0uint_compare_uint]
ATSinline()
atstype_uint
atspre_g0uint_max_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_max_uint]
ATSinline()
atstype_uint
atspre_g0uint_min_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_min_uint]
//
ATSinline()
atstype_ulint
atspre_g0uint_succ_ulint
  (atstype_ulint x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_pred_ulint
  (atstype_ulint x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_half_ulint
  (atstype_ulint x) { return (x >> 1) ; }
// end of [atspre_g0uint_half_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_add_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_sub_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_mul_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_div_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_mod_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_lsl_ulint
  (atstype_ulint x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_lsr_ulint
  (atstype_ulint x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_lnot_ulint
  (atstype_ulint x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_lor_ulint
  (atstype_ulint x, atstype_ulint y) { return (x | y) ; }
// end of [atspre_g0uint_ulint_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_land_ulint
  (atstype_ulint x, atstype_ulint y) { return (x & y) ; }
// end of [atspre_g0uint_ulint_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_lxor_ulint
  (atstype_ulint x, atstype_ulint y) { return (x ^ y) ; }
// end of [atspre_g0uint_ulint_ulint]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_ulint (atstype_ulint x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_ulint]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_ulint (atstype_ulint x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_ulint]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_ulint (atstype_ulint x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_ulint]
ATSinline()
atstype_bool
atspre_g0uint_lt_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_ulint]
ATSinline()
atstype_bool
atspre_g0uint_lte_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_ulint]
ATSinline()
atstype_bool
atspre_g0uint_gt_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_ulint]
ATSinline()
atstype_bool
atspre_g0uint_gte_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_ulint]
ATSinline()
atstype_bool
atspre_g0uint_eq_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_ulint]
ATSinline()
atstype_bool
atspre_g0uint_neq_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_ulint]
ATSinline()
atstype_int
atspre_g0uint_compare_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0uint_compare_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_max_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_max_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_min_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_min_ulint]
//
ATSinline()
atstype_ullint
atspre_g0uint_succ_ullint
  (atstype_ullint x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_pred_ullint
  (atstype_ullint x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_half_ullint
  (atstype_ullint x) { return (x >> 1) ; }
// end of [atspre_g0uint_half_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_add_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_sub_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_mul_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_div_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_mod_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_lsl_ullint
  (atstype_ullint x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_lsr_ullint
  (atstype_ullint x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_lnot_ullint
  (atstype_ullint x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_lor_ullint
  (atstype_ullint x, atstype_ullint y) { return (x | y) ; }
// end of [atspre_g0uint_ullint_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_land_ullint
  (atstype_ullint x, atstype_ullint y) { return (x & y) ; }
// end of [atspre_g0uint_ullint_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_lxor_ullint
  (atstype_ullint x, atstype_ullint y) { return (x ^ y) ; }
// end of [atspre_g0uint_ullint_ullint]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_ullint (atstype_ullint x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_ullint]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_ullint (atstype_ullint x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_ullint]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_ullint (atstype_ullint x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_ullint]
ATSinline()
atstype_bool
atspre_g0uint_lt_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_ullint]
ATSinline()
atstype_bool
atspre_g0uint_lte_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_ullint]
ATSinline()
atstype_bool
atspre_g0uint_gt_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_ullint]
ATSinline()
atstype_bool
atspre_g0uint_gte_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_ullint]
ATSinline()
atstype_bool
atspre_g0uint_eq_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_ullint]
ATSinline()
atstype_bool
atspre_g0uint_neq_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_ullint]
ATSinline()
atstype_int
atspre_g0uint_compare_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0uint_compare_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_max_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_max_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_min_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_min_ullint]
//
ATSinline()
atstype_size
atspre_g0uint_succ_size
  (atstype_size x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_size]
ATSinline()
atstype_size
atspre_g0uint_pred_size
  (atstype_size x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_size]
ATSinline()
atstype_size
atspre_g0uint_half_size
  (atstype_size x) { return (x >> 1) ; }
// end of [atspre_g0uint_half_size]
ATSinline()
atstype_size
atspre_g0uint_add_size
  (atstype_size x1, atstype_size x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_size]
ATSinline()
atstype_size
atspre_g0uint_sub_size
  (atstype_size x1, atstype_size x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_size]
ATSinline()
atstype_size
atspre_g0uint_mul_size
  (atstype_size x1, atstype_size x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_size]
ATSinline()
atstype_size
atspre_g0uint_div_size
  (atstype_size x1, atstype_size x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_size]
ATSinline()
atstype_size
atspre_g0uint_mod_size
  (atstype_size x1, atstype_size x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_size]
ATSinline()
atstype_size
atspre_g0uint_lsl_size
  (atstype_size x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_size]
ATSinline()
atstype_size
atspre_g0uint_lsr_size
  (atstype_size x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_size]
ATSinline()
atstype_size
atspre_g0uint_lnot_size
  (atstype_size x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_size]
ATSinline()
atstype_size
atspre_g0uint_lor_size
  (atstype_size x, atstype_size y) { return (x | y) ; }
// end of [atspre_g0uint_size_size]
ATSinline()
atstype_size
atspre_g0uint_land_size
  (atstype_size x, atstype_size y) { return (x & y) ; }
// end of [atspre_g0uint_size_size]
ATSinline()
atstype_size
atspre_g0uint_lxor_size
  (atstype_size x, atstype_size y) { return (x ^ y) ; }
// end of [atspre_g0uint_size_size]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_size (atstype_size x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_size]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_size (atstype_size x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_size]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_size (atstype_size x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_size]
ATSinline()
atstype_bool
atspre_g0uint_lt_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_size]
ATSinline()
atstype_bool
atspre_g0uint_lte_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_size]
ATSinline()
atstype_bool
atspre_g0uint_gt_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_size]
ATSinline()
atstype_bool
atspre_g0uint_gte_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_size]
ATSinline()
atstype_bool
atspre_g0uint_eq_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_size]
ATSinline()
atstype_bool
atspre_g0uint_neq_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_size]
ATSinline()
atstype_int
atspre_g0uint_compare_size
(
  atstype_size x1, atstype_size x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0uint_compare_size]
ATSinline()
atstype_size
atspre_g0uint_max_size
  (atstype_size x1, atstype_size x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_max_size]
ATSinline()
atstype_size
atspre_g0uint_min_size
  (atstype_size x1, atstype_size x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_min_size]
//
/* ****** ****** */

#define atspre_g1uint_succ_uint atspre_g0uint_succ_uint
#define atspre_g1uint_pred_uint atspre_g0uint_pred_uint
#define atspre_g1uint_half_uint atspre_g0uint_half_uint
#define atspre_g1uint_add_uint atspre_g0uint_add_uint
#define atspre_g1uint_sub_uint atspre_g0uint_sub_uint
#define atspre_g1uint_mul_uint atspre_g0uint_mul_uint
#define atspre_g1uint_div_uint atspre_g0uint_div_uint
#define atspre_g1uint_mod_uint atspre_g0uint_mod_uint
#define atspre_g1uint_isgtz_uint atspre_g0uint_isgtz_uint
#define atspre_g1uint_iseqz_uint atspre_g0uint_iseqz_uint
#define atspre_g1uint_isneqz_uint atspre_g0uint_isneqz_uint
#define atspre_g1uint_lt_uint atspre_g0uint_lt_uint
#define atspre_g1uint_lte_uint atspre_g0uint_lte_uint
#define atspre_g1uint_gt_uint atspre_g0uint_gt_uint
#define atspre_g1uint_gte_uint atspre_g0uint_gte_uint
#define atspre_g1uint_eq_uint atspre_g0uint_eq_uint
#define atspre_g1uint_neq_uint atspre_g0uint_neq_uint
#define atspre_g1uint_compare_uint atspre_g0uint_compare_uint
#define atspre_g1uint_max_uint atspre_g0uint_max_uint
#define atspre_g1uint_min_uint atspre_g0uint_min_uint

/* ****** ****** */

#define atspre_g1uint_succ_ulint atspre_g0uint_succ_ulint
#define atspre_g1uint_pred_ulint atspre_g0uint_pred_ulint
#define atspre_g1uint_half_ulint atspre_g0uint_half_ulint
#define atspre_g1uint_add_ulint atspre_g0uint_add_ulint
#define atspre_g1uint_sub_ulint atspre_g0uint_sub_ulint
#define atspre_g1uint_mul_ulint atspre_g0uint_mul_ulint
#define atspre_g1uint_div_ulint atspre_g0uint_div_ulint
#define atspre_g1uint_mod_ulint atspre_g0uint_mod_ulint
#define atspre_g1uint_isgtz_ulint atspre_g0uint_isgtz_ulint
#define atspre_g1uint_iseqz_ulint atspre_g0uint_iseqz_ulint
#define atspre_g1uint_isneqz_ulint atspre_g0uint_isneqz_ulint
#define atspre_g1uint_lt_ulint atspre_g0uint_lt_ulint
#define atspre_g1uint_lte_ulint atspre_g0uint_lte_ulint
#define atspre_g1uint_gt_ulint atspre_g0uint_gt_ulint
#define atspre_g1uint_gte_ulint atspre_g0uint_gte_ulint
#define atspre_g1uint_eq_ulint atspre_g0uint_eq_ulint
#define atspre_g1uint_neq_ulint atspre_g0uint_neq_ulint
#define atspre_g1uint_compare_ulint atspre_g0uint_compare_ulint
#define atspre_g1uint_max_ulint atspre_g0uint_max_ulint
#define atspre_g1uint_min_ulint atspre_g0uint_min_ulint

/* ****** ****** */

#define atspre_g1uint_succ_ullint atspre_g0uint_succ_ullint
#define atspre_g1uint_pred_ullint atspre_g0uint_pred_ullint
#define atspre_g1uint_half_ullint atspre_g0uint_half_ullint
#define atspre_g1uint_add_ullint atspre_g0uint_add_ullint
#define atspre_g1uint_sub_ullint atspre_g0uint_sub_ullint
#define atspre_g1uint_mul_ullint atspre_g0uint_mul_ullint
#define atspre_g1uint_div_ullint atspre_g0uint_div_ullint
#define atspre_g1uint_mod_ullint atspre_g0uint_mod_ullint
#define atspre_g1uint_isgtz_ullint atspre_g0uint_isgtz_ullint
#define atspre_g1uint_iseqz_ullint atspre_g0uint_iseqz_ullint
#define atspre_g1uint_isneqz_ullint atspre_g0uint_isneqz_ullint
#define atspre_g1uint_lt_ullint atspre_g0uint_lt_ullint
#define atspre_g1uint_lte_ullint atspre_g0uint_lte_ullint
#define atspre_g1uint_gt_ullint atspre_g0uint_gt_ullint
#define atspre_g1uint_gte_ullint atspre_g0uint_gte_ullint
#define atspre_g1uint_eq_ullint atspre_g0uint_eq_ullint
#define atspre_g1uint_neq_ullint atspre_g0uint_neq_ullint
#define atspre_g1uint_compare_ullint atspre_g0uint_compare_ullint
#define atspre_g1uint_max_ullint atspre_g0uint_max_ullint
#define atspre_g1uint_min_ullint atspre_g0uint_min_ullint

/* ****** ****** */

#define atspre_g1uint_succ_size atspre_g0uint_succ_size
#define atspre_g1uint_pred_size atspre_g0uint_pred_size
#define atspre_g1uint_half_size atspre_g0uint_half_size
#define atspre_g1uint_add_size atspre_g0uint_add_size
#define atspre_g1uint_sub_size atspre_g0uint_sub_size
#define atspre_g1uint_mul_size atspre_g0uint_mul_size
#define atspre_g1uint_div_size atspre_g0uint_div_size
#define atspre_g1uint_mod_size atspre_g0uint_mod_size
#define atspre_g1uint_isgtz_size atspre_g0uint_isgtz_size
#define atspre_g1uint_iseqz_size atspre_g0uint_iseqz_size
#define atspre_g1uint_isneqz_size atspre_g0uint_isneqz_size
#define atspre_g1uint_lt_size atspre_g0uint_lt_size
#define atspre_g1uint_lte_size atspre_g0uint_lte_size
#define atspre_g1uint_gt_size atspre_g0uint_gt_size
#define atspre_g1uint_gte_size atspre_g0uint_gte_size
#define atspre_g1uint_eq_size atspre_g0uint_eq_size
#define atspre_g1uint_neq_size atspre_g0uint_neq_size
#define atspre_g1uint_compare_size atspre_g0uint_compare_size
#define atspre_g1uint_max_size atspre_g0uint_max_size
#define atspre_g1uint_min_size atspre_g0uint_min_size

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_INTEGER

/* ****** ****** */

/* end of [integer.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/list_vt.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_LIST_VT
#define ATSLIB_PRELUDE_CATS_LIST_VT

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_LIST_VT

/* ****** ****** */

/* end of [list_vt.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/array.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_ARRAY
#define ATSLIB_PRELUDE_CATS_ARRAY

/* ****** ****** */
//
// [stdlib.h]
//
extern
void qsort
(
  void *base, size_t nmemb, size_t size
, int(*compar)(const void *, const void *)
) ; // end of [qsort]
extern
void *bsearch
(
  const void *key
, const void *base
, size_t nmemb, size_t size
, int (*compar)(const void *, const void *)
) ; // end of [bsearch]
//
#define atspre_array_qsort qsort
#define atspre_array_bsearch bsearch
//
/* ****** ****** */
//
// [string.h]
//
#ifndef memcpy
extern
void *memcpy(void *dst, const void *src, size_t n) ;
#endif // #ifndef
#ifndef memmove
extern
void *memmove(void *dst, const void *src, size_t n) ;
#endif // #ifndef
//
#define atspre_array_memcpy memcpy
#define atspre_array_memmove memmove
//
/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_array_foreach_funenv_tsz
(
  atstype_ptr A
, atstype_size n
, atstype_size tsz
, atstype_funptr f
, atstype_boxed env
) {
  char *p ;
  size_t i ;
  p = (char*)A ;
  for (i = 0 ; i < n ; i += 1)
  {
    ((void(*)(void*, void*))(f))(p, env) ; p += tsz ;
  }
  return ;
} // end of [atspre_array_foreach_funenv_tsz]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_ARRAY

/* ****** ****** */

/* end of [array.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/integer_fixed.atxt
** Time of generation: Sat Oct 17 15:20:02 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_INTEGER_FIXED
#define ATSLIB_PRELUDE_CATS_INTEGER_FIXED

/* ****** ****** */

#include <stdint.h>

/* ****** ****** */

typedef int8_t atstype_int8 ;
typedef int16_t atstype_int16 ;
typedef int32_t atstype_int32 ;
typedef int64_t atstype_int64 ;

typedef uint8_t atstype_uint8 ;
typedef uint16_t atstype_uint16 ;
typedef uint32_t atstype_uint32 ;
typedef uint64_t atstype_uint64 ;

/* ****** ****** */

#define atspre_g0int2int_int8_int(x) ((atstype_int)(x))
#define atspre_g0int2int_int16_int(x) ((atstype_int)(x))
#define atspre_g0int2int_int32_int(x) ((atstype_int)(x))
#define atspre_g0int2int_int64_int(x) ((atstype_int)(x))

/* ****** ****** */

ATSinline()
atstype_int8
atspre_g0int_neg_int8
  (atstype_int8 x) { return (-x) ; }
// end of [atspre_g0int_neg_int8]
ATSinline()
atstype_int8
atspre_g0int_succ_int8
  (atstype_int8 x) { return (x + 1) ; }
// end of [atspre_g0int_succ_int8]
ATSinline()
atstype_int8
atspre_g0int_pred_int8
  (atstype_int8 x) { return (x - 1) ; }
// end of [atspre_g0int_pred_int8]
ATSinline()
atstype_int8
atspre_g0int_half_int8
  (atstype_int8 x) { return (x / 2) ; }
// end of [atspre_g0int_half_int8]
ATSinline()
atstype_int8
atspre_g0int_add_int8
  (atstype_int8 x1, atstype_int8 x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_int8]
ATSinline()
atstype_int8
atspre_g0int_sub_int8
  (atstype_int8 x1, atstype_int8 x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_int8]
ATSinline()
atstype_int8
atspre_g0int_mul_int8
  (atstype_int8 x1, atstype_int8 x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_int8]
ATSinline()
atstype_int8
atspre_g0int_div_int8
  (atstype_int8 x1, atstype_int8 x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_int8]
ATSinline()
atstype_int8
atspre_g0int_mod_int8
  (atstype_int8 x1, atstype_int8 x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_int8]
ATSinline()
atstype_bool
atspre_g0int_isltz_int8 (atstype_int8 x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_int8]
ATSinline()
atstype_bool
atspre_g0int_isltez_int8 (atstype_int8 x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_int8]
ATSinline()
atstype_bool
atspre_g0int_isgtz_int8 (atstype_int8 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_int8]
ATSinline()
atstype_bool
atspre_g0int_isgtez_int8 (atstype_int8 x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_int8]
ATSinline()
atstype_bool
atspre_g0int_iseqz_int8 (atstype_int8 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_int8]
ATSinline()
atstype_bool
atspre_g0int_isneqz_int8 (atstype_int8 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_int8]
ATSinline()
atstype_bool
atspre_g0int_lt_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_int8]
ATSinline()
atstype_bool
atspre_g0int_lte_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_int8]
ATSinline()
atstype_bool
atspre_g0int_gt_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_int8]
ATSinline()
atstype_bool
atspre_g0int_gte_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_int8]
ATSinline()
atstype_bool
atspre_g0int_eq_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_int8]
ATSinline()
atstype_bool
atspre_g0int_neq_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_int8]
ATSinline()
atstype_int16
atspre_g0int_neg_int16
  (atstype_int16 x) { return (-x) ; }
// end of [atspre_g0int_neg_int16]
ATSinline()
atstype_int16
atspre_g0int_succ_int16
  (atstype_int16 x) { return (x + 1) ; }
// end of [atspre_g0int_succ_int16]
ATSinline()
atstype_int16
atspre_g0int_pred_int16
  (atstype_int16 x) { return (x - 1) ; }
// end of [atspre_g0int_pred_int16]
ATSinline()
atstype_int16
atspre_g0int_half_int16
  (atstype_int16 x) { return (x / 2) ; }
// end of [atspre_g0int_half_int16]
ATSinline()
atstype_int16
atspre_g0int_add_int16
  (atstype_int16 x1, atstype_int16 x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_int16]
ATSinline()
atstype_int16
atspre_g0int_sub_int16
  (atstype_int16 x1, atstype_int16 x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_int16]
ATSinline()
atstype_int16
atspre_g0int_mul_int16
  (atstype_int16 x1, atstype_int16 x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_int16]
ATSinline()
atstype_int16
atspre_g0int_div_int16
  (atstype_int16 x1, atstype_int16 x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_int16]
ATSinline()
atstype_int16
atspre_g0int_mod_int16
  (atstype_int16 x1, atstype_int16 x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_int16]
ATSinline()
atstype_bool
atspre_g0int_isltz_int16 (atstype_int16 x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_int16]
ATSinline()
atstype_bool
atspre_g0int_isltez_int16 (atstype_int16 x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_int16]
ATSinline()
atstype_bool
atspre_g0int_isgtz_int16 (atstype_int16 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_int16]
ATSinline()
atstype_bool
atspre_g0int_isgtez_int16 (atstype_int16 x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_int16]
ATSinline()
atstype_bool
atspre_g0int_iseqz_int16 (atstype_int16 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_int16]
ATSinline()
atstype_bool
atspre_g0int_isneqz_int16 (atstype_int16 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_int16]
ATSinline()
atstype_bool
atspre_g0int_lt_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_int16]
ATSinline()
atstype_bool
atspre_g0int_lte_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_int16]
ATSinline()
atstype_bool
atspre_g0int_gt_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_int16]
ATSinline()
atstype_bool
atspre_g0int_gte_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_int16]
ATSinline()
atstype_bool
atspre_g0int_eq_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_int16]
ATSinline()
atstype_bool
atspre_g0int_neq_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_int16]
ATSinline()
atstype_int32
atspre_g0int_neg_int32
  (atstype_int32 x) { return (-x) ; }
// end of [atspre_g0int_neg_int32]
ATSinline()
atstype_int32
atspre_g0int_succ_int32
  (atstype_int32 x) { return (x + 1) ; }
// end of [atspre_g0int_succ_int32]
ATSinline()
atstype_int32
atspre_g0int_pred_int32
  (atstype_int32 x) { return (x - 1) ; }
// end of [atspre_g0int_pred_int32]
ATSinline()
atstype_int32
atspre_g0int_half_int32
  (atstype_int32 x) { return (x / 2) ; }
// end of [atspre_g0int_half_int32]
ATSinline()
atstype_int32
atspre_g0int_add_int32
  (atstype_int32 x1, atstype_int32 x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_int32]
ATSinline()
atstype_int32
atspre_g0int_sub_int32
  (atstype_int32 x1, atstype_int32 x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_int32]
ATSinline()
atstype_int32
atspre_g0int_mul_int32
  (atstype_int32 x1, atstype_int32 x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_int32]
ATSinline()
atstype_int32
atspre_g0int_div_int32
  (atstype_int32 x1, atstype_int32 x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_int32]
ATSinline()
atstype_int32
atspre_g0int_mod_int32
  (atstype_int32 x1, atstype_int32 x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_int32]
ATSinline()
atstype_bool
atspre_g0int_isltz_int32 (atstype_int32 x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_int32]
ATSinline()
atstype_bool
atspre_g0int_isltez_int32 (atstype_int32 x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_int32]
ATSinline()
atstype_bool
atspre_g0int_isgtz_int32 (atstype_int32 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_int32]
ATSinline()
atstype_bool
atspre_g0int_isgtez_int32 (atstype_int32 x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_int32]
ATSinline()
atstype_bool
atspre_g0int_iseqz_int32 (atstype_int32 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_int32]
ATSinline()
atstype_bool
atspre_g0int_isneqz_int32 (atstype_int32 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_int32]
ATSinline()
atstype_bool
atspre_g0int_lt_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_int32]
ATSinline()
atstype_bool
atspre_g0int_lte_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_int32]
ATSinline()
atstype_bool
atspre_g0int_gt_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_int32]
ATSinline()
atstype_bool
atspre_g0int_gte_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_int32]
ATSinline()
atstype_bool
atspre_g0int_eq_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_int32]
ATSinline()
atstype_bool
atspre_g0int_neq_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_int32]
ATSinline()
atstype_int64
atspre_g0int_neg_int64
  (atstype_int64 x) { return (-x) ; }
// end of [atspre_g0int_neg_int64]
ATSinline()
atstype_int64
atspre_g0int_succ_int64
  (atstype_int64 x) { return (x + 1) ; }
// end of [atspre_g0int_succ_int64]
ATSinline()
atstype_int64
atspre_g0int_pred_int64
  (atstype_int64 x) { return (x - 1) ; }
// end of [atspre_g0int_pred_int64]
ATSinline()
atstype_int64
atspre_g0int_half_int64
  (atstype_int64 x) { return (x / 2) ; }
// end of [atspre_g0int_half_int64]
ATSinline()
atstype_int64
atspre_g0int_add_int64
  (atstype_int64 x1, atstype_int64 x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_int64]
ATSinline()
atstype_int64
atspre_g0int_sub_int64
  (atstype_int64 x1, atstype_int64 x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_int64]
ATSinline()
atstype_int64
atspre_g0int_mul_int64
  (atstype_int64 x1, atstype_int64 x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_int64]
ATSinline()
atstype_int64
atspre_g0int_div_int64
  (atstype_int64 x1, atstype_int64 x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_int64]
ATSinline()
atstype_int64
atspre_g0int_mod_int64
  (atstype_int64 x1, atstype_int64 x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_int64]
ATSinline()
atstype_bool
atspre_g0int_isltz_int64 (atstype_int64 x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_int64]
ATSinline()
atstype_bool
atspre_g0int_isltez_int64 (atstype_int64 x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_int64]
ATSinline()
atstype_bool
atspre_g0int_isgtz_int64 (atstype_int64 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_int64]
ATSinline()
atstype_bool
atspre_g0int_isgtez_int64 (atstype_int64 x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_int64]
ATSinline()
atstype_bool
atspre_g0int_iseqz_int64 (atstype_int64 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_int64]
ATSinline()
atstype_bool
atspre_g0int_isneqz_int64 (atstype_int64 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_int64]
ATSinline()
atstype_bool
atspre_g0int_lt_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_int64]
ATSinline()
atstype_bool
atspre_g0int_lte_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_int64]
ATSinline()
atstype_bool
atspre_g0int_gt_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_int64]
ATSinline()
atstype_bool
atspre_g0int_gte_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_int64]
ATSinline()
atstype_bool
atspre_g0int_eq_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_int64]
ATSinline()
atstype_bool
atspre_g0int_neq_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_int64]
//
/* ****** ****** */
//
#define atspre_g0int2uint_int8_uint(x) ((atstype_uint)(x))
#define atspre_g0int2uint_int16_uint(x) ((atstype_uint)(x))
#define atspre_g0int2uint_int32_uint(x) ((atstype_uint)(x))
#define atspre_g0int2uint_int64_uint(x) ((atstype_uint)(x))
//
#define atspre_g0uint2int_uint8_int(x) ((atstype_int)(x))
#define atspre_g0uint2int_uint16_int(x) ((atstype_int)(x))
#define atspre_g0uint2int_uint32_int(x) ((atstype_int)(x))
#define atspre_g0uint2int_uint64_int(x) ((atstype_int)(x))
//
#define atspre_g0uint2uint_uint8_uint(x) ((atstype_uint)(x))
#define atspre_g0uint2uint_uint16_uint(x) ((atstype_uint)(x))
#define atspre_g0uint2uint_uint32_uint(x) ((atstype_uint)(x))
#define atspre_g0uint2uint_uint64_uint(x) ((atstype_uint)(x))
//
/* ****** ****** */

ATSinline()
atstype_uint8
atspre_g0uint_succ_uint8
  (atstype_uint8 x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_pred_uint8
  (atstype_uint8 x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_half_uint8
  (atstype_uint8 x) { return (x >> 1) ; }
// end of [atspre_g0uint_pred_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_add_uint8
  (atstype_uint8 x1, atstype_uint8 x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_sub_uint8
  (atstype_uint8 x1, atstype_uint8 x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_mul_uint8
  (atstype_uint8 x1, atstype_uint8 x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_div_uint8
  (atstype_uint8 x1, atstype_uint8 x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_mod_uint8
  (atstype_uint8 x1, atstype_uint8 x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_lsl_uint8
  (atstype_uint8 x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_lsr_uint8
  (atstype_uint8 x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_lnot_uint8
  (atstype_uint8 x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_lor_uint8
  (atstype_uint8 x, atstype_uint8 y) { return (x | y) ; }
// end of [atspre_g0uint_uint8_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_land_uint8
  (atstype_uint8 x, atstype_uint8 y) { return (x & y) ; }
// end of [atspre_g0uint_uint8_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_lxor_uint8
  (atstype_uint8 x, atstype_uint8 y) { return (x ^ y) ; }
// end of [atspre_g0uint_uint8_uint8]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uint8 (atstype_uint8 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uint8]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uint8 (atstype_uint8 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uint8]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uint8 (atstype_uint8 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uint8]
ATSinline()
atstype_bool
atspre_g0uint_lt_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uint8]
ATSinline()
atstype_bool
atspre_g0uint_lte_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uint8]
ATSinline()
atstype_bool
atspre_g0uint_gt_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uint8]
ATSinline()
atstype_bool
atspre_g0uint_gte_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uint8]
ATSinline()
atstype_bool
atspre_g0uint_eq_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uint8]
ATSinline()
atstype_bool
atspre_g0uint_neq_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uint8]
ATSinline()
atstype_uint16
atspre_g0uint_succ_uint16
  (atstype_uint16 x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_pred_uint16
  (atstype_uint16 x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_half_uint16
  (atstype_uint16 x) { return (x >> 1) ; }
// end of [atspre_g0uint_pred_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_add_uint16
  (atstype_uint16 x1, atstype_uint16 x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_sub_uint16
  (atstype_uint16 x1, atstype_uint16 x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_mul_uint16
  (atstype_uint16 x1, atstype_uint16 x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_div_uint16
  (atstype_uint16 x1, atstype_uint16 x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_mod_uint16
  (atstype_uint16 x1, atstype_uint16 x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_lsl_uint16
  (atstype_uint16 x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_lsr_uint16
  (atstype_uint16 x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_lnot_uint16
  (atstype_uint16 x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_lor_uint16
  (atstype_uint16 x, atstype_uint16 y) { return (x | y) ; }
// end of [atspre_g0uint_uint16_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_land_uint16
  (atstype_uint16 x, atstype_uint16 y) { return (x & y) ; }
// end of [atspre_g0uint_uint16_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_lxor_uint16
  (atstype_uint16 x, atstype_uint16 y) { return (x ^ y) ; }
// end of [atspre_g0uint_uint16_uint16]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uint16 (atstype_uint16 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uint16]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uint16 (atstype_uint16 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uint16]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uint16 (atstype_uint16 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uint16]
ATSinline()
atstype_bool
atspre_g0uint_lt_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uint16]
ATSinline()
atstype_bool
atspre_g0uint_lte_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uint16]
ATSinline()
atstype_bool
atspre_g0uint_gt_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uint16]
ATSinline()
atstype_bool
atspre_g0uint_gte_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uint16]
ATSinline()
atstype_bool
atspre_g0uint_eq_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uint16]
ATSinline()
atstype_bool
atspre_g0uint_neq_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uint16]
ATSinline()
atstype_uint32
atspre_g0uint_succ_uint32
  (atstype_uint32 x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_pred_uint32
  (atstype_uint32 x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_half_uint32
  (atstype_uint32 x) { return (x >> 1) ; }
// end of [atspre_g0uint_pred_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_add_uint32
  (atstype_uint32 x1, atstype_uint32 x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_sub_uint32
  (atstype_uint32 x1, atstype_uint32 x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_mul_uint32
  (atstype_uint32 x1, atstype_uint32 x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_div_uint32
  (atstype_uint32 x1, atstype_uint32 x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_mod_uint32
  (atstype_uint32 x1, atstype_uint32 x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_lsl_uint32
  (atstype_uint32 x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_lsr_uint32
  (atstype_uint32 x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_lnot_uint32
  (atstype_uint32 x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_lor_uint32
  (atstype_uint32 x, atstype_uint32 y) { return (x | y) ; }
// end of [atspre_g0uint_uint32_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_land_uint32
  (atstype_uint32 x, atstype_uint32 y) { return (x & y) ; }
// end of [atspre_g0uint_uint32_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_lxor_uint32
  (atstype_uint32 x, atstype_uint32 y) { return (x ^ y) ; }
// end of [atspre_g0uint_uint32_uint32]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uint32 (atstype_uint32 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uint32]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uint32 (atstype_uint32 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uint32]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uint32 (atstype_uint32 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uint32]
ATSinline()
atstype_bool
atspre_g0uint_lt_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uint32]
ATSinline()
atstype_bool
atspre_g0uint_lte_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uint32]
ATSinline()
atstype_bool
atspre_g0uint_gt_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uint32]
ATSinline()
atstype_bool
atspre_g0uint_gte_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uint32]
ATSinline()
atstype_bool
atspre_g0uint_eq_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uint32]
ATSinline()
atstype_bool
atspre_g0uint_neq_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uint32]
ATSinline()
atstype_uint64
atspre_g0uint_succ_uint64
  (atstype_uint64 x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_pred_uint64
  (atstype_uint64 x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_half_uint64
  (atstype_uint64 x) { return (x >> 1) ; }
// end of [atspre_g0uint_pred_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_add_uint64
  (atstype_uint64 x1, atstype_uint64 x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_sub_uint64
  (atstype_uint64 x1, atstype_uint64 x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_mul_uint64
  (atstype_uint64 x1, atstype_uint64 x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_div_uint64
  (atstype_uint64 x1, atstype_uint64 x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_mod_uint64
  (atstype_uint64 x1, atstype_uint64 x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_lsl_uint64
  (atstype_uint64 x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_lsr_uint64
  (atstype_uint64 x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_lnot_uint64
  (atstype_uint64 x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_lor_uint64
  (atstype_uint64 x, atstype_uint64 y) { return (x | y) ; }
// end of [atspre_g0uint_uint64_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_land_uint64
  (atstype_uint64 x, atstype_uint64 y) { return (x & y) ; }
// end of [atspre_g0uint_uint64_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_lxor_uint64
  (atstype_uint64 x, atstype_uint64 y) { return (x ^ y) ; }
// end of [atspre_g0uint_uint64_uint64]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uint64 (atstype_uint64 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uint64]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uint64 (atstype_uint64 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uint64]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uint64 (atstype_uint64 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uint64]
ATSinline()
atstype_bool
atspre_g0uint_lt_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uint64]
ATSinline()
atstype_bool
atspre_g0uint_lte_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uint64]
ATSinline()
atstype_bool
atspre_g0uint_gt_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uint64]
ATSinline()
atstype_bool
atspre_g0uint_gte_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uint64]
ATSinline()
atstype_bool
atspre_g0uint_eq_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uint64]
ATSinline()
atstype_bool
atspre_g0uint_neq_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uint64]
//
/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_INTEGER_FIXED

/* ****** ****** */

/* end of [integer_fixed.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/option.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_OPTION
#define ATSLIB_PRELUDE_CATS_OPTION

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_OPTION

/* ****** ****** */

/* end of [option.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/string.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_STRING
#define ATSLIB_PRELUDE_CATS_STRING

/* ****** ****** */
//
// [string.h]
//
extern
size_t strlen (const char *str) ;
extern
int // (sign)
strcmp (const char *x1, const char *x2) ;
//
extern
char *strchr(const char *str1, int c2) ;
extern
char *strrchr(const char *str1, int c2) ;
extern
char *strstr(const char *str1, const char *str2) ;
//
extern
size_t strspn(const char *str1, const char *acc2) ;
extern
size_t strcspn(const char *str1, const char *rej2) ;
//
#ifndef memcpy
extern
void *memcpy(void *dest, const void *src, size_t n) ;
#endif // #ifndef
//
/* ****** ****** */

#define atspre_stropt_none() atsptr_null

/* ****** ****** */

ATSinline()
atstype_bool
atspre_lt_string_string (
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2) < 0 ? atsbool_true : atsbool_false) ;
} // [atspre_lt_string_string]

ATSinline()
atstype_bool
atspre_lte_string_string (
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2) <= 0 ? atsbool_true : atsbool_false) ;
} // [atspre_lte_string_string]

ATSinline()
atstype_bool
atspre_gt_string_string(
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2) > 0 ? atsbool_true : atsbool_false) ;
} // [atspre_gt_string_string]

ATSinline()
atstype_bool
atspre_gte_string_string (
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2) >= 0 ? atsbool_true : atsbool_false) ;
} // [atspre_gte_string_string]

ATSinline()
atstype_bool
atspre_eq_string_string (
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2)==0 ? atsbool_true : atsbool_false) ;
} // [atspre_eq_string_string]

ATSinline()
atstype_bool
atspre_neq_string_string (
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2)!=0 ? atsbool_true : atsbool_false) ;
} // [atspre_neq_string_string]

/* ****** ****** */

#define atspre_string_equal atspre_eq_string_string
#define atspre_string_noteq atspre_neq_string_string

/* ****** ****** */

ATSinline()
atstype_int
atspre_compare_string_string
  (atstype_string x1, atstype_string x2) { return strcmp((char*)x1, (char*)x2) ; }
// [atspre_compare_string_string]

/* ****** ****** */

#define atspre_strlen strlen
#define atspre_strchr strchr
#define atspre_strrchr strrchr
#define atspre_strstr strstr
#define atspre_strspn strspn
#define atspre_strcspn strcspn

#define atspre_string_memcpy memcpy

/* ****** ****** */
//
// HX-2013-09: declared in [stdio.h]
//
#ifndef snprintf
extern
int snprintf (char *str, size_t size, const char *format, ...) ;
#endif // end of [ifndef]
//
/* ****** ****** */
//
ATSinline()
atstype_string
atspre_g0int2string_int
  (atstype_int x)
{
  size_t n0 ;
  char *res ;
  size_t ntot ;
  n0 = 4 ;
  res = ATS_MALLOC(n0) ;
  ntot = snprintf(res, n0, "%i", x) ;
  if (ntot >= n0)
  {
    ATS_MFREE(res) ;
    res = (char*)ATS_MALLOC(ntot+1) ;
    ntot = snprintf(res, ntot+1, "%i", x) ;
  }
  return res ;
}
//
ATSinline()
atstype_string
atspre_g0int2string_lint
  (atstype_lint x)
{
  size_t n0 ;
  char *res ;
  size_t ntot ;
  n0 = 4 ;
  res = ATS_MALLOC(n0) ;
  ntot = snprintf(res, n0, "%li", x) ;
  if (ntot >= n0)
  {
    ATS_MFREE(res) ;
    res = (char*)ATS_MALLOC(ntot+1) ;
    ntot = snprintf(res, ntot+1, "%li", x) ;
  }
  return res ;
}
//
ATSinline()
atstype_string
atspre_g0int2string_llint
  (atstype_llint x)
{
  size_t n0 ;
  char *res ;
  size_t ntot ;
  n0 = 8 ;
  res = ATS_MALLOC(n0) ;
  ntot = snprintf(res, n0, "%lli", x) ;
  if (ntot >= n0)
  {
    ATS_MFREE(res) ;
    res = (char*)ATS_MALLOC(ntot+1) ;
    ntot = snprintf(res, ntot+1, "%lli", x) ;
  }
  return res ;
}
//
/* ****** ****** */
//
#include <stdarg.h>
//
// HX-2013-11:
// these are implemented in [string.dats]
//
extern
atstype_string // Strptr0
atspre_string_make_snprintf(atstype_string fmt, ...) ;
extern
atstype_string // Strptr0
atspre_string_make_vsnprintf
  (atstype_size bsz0, atstype_string fmt, va_list ap0) ;
//
/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_STRING

/* ****** ****** */

/* end of [string.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/filebas.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_FILEBAS
#define ATSLIB_PRELUDE_CATS_FILEBAS

/* ****** ****** */

#include <stdio.h>
#include <string.h>
#include <sys/stat.h>

/* ****** ****** */

#define atspre_FILE_stdin stdin
#define atspre_FILE_stdout stdout
#define atspre_FILE_stderr stderr

/* ****** ****** */

#define atspre_file_mode_r "r"
#define atspre_file_mode_rr "r+"
#define atspre_file_mode_w "w"
#define atspre_file_mode_ww "w+"
#define atspre_file_mode_a "a"
#define atspre_file_mode_aa "a+"

/* ****** ****** */

ATSinline()
atstype_bool
atspre_test_file_exists
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  return (err==0) ? atsbool_true : atsbool_false ;
} // end of [atspre_test_file_exists]

/* ****** ****** */

ATSinline()
atstype_int
atspre_test_file_mode_fun
(
  atstype_string path, atstype_funptr pred
)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return ((atstype_bool(*)(atstype_uint))(pred))(st.st_mode) ? 1 : 0 ;
}

/* ****** ****** */

ATSinline()
atstype_bool
atspre_test_file_isreg
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return (S_ISREG(st.st_mode)) ? 1 : 0 ;
} // end of [atspre_test_file_isreg]

/* ****** ****** */

ATSinline()
atstype_int
atspre_test_file_isdir
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return (S_ISDIR(st.st_mode)) ? 1 : 0 ;
} // end of [atspre_test_file_isdir]

/* ****** ****** */

ATSinline()
atstype_int
atspre_test_file_isblk
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return (S_ISBLK(st.st_mode)) ? 1 : 0 ;
} // end of [atspre_test_file_isblk]

/* ****** ****** */

ATSinline()
atstype_int
atspre_test_file_ischr
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return (S_ISCHR(st.st_mode)) ? 1 : 0 ;
} // end of [atspre_test_file_ischr]

/* ****** ****** */

ATSinline()
atstype_int
atspre_test_file_isfifo
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return (S_ISFIFO(st.st_mode)) ? 1 : 0 ;
} // end of [atspre_test_file_isfifo]

/* ****** ****** */

ATSinline()
atstype_ref
atspre_fileref_open_exn
  (atstype_string path, atstype_string fm)
{
  FILE* filr ;
  filr = fopen((char*)path, (char*)fm) ;
  if (!filr) {
    fprintf(
      stderr
    , "exit(ATS): [atspre_fileref_open_exn(%s, %s)] failed.\n"
    , (char*)path, (char*)fm
    ) ;
    exit(1) ;
  }
  return filr ;
} // end of [atspre_fileref_open]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fileref_close
  (atstype_ref filr)
{
  int err ;
  err = fclose((FILE*)filr) ;
  if (err < 0) {
    fprintf(
      stderr
    , "exit(ATS): [atspre_fileref_close] failed.\n"
    ) ;
    exit(1) ;
  }
  return ;
} // end of [atspre_fileref_close]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fileref_flush
  (atstype_ref filr)
{
  int err ;
  err = fflush((FILE*)filr) ;
  if (err < 0) {
    fprintf(
      stderr
    , "exit(ATS): [atspre_fileref_fflush] failed.\n"
    ) ;
    exit(1) ;
  }
  return ;
} // end of [atspre_fileref_flush]

/* ****** ****** */

ATSinline()
atstype_int
atspre_fileref_getc
  (atstype_ref filr) { return fgetc((FILE*)filr) ; }
// end of [atspre_fileref_getc]

/* ****** ****** */
//
ATSinline()
atsvoid_t0ype
atspre_fileref_putc
(
  atstype_ref filr, atstype_int c
) {
  fputc (c, (FILE*)filr) ; return ;
} // end of [atspre_fileref_putc]
//
#define atspre_fileref_putc_int atspre_fileref_putc
#define atspre_fileref_putc_char atspre_fileref_putc
//
/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fileref_puts
(
  atstype_ref filr, atstype_ptr cs
) {
  fputs ((char*)cs, (FILE*)filr) ; return ;
} // end of [atspre_fileref_puts]

/* ****** ****** */

ATSinline()
atstype_bool
atspre_fileref_is_eof
  (atstype_ref filr)
{
  int eof ;
  eof = feof ((FILE*)filr) ;
  return (eof != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_is_eof]

/* ****** ****** */

ATSinline()
atstype_bool
atspre_fileref_load_int
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%i", (atstype_int*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_int]

ATSinline()
atstype_bool
atspre_fileref_load_lint
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%li", (atstype_lint*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_lint]

/* ****** ****** */

ATSinline()
atstype_bool
atspre_fileref_load_uint
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%u", (atstype_uint*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_uint]

ATSinline()
atstype_bool
atspre_fileref_load_ulint
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%lu", (atstype_ulint*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_ulint]

/* ****** ****** */

ATSinline()
atstype_bool
atspre_fileref_load_float
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%f", (atstype_float*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_float]

ATSinline()
atstype_bool
atspre_fileref_load_double
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%lf", (atstype_double*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_double]

/* ****** ****** */

extern
atstype_ptr
atspre_fileref_get_line_string_main2
(
  atstype_int bsz // int bsz
, atstype_ptr filp // FILE* filp
, atstype_ref nlen // int *nlen
) ; // endfun

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_FILEBAS

/* ****** ****** */

/* end of [filebas.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/matrixref.atxt
** Time of generation: Sat Oct 17 15:20:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_MATRIXREF
#define ATSLIB_PRELUDE_CATS_MATRIXREF

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_MATRIXREF

/* ****** ****** */

/* end of [matrixref.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/arrayref.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_ARRAYREF
#define ATSLIB_PRELUDE_CATS_ARRAYREF

/* ****** ****** */

ATSinline()
atstype_arrptr
atspre_arrayref_make_arrpsz
  (atstype_arrpsz psz) { return (psz).ptr ; }
// end of [atspre_arrayref_make_arrpsz]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_ARRAYREF

/* ****** ****** */

/* end of [arrayref.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/float.atxt
** Time of generation: Sat Oct 17 15:20:02 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_FLOAT
#define ATSLIB_PRELUDE_CATS_FLOAT

/* ****** ****** */

ATSinline()
atstype_float
atspre_g0int2float_int_float
  (atstype_int x) { return ((atstype_float)x) ; }
// end of [atspre_g0int2float_int_float]

ATSinline()
atstype_double
atspre_g0int2float_int_double
  (atstype_int x) { return ((atstype_double)x) ; }
// end of [atspre_g0int2float_int_double]

ATSinline()
atstype_double
atspre_g0int2float_lint_double
  (atstype_lint x) { return ((atstype_double)x) ; }
// end of [atspre_g0int2float_lint_double]

/* ****** ****** */

ATSinline()
atstype_int
atspre_g0float2int_float_int
  (atstype_float x) { return ((atstype_int)x) ; }
ATSinline()
atstype_lint
atspre_g0float2int_float_lint
  (atstype_float x) { return ((atstype_lint)x) ; }
ATSinline()
atstype_llint
atspre_g0float2int_float_llint
  (atstype_float x) { return ((atstype_llint)x) ; }

ATSinline()
atstype_int
atspre_g0float2int_double_int
  (atstype_double x) { return ((atstype_int)x) ; }
ATSinline()
atstype_lint
atspre_g0float2int_double_lint
  (atstype_double x) { return ((atstype_lint)x) ; }
ATSinline()
atstype_llint
atspre_g0float2int_double_llint
  (atstype_double x) { return ((atstype_llint)x) ; }

/* ****** ****** */

ATSinline()
atstype_float
atspre_g0float2float_float_float (atstype_float x) { return (x) ; }

ATSinline()
atstype_double
atspre_g0float2float_double_double (atstype_double x) { return (x) ; }

ATSinline()
atstype_double
atspre_g0float2float_float_double
(
atstype_float x
)
{
 return ((atstype_double)x) ;
}

ATSinline()
atstype_float
atspre_g0float2float_double_float
(
atstype_double x
)
{
 return ((atstype_float)x) ;
}

/* ****** ****** */
//
extern double atof (const char *inp) ;
//
ATSinline()
atstype_int
atspre_g0string2float_double
  (atstype_string inp) { return atof((char*)inp) ; }
//
/* ****** ****** */

ATSinline()
atstype_float
atspre_g0float_neg_float (atstype_float f) { return (-f) ; }
ATSinline()
atstype_double
atspre_g0float_neg_double (atstype_double f) { return (-f) ; }
ATSinline()
atstype_ldouble
atspre_g0float_neg_ldouble (atstype_ldouble f) { return (-f) ; }

ATSinline()
atstype_float
atspre_g0float_abs_float (atstype_float f) { return (f >= 0 ? f : -f) ; }
ATSinline()
atstype_double
atspre_g0float_abs_double (atstype_double f) { return (f >= 0 ? f : -f) ; }
ATSinline()
atstype_ldouble
atspre_g0float_abs_ldouble (atstype_ldouble f) { return (f >= 0 ? f : -f) ; }

ATSinline()
atstype_float
atspre_g0float_succ_float (atstype_float f) { return (f+1) ; }
ATSinline()
atstype_double
atspre_g0float_succ_double (atstype_double f) { return (f+1) ; }
ATSinline()
atstype_ldouble
atspre_g0float_succ_ldouble (atstype_ldouble f) { return (f+1) ; }

ATSinline()
atstype_float
atspre_g0float_pred_float (atstype_float f) { return (f-1) ; }
ATSinline()
atstype_double
atspre_g0float_pred_double (atstype_double f) { return (f-1) ; }
ATSinline()
atstype_ldouble
atspre_g0float_pred_ldouble (atstype_ldouble f) { return (f-1) ; }

/* ****** ****** */

//
ATSinline()
atstype_float
atspre_g0float_add_float
  (atstype_float f1, atstype_float f2) { return (f1 + f2) ; }
// end of [atspre_g0float_add_float]
ATSinline()
atstype_float
atspre_g0float_sub_float
  (atstype_float f1, atstype_float f2) { return (f1 - f2) ; }
// end of [atspre_g0float_sub_float]
ATSinline()
atstype_float
atspre_g0float_mul_float
  (atstype_float f1, atstype_float f2) { return (f1 * f2) ; }
// end of [atspre_g0float_mul_float]
ATSinline()
atstype_float
atspre_g0float_div_float
  (atstype_float f1, atstype_float f2) { return (f1 / f2) ; }
// end of [atspre_g0float_div_float]
//
ATSinline()
atstype_double
atspre_g0float_add_double
  (atstype_double f1, atstype_double f2) { return (f1 + f2) ; }
// end of [atspre_g0float_add_double]
ATSinline()
atstype_double
atspre_g0float_sub_double
  (atstype_double f1, atstype_double f2) { return (f1 - f2) ; }
// end of [atspre_g0float_sub_double]
ATSinline()
atstype_double
atspre_g0float_mul_double
  (atstype_double f1, atstype_double f2) { return (f1 * f2) ; }
// end of [atspre_g0float_mul_double]
ATSinline()
atstype_double
atspre_g0float_div_double
  (atstype_double f1, atstype_double f2) { return (f1 / f2) ; }
// end of [atspre_g0float_div_double]
//
ATSinline()
atstype_ldouble
atspre_g0float_add_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 + f2) ; }
// end of [atspre_g0float_add_ldouble]
ATSinline()
atstype_ldouble
atspre_g0float_sub_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 - f2) ; }
// end of [atspre_g0float_sub_ldouble]
ATSinline()
atstype_ldouble
atspre_g0float_mul_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 * f2) ; }
// end of [atspre_g0float_mul_ldouble]
ATSinline()
atstype_ldouble
atspre_g0float_div_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 / f2) ; }
// end of [atspre_g0float_div_ldouble]
//
extern atstype_float fmodf (atstype_float, atstype_float) ;
extern atstype_double fmod (atstype_double, atstype_double) ;
extern atstype_ldouble fmodl (atstype_ldouble, atstype_ldouble) ;
//
ATSinline()
atstype_float
atspre_g0float_mod_float
  (atstype_float f1, atstype_float f2) { return fmodf(f1, f2) ; }
ATSinline()
atstype_double
atspre_g0float_mod_double
  (atstype_double f1, atstype_double f2) { return fmod(f1, f2) ; }
ATSinline()
atstype_ldouble
atspre_g0float_mod_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return fmodl(f1, f2) ; }
//
/* ****** ****** */

//
ATSinline()
atstype_bool
atspre_g0float_lt_float
  (atstype_float f1, atstype_float f2) {
  return (f1 < f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lt_float]
ATSinline()
atstype_bool
atspre_g0float_lte_float
  (atstype_float f1, atstype_float f2) {
  return (f1 <= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lte_float]
ATSinline()
atstype_bool
atspre_g0float_gt_float
  (atstype_float f1, atstype_float f2) {
  return (f1 > f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gt_float]
ATSinline()
atstype_bool
atspre_g0float_gte_float
  (atstype_float f1, atstype_float f2) {
  return (f1 >= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gte_float]
ATSinline()
atstype_bool
atspre_g0float_eq_float
  (atstype_float f1, atstype_float f2) {
  return (f1 == f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_eq_float]
ATSinline()
atstype_bool
atspre_g0float_neq_float
  (atstype_float f1, atstype_float f2) {
  return (f1 != f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_neq_float]
//
ATSinline()
atstype_bool
atspre_g0float_lt_double
  (atstype_double f1, atstype_double f2) {
  return (f1 < f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lt_double]
ATSinline()
atstype_bool
atspre_g0float_lte_double
  (atstype_double f1, atstype_double f2) {
  return (f1 <= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lte_double]
ATSinline()
atstype_bool
atspre_g0float_gt_double
  (atstype_double f1, atstype_double f2) {
  return (f1 > f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gt_double]
ATSinline()
atstype_bool
atspre_g0float_gte_double
  (atstype_double f1, atstype_double f2) {
  return (f1 >= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gte_double]
ATSinline()
atstype_bool
atspre_g0float_eq_double
  (atstype_double f1, atstype_double f2) {
  return (f1 == f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_eq_double]
ATSinline()
atstype_bool
atspre_g0float_neq_double
  (atstype_double f1, atstype_double f2) {
  return (f1 != f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_neq_double]
//
ATSinline()
atstype_bool
atspre_g0float_lt_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 < f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lt_ldouble]
ATSinline()
atstype_bool
atspre_g0float_lte_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 <= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lte_ldouble]
ATSinline()
atstype_bool
atspre_g0float_gt_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 > f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gt_ldouble]
ATSinline()
atstype_bool
atspre_g0float_gte_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 >= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gte_ldouble]
ATSinline()
atstype_bool
atspre_g0float_eq_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 == f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_eq_ldouble]
ATSinline()
atstype_bool
atspre_g0float_neq_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 != f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_neq_ldouble]
//
/* ****** ****** */

ATSinline()
atstype_int
atspre_g0float_compare_float
(
  atstype_float f1, atstype_float f2
)
{
  if (f1 > f2) return 1 ; else if (f1 < f2) return -1 ; else return 0 ;
} // end of [atspre_g0float_compare_float]

ATSinline()
atstype_int
atspre_g0float_compare_double
(
  atstype_double f1, atstype_double f2
)
{
  if (f1 > f2) return 1 ; else if (f1 < f2) return -1 ; else return 0 ;
} // end of [atspre_g0float_compare_double]

ATSinline()
atstype_int
atspre_g0float_compare_ldouble
(
  atstype_ldouble f1, atstype_ldouble f2
)
{
  if (f1 > f2) return 1 ; else if (f1 < f2) return -1 ; else return 0 ;
} // end of [atspre_g0float_compare_ldouble]

/* ****** ****** */

ATSinline()
atstype_float
atspre_g0float_min_float
  (atstype_float f1, atstype_float f2) { return (f1 <= f2 ? f1 : f2) ; }
// end of [atspre_g0float_min_float]
ATSinline()
atstype_double
atspre_g0float_min_double
  (atstype_double f1, atstype_double f2) { return (f1 <= f2 ? f1 : f2) ; }
// end of [atspre_g0float_min_double]
ATSinline()
atstype_ldouble
atspre_g0float_min_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 <= f2 ? f1 : f2) ; }
// end of [atspre_g0float_min_ldouble]

ATSinline()
atstype_float
atspre_g0float_max_float
  (atstype_float f1, atstype_float f2) { return (f1 >= f2 ? f1 : f2) ; }
// end of [atspre_g0float_max_float]
ATSinline()
atstype_double
atspre_g0float_max_double
  (atstype_double f1, atstype_double f2) { return (f1 >= f2 ? f1 : f2) ; }
// end of [atspre_g0float_max_double]
ATSinline()
atstype_ldouble
atspre_g0float_max_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 >= f2 ? f1 : f2) ; }
// end of [atspre_g0float_max_ldouble]

/* ****** ****** */

//
ATSinline()
atstype_float
atspre_add_int_float
  (atstype_int i1, atstype_float f2) { return (((atstype_float)i1) + f2) ; }
// end of [atspre_add_int_float]
ATSinline()
atstype_float
atspre_sub_int_float
  (atstype_int i1, atstype_float f2) { return (((atstype_float)i1) - f2) ; }
// end of [atspre_sub_int_float]
ATSinline()
atstype_float
atspre_mul_int_float
  (atstype_int i1, atstype_float f2) { return (((atstype_float)i1) * f2) ; }
// end of [atspre_mul_int_float]
ATSinline()
atstype_float
atspre_div_int_float
  (atstype_int i1, atstype_float f2) { return (((atstype_float)i1) / f2) ; }
// end of [atspre_div_int_float]
//
ATSinline()
atstype_double
atspre_add_int_double
  (atstype_int i1, atstype_double f2) { return (((atstype_double)i1) + f2) ; }
// end of [atspre_add_int_double]
ATSinline()
atstype_double
atspre_sub_int_double
  (atstype_int i1, atstype_double f2) { return (((atstype_double)i1) - f2) ; }
// end of [atspre_sub_int_double]
ATSinline()
atstype_double
atspre_mul_int_double
  (atstype_int i1, atstype_double f2) { return (((atstype_double)i1) * f2) ; }
// end of [atspre_mul_int_double]
ATSinline()
atstype_double
atspre_div_int_double
  (atstype_int i1, atstype_double f2) { return (((atstype_double)i1) / f2) ; }
// end of [atspre_div_int_double]
//
ATSinline()
atstype_ldouble
atspre_add_int_ldouble
  (atstype_int i1, atstype_ldouble f2) { return (((atstype_ldouble)i1) + f2) ; }
// end of [atspre_add_int_ldouble]
ATSinline()
atstype_ldouble
atspre_sub_int_ldouble
  (atstype_int i1, atstype_ldouble f2) { return (((atstype_ldouble)i1) - f2) ; }
// end of [atspre_sub_int_ldouble]
ATSinline()
atstype_ldouble
atspre_mul_int_ldouble
  (atstype_int i1, atstype_ldouble f2) { return (((atstype_ldouble)i1) * f2) ; }
// end of [atspre_mul_int_ldouble]
ATSinline()
atstype_ldouble
atspre_div_int_ldouble
  (atstype_int i1, atstype_ldouble f2) { return (((atstype_ldouble)i1) / f2) ; }
// end of [atspre_div_int_ldouble]
//
/* ****** ****** */

//
ATSinline()
atstype_float
atspre_add_float_int
  (atstype_float f1, atstype_int i2) { return (f1 + ((atstype_float)i2)) ; }
// end of [atspre_add_float_int]
ATSinline()
atstype_float
atspre_sub_float_int
  (atstype_float f1, atstype_int i2) { return (f1 - ((atstype_float)i2)) ; }
// end of [atspre_sub_float_int]
ATSinline()
atstype_float
atspre_mul_float_int
  (atstype_float f1, atstype_int i2) { return (f1 * ((atstype_float)i2)) ; }
// end of [atspre_mul_float_int]
ATSinline()
atstype_float
atspre_div_float_int
  (atstype_float f1, atstype_int i2) { return (f1 / ((atstype_float)i2)) ; }
// end of [atspre_div_float_int]
//
ATSinline()
atstype_double
atspre_add_double_int
  (atstype_double f1, atstype_int i2) { return (f1 + ((atstype_double)i2)) ; }
// end of [atspre_add_double_int]
ATSinline()
atstype_double
atspre_sub_double_int
  (atstype_double f1, atstype_int i2) { return (f1 - ((atstype_double)i2)) ; }
// end of [atspre_sub_double_int]
ATSinline()
atstype_double
atspre_mul_double_int
  (atstype_double f1, atstype_int i2) { return (f1 * ((atstype_double)i2)) ; }
// end of [atspre_mul_double_int]
ATSinline()
atstype_double
atspre_div_double_int
  (atstype_double f1, atstype_int i2) { return (f1 / ((atstype_double)i2)) ; }
// end of [atspre_div_double_int]
//
ATSinline()
atstype_ldouble
atspre_add_ldouble_int
  (atstype_ldouble f1, atstype_int i2) { return (f1 + ((atstype_ldouble)i2)) ; }
// end of [atspre_add_ldouble_int]
ATSinline()
atstype_ldouble
atspre_sub_ldouble_int
  (atstype_ldouble f1, atstype_int i2) { return (f1 - ((atstype_ldouble)i2)) ; }
// end of [atspre_sub_ldouble_int]
ATSinline()
atstype_ldouble
atspre_mul_ldouble_int
  (atstype_ldouble f1, atstype_int i2) { return (f1 * ((atstype_ldouble)i2)) ; }
// end of [atspre_mul_ldouble_int]
ATSinline()
atstype_ldouble
atspre_div_ldouble_int
  (atstype_ldouble f1, atstype_int i2) { return (f1 / ((atstype_ldouble)i2)) ; }
// end of [atspre_div_ldouble_int]
//
/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_FLOAT

/* ****** ****** */

/* end of [float.cats] */

