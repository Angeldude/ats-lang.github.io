

<!DOCTYPE html>
<html>

<head>
<meta
 http-equiv="content-type"
 content="text/html; charset=UTF-8" />
<title>EFFECTIVATS-ssntyped-channels-introduction</title>
#__tok1$
</head>

<body>

<h1>
Effective ATS:<br>
Session-typed Channels:<br>
A Brief Introduction
</h1>

<p>
In this article, I present a brief introduction to session types.
</p>

<h2>
Basics on session-typed channels
</h2>

<p>
In broad terms, a (dyadic) session is a sequence of interactions between
two concurrently running processes, and a session type is a form of type
for specifying (or classifying) such interactions. As an example, let us
assume that two processes P and Q are connected via a bidirectional
channel. From the perspective of P, the channel may be specified by a term
sequence of the following form: </p>

<pre
class="patsyntax">
#__tok2$</pre>

<p>
which means that an integer is to be sent, another integer is to be
sent, a boolean is to be received, and finally the channel is to be
closed.  Clearly, from the perspective of Q, the channel should be
specified by the following term sequence:
</p>

<pre
class="patsyntax">
#__tok3$</pre>

<p>
which means precisely the dual of what the previous term sequence
does.  We may think of P as a client who sends two integers to the
server Q and then receives from Q either true or false depending on
whether or not the first sent integer is less than the second one.
</p>

<p>
There are two endpoints in a channel: a positive end and a negative end;
the end held by the server is positive and the end held by the client is
negative. We introduce two abstract types #__tok4$ and
#__tok5$ for positive channels and negative channels,
respectively, where a positive (negative) channel refers to the positive
(negative) end of a channel:
</p>

<pre
class="patsyntax">
#__tok6$</pre>

<p>
For instance, the end of the channel held by P is assigned the
type #__tok7$ (not #__tok8$) and
the end of the channel held by Q is assigned the type #__tok9$.
So the interpretation of a session type is given based on the view of the
positive end (that is, the server).
</p>

<p>
The functions for sending data on channels are given the following types:
</p>

<pre
class="patsyntax">
#__tok10$</pre>

<p>
Note that #__tok11$ is for sending a value on a positive
channel while #__tok12$ is for sending a value on a
negative channel. For convenience, the symbol #__tok13$ is
overloaded with both of these functions.
</p>

<p>
The functions for receiving data sent on channels are given the following types:
</p>

<pre
class="patsyntax">
#__tok14$</pre>

<p>
Note that #__tok15$ is for receiving a value on a positive
channel while #__tok16$ is for receiving a value on a
negative channel. For convenience, the symbol #__tok17$ is
overloaded with both of these functions.
</p>

<p>
The functions for closing channels are given the following types:
</p>

<pre
class="patsyntax">
#__tok18$</pre>

<p>
Note that #__tok19$ is for closing a positive
channel while #__tok20$ is for closing a negative
channel. More specifically, a call to #__tok21$ on
(the positive end of) a channel waits until a message sent by a call
to #__tok22$ on (the negative end of) the same
channel arrives.  For convenience, the symbol #__tok23$
is overloaded with both of these functions.
</p>

<p>
The functions for sending and receiving can be based
on either synchronous or asynchronous communication. Calling these
functions may result in the caller to be blocked. For instance,
calling #__tok24$ blocks the caller if there is no
value available for the call to return. For asynchronous communication,
calling #__tok25$ may block the caller if there is no
more room available for buffering.
</p>

<p>
The programs for the processes P and Q can be implemented as follows:
</p>

<pre
class="patsyntax">
#__tok26$</pre>

<p>
But how a channel can be created in the first place? The answer
to this question depends on the underlying support for distributed
programming. For instance, we may be able to introduce the following
function #__tok27$ for creating a channel:

<pre
class="patsyntax">
#__tok28$</pre>

The basic idea here is to spawn a thread (by executing the linear
closure-function #__tok29$) that works on the postive end of
the newly created channel and then returns the negative end of the
channel to the caller.
</p>

<h2>
Session-typed channels based on web-workers
</h2>

<p>
In the rest of this article, I will give a concrete presentation of
session-typed channels that are implemented based on web-workers.  For
those who are not yet familiar with web-workers, it can be a good idea
to first study some programming examples involving them before reading
on. Essentially, a web-worker is a thread running in the background
that can communicate with the browser via message-passing.  The ATS
code presented as follows is intended to be compiled into JS code (via
Patsopt and Atscc2js) for running in the browser (client) and a
web-worker (server). As JS (or, more precisely, its run-time) is
single-threaded, we cannot support a function (e.g.,
#__tok30$) that may block its caller indefinitely. We
address this issue by building an interface for programming
session-typed channels that is of CPS-style (where CPS stands for
continuation-passing style).
</p>

<p>
Let us first see the types assigned to the functions for closing
channels:

<pre
class="patsyntax">
#__tok31$</pre>

Clearly, everything is standard here, and there is really no surprise at all.

</p>

<p>

Let us next see the types assigned to the functions for sending and receiving
on channels:

<pre
class="patsyntax">
#__tok32$</pre>

Given a type T, the type #__tok33$ is for the marshalled
representation of a value of the type T. The type assigned to the
function #__tok34$ indicates that the function takes
three arguments: a positive channel, a value (to be sent), and a
continuation; the channel is passed to the continuation after the
value is sent onto the channel. Also, the type assigned to the
function #__tok35$ indicates that the function takes
two arguments: a positive channel and a continuation; the channel and
the marshalled representation of a value are passed to the
continutation after the representation is received. The types assigned
to the functions #__tok36$ and
#__tok37$ can be explained similarly.

</p>

<p>

The above functions #__tok38$ and #__tok39$ can now be implemented
as follows:

<pre
class="patsyntax">
#__tok40$</pre>

Note that #__tok41$ is a function template for
unmarshalling: It is called to turn the marshalled representation of a
value into the value itself.

</p>

<p>
A simple demo based on the code for #__tok42$ and #__tok43$ is
available <a href="./introxmpl1_demo.html">on-line</a>. The entirety
of the code for this demo can be found in four files of the following
names:

<pre>
introxmpl1_demo.html
introxmpl1_prctl.sats
introxmpl1_client.dats
introxmpl1_server.dats
</pre>

In the file #__tok44$, the protocol for
communincations between the client (browser) and the server
(web-worker) is formally represented as a session type. As can be
expected, this file is statically loaded in both
#__tok45$ and
#__tok46$.  The client code (in
#__tok47$) is based on the code for
#__tok48$ but contains various significant modifications, and it
makes use of Bacon.js in its handling GUI issues. On the other hand,
the server code (in #__tok49$) is directly
based on the code for #__tok50$ with virtually no modifications. I
strongly encourage the reader to use the provided Makefile to build
the demo on his/her own.

</p>

<hr size="2">

This article is written by <a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.

</body>
</html>


