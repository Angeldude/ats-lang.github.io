<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Generating a fprint-function</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="A Tutorial on Programming Features in ATS"
HREF="book1.html"><LINK
REL="UP"
TITLE="Automatic Code Generation"
HREF="c1360.html"><LINK
REL="PREVIOUS"
TITLE="Generating a datcontag-function"
HREF="x1397.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./assets/ATS2TUTORIAL-BOOK.css"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>A Tutorial on Programming Features in ATS: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x1397.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 29. Automatic Code Generation</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
>&nbsp;</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="codegen2_fprint"
>Generating a fprint-function</A
></H1
><P
>&#13;A fprint-function takes a file-handle (of the type
<FONT
COLOR="RED"
>FILEref</FONT
>) and a value and then outputs a text
representation of the value to the file-handle.  Given a datatype, one
is often in need of a function that can output certain kind of text
representation for values of this datatype. For instance, such a
function can be of great use in debugging.
</P
><P
>&#13;Let us first declare a function template <FONT
COLOR="RED"
>fprint_expr_</FONT
> as
follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1422"
></A
><PRE
CLASS="programlisting"
>############sats2xhtml_docbook("""fun{}
fprint_expr_ : (FILEref, expr) -&#62; void // a function template
""")</PRE
><P
></P
></DIV
>


We can then use the directive below to indicate (to the ATS compiler) that
the fprint-function for the datatype <FONT
COLOR="RED"
>expr</FONT
> needs to be generated:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1425"
></A
><PRE
CLASS="programlisting"
>############sats2xhtml_docbook("""#codegen2("fprint", expr, fprint_expr_)
""")</PRE
><P
></P
></DIV
>


The third argument of the <FONT
COLOR="RED"
>codegen2</FONT
>-directive can be omitted
in this case as it coincides with the default. The generated code that
implements <FONT
COLOR="RED"
>fprint_expr_</FONT
> is listed as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1429"
></A
><PRE
CLASS="programlisting"
>############dats2xhtml_docbook("""(* ****** ****** *)
//
extern
fun{}
fprint_expr_$Int: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Var: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Add: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Sub: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Mul: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Div: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtz: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtez: $d2ctype(fprint_expr_&#60;&#62;)
//
(* ****** ****** *)
//
implement{}
fprint_expr_
  (out, arg0) =
(
case+ arg0 of
| Int _ =&#62; fprint_expr_$Int&#60;&#62;(out, arg0)
| Var _ =&#62; fprint_expr_$Var&#60;&#62;(out, arg0)
| Add _ =&#62; fprint_expr_$Add&#60;&#62;(out, arg0)
| Sub _ =&#62; fprint_expr_$Sub&#60;&#62;(out, arg0)
| Mul _ =&#62; fprint_expr_$Mul&#60;&#62;(out, arg0)
| Div _ =&#62; fprint_expr_$Div&#60;&#62;(out, arg0)
| Ifgtz _ =&#62; fprint_expr_$Ifgtz&#60;&#62;(out, arg0)
| Ifgtez _ =&#62; fprint_expr_$Ifgtez&#60;&#62;(out, arg0)
)
//
(* ****** ****** *)
//
extern
fun{}
fprint_expr_$sep: (FILEref) -&#62; void
implement{}
fprint_expr_$sep(out) = fprint(out, ",")
//
extern
fun{}
fprint_expr_$lpar: (FILEref) -&#62; void
implement{}
fprint_expr_$lpar(out) = fprint(out, "(")
//
extern
fun{}
fprint_expr_$rpar: (FILEref) -&#62; void
implement{}
fprint_expr_$rpar(out) = fprint(out, ")")
//
extern
fun{a:t0p}
fprint_expr_$carg: (FILEref, INV(a)) -&#62; void
implement{a}
fprint_expr_$carg(out, arg) = fprint_val&#60;a&#62;(out, arg)
//
(* ****** ****** *)
//
extern
fun{}
fprint_expr_$Int$con: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Int$lpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Int$rpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Int$arg1: $d2ctype(fprint_expr_&#60;&#62;)
//
implement{}
fprint_expr_$Int(out, arg0) = 
{
//
val () = fprint_expr_$Int$con&#60;&#62;(out, arg0)
val () = fprint_expr_$Int$lpar&#60;&#62;(out, arg0)
val () = fprint_expr_$Int$arg1&#60;&#62;(out, arg0)
val () = fprint_expr_$Int$rpar&#60;&#62;(out, arg0)
//
}
implement{}
fprint_expr_$Int$con(out, _) = fprint(out, "Int")
implement{}
fprint_expr_$Int$lpar(out, _) = fprint_expr_$lpar(out)
implement{}
fprint_expr_$Int$rpar(out, _) = fprint_expr_$rpar(out)
implement{}
fprint_expr_$Int$arg1(out, arg0) =
  let val-Int(arg1) = arg0 in fprint_expr_$carg(out, arg1) end
//
extern
fun{}
fprint_expr_$Var$con: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Var$lpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Var$rpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Var$arg1: $d2ctype(fprint_expr_&#60;&#62;)
//
implement{}
fprint_expr_$Var(out, arg0) = 
{
//
val () = fprint_expr_$Var$con&#60;&#62;(out, arg0)
val () = fprint_expr_$Var$lpar&#60;&#62;(out, arg0)
val () = fprint_expr_$Var$arg1&#60;&#62;(out, arg0)
val () = fprint_expr_$Var$rpar&#60;&#62;(out, arg0)
//
}
implement{}
fprint_expr_$Var$con(out, _) = fprint(out, "Var")
implement{}
fprint_expr_$Var$lpar(out, _) = fprint_expr_$lpar(out)
implement{}
fprint_expr_$Var$rpar(out, _) = fprint_expr_$rpar(out)
implement{}
fprint_expr_$Var$arg1(out, arg0) =
  let val-Var(arg1) = arg0 in fprint_expr_$carg(out, arg1) end
//
extern
fun{}
fprint_expr_$Add$con: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Add$lpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Add$rpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Add$sep1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Add$arg1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Add$arg2: $d2ctype(fprint_expr_&#60;&#62;)
//
implement{}
fprint_expr_$Add(out, arg0) = 
{
//
val () = fprint_expr_$Add$con&#60;&#62;(out, arg0)
val () = fprint_expr_$Add$lpar&#60;&#62;(out, arg0)
val () = fprint_expr_$Add$arg1&#60;&#62;(out, arg0)
val () = fprint_expr_$Add$sep1&#60;&#62;(out, arg0)
val () = fprint_expr_$Add$arg2&#60;&#62;(out, arg0)
val () = fprint_expr_$Add$rpar&#60;&#62;(out, arg0)
//
}
implement{}
fprint_expr_$Add$con(out, _) = fprint(out, "Add")
implement{}
fprint_expr_$Add$lpar(out, _) = fprint_expr_$lpar(out)
implement{}
fprint_expr_$Add$rpar(out, _) = fprint_expr_$rpar(out)
implement{}
fprint_expr_$Add$sep1(out, _) = fprint_expr_$sep&#60;&#62;(out)
implement{}
fprint_expr_$Add$arg1(out, arg0) =
  let val-Add(arg1, _) = arg0 in fprint_expr_$carg(out, arg1) end
implement{}
fprint_expr_$Add$arg2(out, arg0) =
  let val-Add(_, arg2) = arg0 in fprint_expr_$carg(out, arg2) end
//
extern
fun{}
fprint_expr_$Sub$con: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Sub$lpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Sub$rpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Sub$sep1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Sub$arg1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Sub$arg2: $d2ctype(fprint_expr_&#60;&#62;)
//
implement{}
fprint_expr_$Sub(out, arg0) = 
{
//
val () = fprint_expr_$Sub$con&#60;&#62;(out, arg0)
val () = fprint_expr_$Sub$lpar&#60;&#62;(out, arg0)
val () = fprint_expr_$Sub$arg1&#60;&#62;(out, arg0)
val () = fprint_expr_$Sub$sep1&#60;&#62;(out, arg0)
val () = fprint_expr_$Sub$arg2&#60;&#62;(out, arg0)
val () = fprint_expr_$Sub$rpar&#60;&#62;(out, arg0)
//
}
implement{}
fprint_expr_$Sub$con(out, _) = fprint(out, "Sub")
implement{}
fprint_expr_$Sub$lpar(out, _) = fprint_expr_$lpar(out)
implement{}
fprint_expr_$Sub$rpar(out, _) = fprint_expr_$rpar(out)
implement{}
fprint_expr_$Sub$sep1(out, _) = fprint_expr_$sep&#60;&#62;(out)
implement{}
fprint_expr_$Sub$arg1(out, arg0) =
  let val-Sub(arg1, _) = arg0 in fprint_expr_$carg(out, arg1) end
implement{}
fprint_expr_$Sub$arg2(out, arg0) =
  let val-Sub(_, arg2) = arg0 in fprint_expr_$carg(out, arg2) end
//
extern
fun{}
fprint_expr_$Mul$con: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Mul$lpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Mul$rpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Mul$sep1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Mul$arg1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Mul$arg2: $d2ctype(fprint_expr_&#60;&#62;)
//
implement{}
fprint_expr_$Mul(out, arg0) = 
{
//
val () = fprint_expr_$Mul$con&#60;&#62;(out, arg0)
val () = fprint_expr_$Mul$lpar&#60;&#62;(out, arg0)
val () = fprint_expr_$Mul$arg1&#60;&#62;(out, arg0)
val () = fprint_expr_$Mul$sep1&#60;&#62;(out, arg0)
val () = fprint_expr_$Mul$arg2&#60;&#62;(out, arg0)
val () = fprint_expr_$Mul$rpar&#60;&#62;(out, arg0)
//
}
implement{}
fprint_expr_$Mul$con(out, _) = fprint(out, "Mul")
implement{}
fprint_expr_$Mul$lpar(out, _) = fprint_expr_$lpar(out)
implement{}
fprint_expr_$Mul$rpar(out, _) = fprint_expr_$rpar(out)
implement{}
fprint_expr_$Mul$sep1(out, _) = fprint_expr_$sep&#60;&#62;(out)
implement{}
fprint_expr_$Mul$arg1(out, arg0) =
  let val-Mul(arg1, _) = arg0 in fprint_expr_$carg(out, arg1) end
implement{}
fprint_expr_$Mul$arg2(out, arg0) =
  let val-Mul(_, arg2) = arg0 in fprint_expr_$carg(out, arg2) end
//
extern
fun{}
fprint_expr_$Div$con: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Div$lpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Div$rpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Div$sep1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Div$arg1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Div$arg2: $d2ctype(fprint_expr_&#60;&#62;)
//
implement{}
fprint_expr_$Div(out, arg0) = 
{
//
val () = fprint_expr_$Div$con&#60;&#62;(out, arg0)
val () = fprint_expr_$Div$lpar&#60;&#62;(out, arg0)
val () = fprint_expr_$Div$arg1&#60;&#62;(out, arg0)
val () = fprint_expr_$Div$sep1&#60;&#62;(out, arg0)
val () = fprint_expr_$Div$arg2&#60;&#62;(out, arg0)
val () = fprint_expr_$Div$rpar&#60;&#62;(out, arg0)
//
}
implement{}
fprint_expr_$Div$con(out, _) = fprint(out, "Div")
implement{}
fprint_expr_$Div$lpar(out, _) = fprint_expr_$lpar(out)
implement{}
fprint_expr_$Div$rpar(out, _) = fprint_expr_$rpar(out)
implement{}
fprint_expr_$Div$sep1(out, _) = fprint_expr_$sep&#60;&#62;(out)
implement{}
fprint_expr_$Div$arg1(out, arg0) =
  let val-Div(arg1, _) = arg0 in fprint_expr_$carg(out, arg1) end
implement{}
fprint_expr_$Div$arg2(out, arg0) =
  let val-Div(_, arg2) = arg0 in fprint_expr_$carg(out, arg2) end
//
extern
fun{}
fprint_expr_$Ifgtz$con: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtz$lpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtz$rpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtz$sep1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtz$sep2: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtz$arg1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtz$arg2: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtz$arg3: $d2ctype(fprint_expr_&#60;&#62;)
//
implement{}
fprint_expr_$Ifgtz(out, arg0) = 
{
//
val () = fprint_expr_$Ifgtz$con&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtz$lpar&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtz$arg1&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtz$sep1&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtz$arg2&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtz$sep2&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtz$arg3&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtz$rpar&#60;&#62;(out, arg0)
//
}
implement{}
fprint_expr_$Ifgtz$con(out, _) = fprint(out, "Ifgtz")
implement{}
fprint_expr_$Ifgtz$lpar(out, _) = fprint_expr_$lpar(out)
implement{}
fprint_expr_$Ifgtz$rpar(out, _) = fprint_expr_$rpar(out)
implement{}
fprint_expr_$Ifgtz$sep1(out, _) = fprint_expr_$sep&#60;&#62;(out)
implement{}
fprint_expr_$Ifgtz$sep2(out, _) = fprint_expr_$sep&#60;&#62;(out)
implement{}
fprint_expr_$Ifgtz$arg1(out, arg0) =
  let val-Ifgtz(arg1, _, _) = arg0 in fprint_expr_$carg(out, arg1) end
implement{}
fprint_expr_$Ifgtz$arg2(out, arg0) =
  let val-Ifgtz(_, arg2, _) = arg0 in fprint_expr_$carg(out, arg2) end
implement{}
fprint_expr_$Ifgtz$arg3(out, arg0) =
  let val-Ifgtz(_, _, arg3) = arg0 in fprint_expr_$carg(out, arg3) end
//
extern
fun{}
fprint_expr_$Ifgtez$con: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtez$lpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtez$rpar: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtez$sep1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtez$sep2: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtez$arg1: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtez$arg2: $d2ctype(fprint_expr_&#60;&#62;)
extern
fun{}
fprint_expr_$Ifgtez$arg3: $d2ctype(fprint_expr_&#60;&#62;)
//
implement{}
fprint_expr_$Ifgtez(out, arg0) = 
{
//
val () = fprint_expr_$Ifgtez$con&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtez$lpar&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtez$arg1&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtez$sep1&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtez$arg2&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtez$sep2&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtez$arg3&#60;&#62;(out, arg0)
val () = fprint_expr_$Ifgtez$rpar&#60;&#62;(out, arg0)
//
}
implement{}
fprint_expr_$Ifgtez$con(out, _) = fprint(out, "Ifgtez")
implement{}
fprint_expr_$Ifgtez$lpar(out, _) = fprint_expr_$lpar(out)
implement{}
fprint_expr_$Ifgtez$rpar(out, _) = fprint_expr_$rpar(out)
implement{}
fprint_expr_$Ifgtez$sep1(out, _) = fprint_expr_$sep&#60;&#62;(out)
implement{}
fprint_expr_$Ifgtez$sep2(out, _) = fprint_expr_$sep&#60;&#62;(out)
implement{}
fprint_expr_$Ifgtez$arg1(out, arg0) =
  let val-Ifgtez(arg1, _, _) = arg0 in fprint_expr_$carg(out, arg1) end
implement{}
fprint_expr_$Ifgtez$arg2(out, arg0) =
  let val-Ifgtez(_, arg2, _) = arg0 in fprint_expr_$carg(out, arg2) end
implement{}
fprint_expr_$Ifgtez$arg3(out, arg0) =
  let val-Ifgtez(_, _, arg3) = arg0 in fprint_expr_$carg(out, arg3) end
//
(* ****** ****** *)
""")</PRE
><P
></P
></DIV
>


The code for <FONT
COLOR="RED"
>fprint_expr_</FONT
> is entirely template-based. This style
makes the code extremely flexible for adaption through template re-mplementation.
As the datatype <FONT
COLOR="RED"
>expr</FONT
> is recursively defined, the following template
implementation needs to be added in order to make <FONT
COLOR="RED"
>fprint_expr_</FONT
> work:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1434"
></A
><PRE
CLASS="programlisting"
>############dats2xhtml_docbook("""implement fprint_expr_$card&#60;expr&#62; = fprint_expr_
""")</PRE
><P
></P
></DIV
>


For instance,
applying <FONT
COLOR="RED"
>fprint_expr_</FONT
>
to the expression <FONT
COLOR="RED"
>Add(Int(10),Mul(Int(1),Int(2)))</FONT
>
outputs the same text representation.

As an example of adaptation, let us add the following template implementations:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1438"
></A
><PRE
CLASS="programlisting"
>############dats2xhtml_docbook("""implement
fprint_expr_$Add$con&#60;&#62; (_, _) = ()
implement
fprint_expr_$Add$sep1&#60;&#62; (out, _) = fprint! (out, "+")
""")</PRE
><P
></P
></DIV
>


When <FONT
COLOR="RED"
>fprint_expr_</FONT
> is applied to the expression
<FONT
COLOR="RED"
>Add(Int(10),Mul(Int(1),Int(2)))</FONT
> this time, the output is
expected to read <FONT
COLOR="RED"
>(Int(10)+Mul(Int(1),Int(2)))</FONT
>.

</P
><P
>&#13;After proper adaptation is done, one can introduce a (non-template)
function as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1444"
></A
><PRE
CLASS="programlisting"
>############dats2xhtml_docbook("""//
extern
fun
fprint_expr
  (out: FILEref, x: expr): void
//
implement
fprint_expr(out, x) = fprint_expr_&#60;&#62;(out, x)
//
""")</PRE
><P
></P
></DIV
>


In this way, only one instance of <FONT
COLOR="RED"
>fprint_expr_</FONT
> is compiled
even if repeated calls to <FONT
COLOR="RED"
>fprint_expr</FONT
> are made.

</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS2TUTORIAL/CODE/CHAP_CODEGEN2"
TARGET="_top"
>on-line</A
>
the entirety of this presented example plus a Makefile (for illustrating
the code generation process).
</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x1397.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Generating a datcontag-function</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c1360.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>&nbsp;</TD
></TR
></TABLE
></DIV
><SCRIPT SRC="./assets/ATS2TUTORIAL-BOOK.js"></SCRIPT></BODY
></HTML
>